<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vysti Marker — Student Check</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/marker.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docx-preview/dist/docx-preview.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <style>
    .assignment-tracker-block {
      margin-bottom: 18px;
      padding: 16px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    .assignment-tracker-title {
      font-size: var(--fs-sm);
      font-weight: 700;
      color: var(--text);
      margin-bottom: 4px;
    }
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .assignment-tracker-help {
      font-size: var(--fs-sm);
      color: var(--muted);
      margin-bottom: 12px;
    }
    .primary-btn.is-loading {
      cursor: progress;
      opacity: 0.95; /* keep readable even while disabled */
    }

    /* Loading indicator: blinking cursor (optional; controlled in JS) */
    @keyframes vysti-caret-blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }
    button.loading-cursor::after {
      content: " \258c"; /* U+258C (left half block) */
      animation: vysti-caret-blink 900ms step-end infinite;
    }

    /* Preview action area (centered button below preview) */
    .preview-actions {
      margin-top: 16px;
      display: flex;
      justify-content: center;
    }
    .preview-actions .primary-btn {
      width: min(360px, 100%);
      margin-top: 0; /* override default .primary-btn margin-top */
    }
    .marked-preview-card {
      margin-top: 24px;
      grid-column: 1 / -1;
    }
    .preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }
    .preview-title {
      margin: 0;
      font-size: var(--fs-h3);
      font-weight: 700;
    }
    .preview-zoom {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: var(--fs-xs);
      color: var(--muted);
    }
    #previewZoom {
      width: auto;
      height: 32px;
      padding: 0 8px;
      border-radius: 8px;
      font-size: var(--fs-xs);
    }
    .marked-preview-container {
      max-height: 600px;
      overflow: auto;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 16px;
      background: #fff;
    }
    .revision-practice-card {
      margin-top: 24px;
      grid-column: 1 / -1;
    }
    .revision-practice-title {
      margin-bottom: 12px;
      font-size: var(--fs-h3);
      font-weight: 700;
      text-align: center;
    }
    .most-common-footer {
      margin-top: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .most-common-word-count,
    .most-common-total-issues {
      font-size: var(--fs-sm);
      font-weight: 600;
      color: var(--text);
    }
    .most-common-techniques {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: #fff;
      text-align: right;
      margin-left: auto;
    }
    .most-common-techniques-title {
      font-size: var(--fs-xs);
      font-weight: 700;
      color: var(--muted);
      margin-bottom: 6px;
      text-transform: none;
      letter-spacing: 0.02em;
    }
    .most-common-techniques-list {
      font-size: var(--fs-sm);
      color: var(--text);
      line-height: 1.4;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .issue-select-wrapper {
      display: none;
    }
    .issue-buttons-wrap {
      display: none;
      flex-direction: column;
      gap: 14px;
    }
    .issue-section-block {
      padding-top: 4px;
    }
    .issue-section-heading {
      text-align: center;
      font-size: var(--fs-sm);
      font-weight: 700;
      color: rgba(0, 0, 0, 0.7);
      margin: 6px 0 8px;
      letter-spacing: 0.02em;
    }
    .issue-button-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    .issue-btn {
      appearance: none;
      border: 1px solid var(--issue-border, #e0e0e0);
      background: var(--issue-bg, #fff);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: var(--fs-xs);
      cursor: pointer;
      transition: border-color 120ms ease, box-shadow 120ms ease, transform 80ms ease, background-color 120ms ease;
    }
    .issue-btn:hover {
      border-color: var(--issue-border, #e0e0e0);
      background: var(--issue-bg-hover, #fff);
    }
    .issue-btn:active {
      transform: translateY(1px);
    }
    .issue-btn.active {
      border-color: var(--issue-border, #e0e0e0);
      box-shadow: 0 0 0 2px var(--issue-ring, rgba(128, 0, 32, 0.15));
    }
    .issue-explanation-header {
      font-weight: 700;
      font-size: var(--fs-sm);
      margin-bottom: 6px;
      padding: 0 12px;
      color: rgba(0, 0, 0, .75);
      text-transform: none;
    }
    .issue-explanation {
      margin-bottom: 16px;
      padding: 12px;
      background: #f8f9fa;
      border-radius: 6px;
      font-size: var(--fs-sm);
      color: var(--text);
    }
    .examples-empty-state {
      margin: 0 0 16px;
      padding: 12px;
      background: #f8f9fa;
      border: 1px solid rgba(0, 0, 0, 0.08);
      border-radius: 8px;
      font-size: var(--fs-sm);
      color: rgba(0, 0, 0, 0.75);
    }
    .mci-tooltip {
      pointer-events: none;
      z-index: 80;
      width: min(380px, calc(100vw - 24px));
      max-width: min(380px, calc(100vw - 24px));
    }
    .mci-tooltip .mci-tooltip-header {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    .mci-tooltip .mci-count {
      font-weight: 600;
      margin-bottom: 6px;
    }
    .mci-tooltip .mci-explanation {
      font-size: var(--fs-sm);
      color: rgba(0, 0, 0, .75);
      line-height: 1.45;
    }
    .mci-tooltip .mci-hint {
      margin-top: 10px;
      font-size: var(--fs-xs);
      font-weight: 700;
      color: rgba(90, 15, 28, 0.75);
    }
    .examples-nav {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin: 6px 0 12px;
      padding: 0 4px;
    }
    .examples-nav-text {
      font-size: var(--fs-xs);
      font-weight: 600;
      color: var(--muted);
    }
    .next-example-btn {
      padding: 6px 12px;
      font-size: var(--fs-xs);
      white-space: nowrap;
    }
    .examples-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .example-item {
      margin-bottom: 20px;
      padding: 16px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    .example-guidance {
      font-size: var(--fs-sm);
      font-weight: 600;
      color: #5a0f1c;
      margin-bottom: 8px;
      padding: 12px;
      background: rgba(169, 13, 34, 0.08);
      border: 1px solid rgba(169, 13, 34, 0.18);
      border-left: 4px solid rgba(169, 13, 34, 0.65);
      border-radius: 6px;
    }
    .example-guidance-label {
      font-weight: 700;
      font-size: var(--fs-xs);
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: rgba(90, 15, 28, 0.75);
      margin-bottom: 6px;
    }
    .example-guidance-text {
      font-weight: 600;
      font-size: var(--fs-sm);
      color: var(--text);
    }
    .example-meta {
      font-size: var(--fs-xs);
      color: var(--muted);
      margin: -2px 0 10px;
      font-weight: 600;
    }
    .example-student {
      font-size: var(--fs-xs);
      color: var(--muted);
      margin-bottom: 12px;
    }
    .example-rewrite {
      width: 100%;
      min-height: 80px;
      max-height: 220px;
      padding: 8px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-size: var(--fs-body);
      font-family: inherit;
      margin-bottom: 8px;
      resize: vertical;
      overflow-y: hidden;
    }
    .example-actions {
      display: flex;
      gap: 8px;
    }
    .power-verbs-helper {
      margin: 6px 0 10px;
    }
    .power-verbs-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 8px;
    }
    .power-verbs-title {
      font-size: var(--fs-sm);
      font-weight: 600;
      color: rgba(0, 0, 0, 0.75);
    }
    .power-verbs-actions {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .power-verbs-feedback {
      font-size: var(--fs-xs);
      color: rgba(0, 0, 0, 0.6);
      min-height: 14px;
    }
    .power-verbs-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .power-verbs-popover {
      width: min(420px, calc(100vw - 24px));
      max-height: 60vh;
      overflow: auto;
      z-index: 120;
    }
    .power-verbs-popover-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 8px;
    }
    .power-verbs-popover-title {
      font-weight: 700;
      font-size: var(--fs-sm);
    }
    .power-verbs-popover-close {
      border: none;
      background: transparent;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
    }
    .power-verbs-popover-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .power-verbs-popover-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 10px;
    }
    .approved-rewrites-wrap {
      margin-top: 16px;
      padding: 14px;
      border-radius: 10px;
      border: 1px solid rgba(53, 133, 53, 0.35);
      background: rgba(231, 245, 231, 0.45);
    }
    .approved-rewrites-title {
      margin: 10px 0 8px;
      font-size: var(--fs-sm);
      font-weight: 700;
      color: #2d5a2d;
    }
    .approved-rewrites-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .approved-rewrites-toggle {
      border: 1px solid rgba(53, 133, 53, 0.35);
      background: rgba(241, 251, 241, 0.9);
      color: #2d5a2d;
      font-size: var(--fs-xs);
      font-weight: 700;
      border-radius: 999px;
      padding: 6px 12px;
      cursor: pointer;
    }
    .approved-rewrites-toggle:hover {
      background: rgba(224, 244, 224, 0.95);
    }
    .approved-rewrites-wrap[data-collapsed="true"] .approved-rewrites-list {
      display: none;
    }
    .approved-rewrites-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .approved-rewrite-card {
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #a8d5a8;
      background: #f1fbf1;
    }
    .approved-rewrite-label {
      font-size: var(--fs-xs);
      font-weight: 700;
      color: #2d5a2d;
      margin-bottom: 6px;
    }
    .approved-rewrite-text {
      font-size: var(--fs-sm);
      color: var(--text);
      margin-bottom: 8px;
      white-space: pre-wrap;
    }
    .approved-rewrite-actions {
      display: flex;
      gap: 8px;
    }
    .example-btn {
      padding: 7px 12px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      background: #fff;
      font-size: var(--fs-xs);
      cursor: pointer;
    }
    .example-btn:hover {
      background: #f0f0f0;
    }
    .example-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .example-btn.remove-issue-btn {
      border-color: rgba(128, 0, 32, 0.35);
      color: #7a1c1c;
      background: #fff;
    }
    .example-btn.remove-issue-btn:hover {
      background: #fbeaea;
    }
    .apply-to-preview-btn {
      background: #f8f9fa;
      border-color: rgba(0,0,0,.14);
      color: rgba(0,0,0,.75);
    }
    .apply-to-preview-btn.apply-attention,
    #applyAllToPreviewBtn.apply-attention {
      border-color: rgba(128, 0, 32, 0.75);
      outline: 2px solid rgba(128, 0, 32, 0.55);
      box-shadow:
        0 0 0 4px rgba(128, 0, 32, 0.18),
        0 0 14px rgba(128, 0, 32, 0.32);
      animation: applyPulse 1.4s ease-in-out infinite;
    }
    @keyframes applyPulse {
      0% {
        box-shadow:
          0 0 0 0 rgba(128, 0, 32, 0.22),
          0 0 10px rgba(128, 0, 32, 0.28);
      }
      60% {
        box-shadow:
          0 0 0 8px rgba(128, 0, 32, 0),
          0 0 16px rgba(128, 0, 32, 0.18);
      }
      100% {
        box-shadow:
          0 0 0 0 rgba(128, 0, 32, 0),
          0 0 12px rgba(128, 0, 32, 0.24);
      }
    }
    .apply-all-btn {
      margin-top: 12px;
      width: 100%;
    }
    .apply-to-preview-btn:not(:disabled):hover {
      background: #e9ecef;
    }
    .example-applied {
      opacity: 0.7;
      background: #f0f0f0;
    }
    .example-item.example-approved {
      background: #e7f5e7;
      border-color: #a8d5a8;
    }
    .example-dismissed {
      background: #f9f2f2;
      border-color: #e7cfcf;
    }
    .hidden-select {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      width: 0;
      height: 0;
    }
    .rewrite-status {
      margin-top: 8px;
      padding: 8px;
      border-radius: 6px;
      font-size: var(--fs-xs);
      display: none;
    }
    .rewrite-status.visible {
      display: block;
    }
    .rewrite-status.ok {
      background: #e7f5e7;
      color: #2d5a2d;
      border: 1px solid #a8d5a8;
    }
    .rewrite-status.bad {
      background: #ffe7e7;
      color: #5a2d2d;
      border: 1px solid #d5a8a8;
    }
    .rewrite-status.checking {
      background: #eef3f8;
      color: #1f3b5b;
      border: 1px solid #c6d7ea;
    }
    .rewrite-status.checking::after {
      content: "...";
      display: inline-block;
      width: 0;
      overflow: hidden;
      vertical-align: bottom;
      animation: rewriteDots 1s steps(4, end) infinite;
    }
    @keyframes rewriteDots {
      to { width: 1.25em; }
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <img src="/assets/logo.svg" alt="Vysti" />
    </div>
  
    <nav>
      <a href="/student.html" class="active">Student Check</a>
    </nav>
  
    <div class="actions">
      <button class="topbar-btn" id="switchModeBtn" type="button">Switch to Teacher Mode</button>
      <button class="iconbtn repeat-tutorial-trigger" id="repeatTutorialBtn" type="button" aria-label="Repeat tutorial" data-tip="Repeat the tutorial">?</button>
      <button class="topbar-btn" id="logoutBtn" type="button">Sign Out</button>
    </div>
  </header>

  <main class="page student-page">
    <form id="studentForm" class="marker-grid" style="display:none;">
      <section class="card form-card">
        <label>
          <span class="label-row mode-select-label-row">
            <span class="visually-hidden">Assignment type</span>
          </span>
          <select id="mode" aria-label="Assignment type">
            <option value="textual_analysis">Analytic essay</option>
            <option value="peel_paragraph">Mini-essay paragraph</option>
            <option value="reader_response">Reader response</option>
            <option value="argumentation">Argumentation</option>
          </select>
        </label>

        <!-- Mode explainer card (single, dynamic) -->
        <div class="mode-card" id="modeCard">
          <div class="mode-card-header">
            <span class="mode-badge" id="modeBadge">Analytic essay</span>
            <span class="mode-tag" id="modeTag"></span>
          </div>

          <div class="mode-desc" id="modeDesc">
            A formal and academic essay of analysis with all Vysti Rules running.
          </div>

          <button type="button" class="mode-more" id="modeMoreBtn" aria-expanded="false">
            Want more details?
          </button>

          <div class="mode-details" id="modeDetails" hidden>
            <ul id="modeDetailsList"></ul>
          </div>
        </div>

        <div class="assignment-tracker-block">
          <div class="assignment-tracker-title">
            <span class="label-row">
              Assignment Tracker
            </span>
          </div>
          <label class="visually-hidden" for="assignmentName">Assignment name (optional)</label>
          <input type="text" id="assignmentName" placeholder="Assignment 01" aria-label="Assignment name (optional)" />
        </div>

        <div id="statsPanel" class="student-stats-panel" style="display:none;">
          <div class="student-stats-title">At a glance</div>

          <div class="student-stats-grid">
            <div class="student-stat">
              <div class="student-stat-label">Word count</div>
              <div id="wordCountStat" class="student-stat-value">—</div>
            </div>

            <div class="student-stat">
              <div class="student-stat-label">Total issues</div>
              <div id="totalIssuesStat" class="student-stat-value">—</div>
            </div>
          </div>

          <div id="topIssueRow" class="student-stat-row" style="display:none;">
            <div class="student-stat-label">Most common</div>
            <div id="topIssueStat" class="student-stat-text"></div>
          </div>

          <div class="student-metrics-grid" id="metricsGrid">
            <div class="metric-card" id="metricPower">
              <div class="metric-head">
                <div class="metric-title">
                  Power
                  <button class="metric-info metric-info-btn" type="button" data-metric="power" aria-label="Power info">i</button>
                </div>
                <div class="metric-score" id="powerScoreText">—</div>
              </div>
              <div class="metric-meter">
                <div class="metric-meter-fill" id="powerMeterFill"></div>
              </div>
              <div class="metric-sub" id="powerSubText"></div>
            </div>

            <div class="metric-card" id="metricVariety">
              <div class="metric-head">
                <div class="metric-title">
                  Variety
                  <button class="metric-info metric-info-btn" type="button" data-metric="variety" aria-label="Variety info">i</button>
                </div>
                <div class="metric-score" id="varietyScoreText">—</div>
              </div>
              <div class="metric-meter">
                <div class="metric-meter-fill" id="varietyMeterFill"></div>
              </div>
              <div class="metric-sub" id="varietySubText"></div>
            </div>

            <div class="metric-card" id="metricCohesion">
              <div class="metric-head">
                <div class="metric-title">
                  Cohesion
                  <button class="metric-info metric-info-btn" type="button" data-metric="cohesion" aria-label="Cohesion info">i</button>
                </div>
                <div class="metric-score" id="cohesionScoreText">—</div>
              </div>
              <div class="metric-meter">
                <div class="metric-meter-fill" id="cohesionMeterFill"></div>
              </div>
              <div class="metric-sub" id="cohesionSubText"></div>
            </div>

            <div class="metric-card" id="metricPrecision">
              <div class="metric-head">
                <div class="metric-title">
                  Precision
                  <button class="metric-info metric-info-btn" type="button" data-metric="precision" aria-label="Precision info">i</button>
                </div>
                <div class="metric-score" id="precisionScoreText">—</div>
              </div>
              <div class="metric-meter">
                <div class="metric-meter-fill" id="precisionMeterFill"></div>
              </div>
              <div class="metric-sub" id="precisionSubText"></div>
            </div>
          </div>

          <div id="techniquesStatWrap" class="student-techniques" style="display:none;">
            <div class="student-stat-label">Range of techniques</div>
            <div id="techniquesStatList" class="student-techniques-list"></div>
          </div>
        </div>

        <button class="primary-btn" id="checkBtn" type="submit" disabled>Mark my essay</button>
      </section>

      <section class="card upload-card">
        <label>Upload</label>
        
        <div id="dropZone" class="drop-zone" tabindex="0" role="button" aria-label="Upload .docx file">
          <img class="dz-icon" src="/assets/cloud-upload.svg" alt="" aria-hidden="true" />
          <div class="dz-title">Drag & drop .docx file here</div>
          <div class="dz-sub">or click to browse</div>
          
          <input
            type="file"
            id="fileInput"
            name="file"
            accept=".docx"
            hidden
          />
        </div>

        <ul id="fileList" class="file-list"></ul>
        <button type="button" id="clearFileBtn" class="secondary-btn" style="display:none;">Clear file</button>
      </section>

      <section class="card rules-card" id="resultsCard" style="display:none;">
        <div id="statusArea" class="status-area" role="status" aria-live="polite"></div>

        <button id="downloadBtn" class="secondary-btn" type="button" style="display:none; margin-top:12px;">
          Download marked essay
        </button>

        <div id="mostCommonIssuesWrap" style="margin-top: 20px; display:none;">
          <div class="rules-title">Most Common Issues</div>
          <div id="mciScrollViewport" class="mci-scroll-viewport">
            <div id="mciScrollInner" class="mci-scroll-inner">
              <canvas id="mostCommonIssuesChart"></canvas>
            </div>
          </div>
        </div>
      </section>
    </form>

    <section class="card revision-practice-card" id="revisionPracticeCard" style="display:none;">
      <h2 class="revision-practice-title">Revision examples</h2>
      <div class="issue-select-wrapper">
        <!-- New UI -->
        <div id="issueButtonsWrap" class="issue-buttons-wrap"></div>

        <!-- Keep old selects for existing JS, but hide them -->
        <div class="issue-selects-hidden" style="display:none;">
          <label>
            Select a section
            <select id="sectionSelect"></select>
          </label>
          <label>
            Select an issue to practice
            <select id="issueSelect"></select>
          </label>
        </div>
      </div>
      <div id="issueExplanationBlock" style="display:none;">
        <div class="issue-explanation-header">Explanation of the Issue</div>
        <div id="issueExplanation" class="issue-explanation"></div>
      </div>
      <div id="allApprovedBanner" class="examples-empty-state" style="display:none;">
        All examples for this issue are approved. Apply them to the Preview to update your progress, then click another bar to revise a different issue.
      </div>
      <div id="examplesEmptyState" class="examples-empty-state" style="display:none;"></div>
      <div id="exampleNavRow" class="examples-nav" style="display:none;">
        <div id="exampleNavText" class="examples-nav-text">Issue 0 of 0</div>
        <button type="button" class="secondary-btn next-example-btn" id="nextExampleBtn">Next →</button>
      </div>
      <ul id="examplesList" class="examples-list"></ul>
      <div id="approvedRewritesWrap" class="approved-rewrites-wrap" style="display:none;" data-collapsed="true">
        <button type="button" class="secondary-btn apply-all-btn apply-to-preview-btn" id="applyAllToPreviewBtn" style="display:none;" disabled>Apply all rewrites to Preview</button>
        <div class="approved-rewrites-header">
          <div class="approved-rewrites-title">Approved rewrites</div>
          <button type="button" class="approved-rewrites-toggle" id="approvedRewritesToggle" aria-expanded="false">Show approved rewrites</button>
        </div>
        <ul id="approvedRewritesList" class="approved-rewrites-list"></ul>
      </div>
      <button type="button" class="secondary-btn" id="downloadRevisionNotesBtn" style="margin-top: 16px; display:none;">Download revision notes</button>
    </section>

    <section class="card marked-preview-card" id="markedPreviewCard" style="display:none;">
      <div class="preview-header">
        <h2 class="preview-title">Preview</h2>
        <label class="preview-zoom" for="previewZoom">
          <span>Zoom</span>
          <select id="previewZoom">
            <option value="0.8">80%</option>
            <option value="0.9">90%</option>
            <option value="1">100%</option>
            <option value="1.1">110%</option>
            <option value="1.25">125%</option>
            <option value="1.5" selected>150%</option>
          </select>
        </label>
      </div>
      <div id="markedPreview" class="marked-preview-container"></div>

      <!-- Recheck moved here: centered under Preview + styled like primary button -->
      <div class="preview-actions">
        <button type="button" class="primary-btn" id="recheckDocumentBtn" style="display:none;" disabled>Recheck my essay</button>
      </div>
    </section>
    <footer class="marker-footer" aria-label="Site footer">
      <div class="footer-copy">© 2025 Vysti Research. All rights reserved.</div>
      <img class="footer-logo" src="/assets/logo_black.png" alt="Vysti" />
    </footer>
  </main>

  <div id="dismissIssueOverlay" class="modal-overlay hidden">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="dismissIssueTitle">
      <div id="dismissIssueTitle" class="modal-title">Dismiss issue</div>
      <div class="modal-body">
        <div class="modal-question">Why are you dismissing this issue?</div>
        <label><input type="radio" name="dismissReason" value="no_issue"> There is no issue</label>
        <label><input type="radio" name="dismissReason" value="unable_to_repair"> Unable to repair issue</label>
        <label><input type="radio" name="dismissReason" value="unclear_guidance"> Unclear student guidance for issue</label>
        <label><input type="radio" name="dismissReason" value="other"> Other</label>
        <textarea id="dismissOtherText" maxlength="280" class="hidden" placeholder="Briefly explain..."></textarea>
        <div id="dismissCharCount" class="hidden">0/280</div>
        <div id="dismissError" class="modal-error hidden"></div>
      </div>
      <div class="modal-actions">
        <button id="dismissCancelBtn" class="secondary-btn">Cancel</button>
        <button id="dismissConfirmBtn" class="primary-btn">Dismiss issue</button>
      </div>
    </div>
  </div>

  <div id="brandConfirmOverlay" class="brand-confirm-overlay" hidden>
    <div class="brand-confirm-popover" role="dialog" aria-modal="true" aria-labelledby="brandConfirmTitle">
      <button class="brand-confirm-close" type="button" aria-label="Close dialog">×</button>
      <div id="brandConfirmTitle" class="brand-confirm-title">Confirm</div>
      <div id="brandConfirmBody" class="brand-confirm-body"></div>
      <div class="brand-confirm-actions">
        <button id="brandConfirmCancel" class="brand-confirm-cancel" type="button">Cancel</button>
        <button id="brandConfirmOk" class="brand-confirm-ok" type="button">Remove</button>
      </div>
    </div>
  </div>

  <div id="metricInfoPopover" class="tour-popover metric-popover hidden" role="dialog" aria-modal="false">
    <button id="metricInfoClose" class="tour-close" type="button" aria-label="Close">×</button>
    <div id="metricInfoTitle" class="tour-title"></div>
    <div id="metricInfoBody" class="tour-body"></div>
  </div>

  <script>
    const DEBUG_METRICS = false;
    const DEBUG_REVISION_BARS = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";

    // ===== Bucket definitions =====
    const LABEL_BUCKETS = [
      {
        id: "thesis_org",
        name: "Thesis & Organization",
        matchers: [
          /thesis/i,
          /topic sentence/i,
          /organization/i,
          /transition/i,
          /boundary statement/i,
          /introduction/i,
          /conclusion/i,
          /paragraph/i,
          /structure/i
        ]
      },
      {
        id: "evidence_integration",
        name: "Evidence & Integration",
        matchers: [
          /quote/i,
          /quotation/i,
          /evidence/i,
          /citation/i,
          /\bcite\b/i,
          /works cited/i,
          /power verbs/i,
          /support/i
        ]
      },
      {
        id: "voice_audience",
        name: "Voice & Audience",
        matchers: [
          /personal pronoun/i,
          /\bI\b/i,
          /\bwe\b/i,
          /\byou\b/i,
          /reader/i,
          /audience/i
        ]
      },
      {
        id: "style_clarity",
        name: "Style & Clarity",
        matchers: [
          /contraction/i,
          /\bwhich\b/i,
          /\bfact\b/i,
          /\bprove\b/i,
          /weak verb/i,
          /article/i,
          /vague/i,
          /people/i,
          /human/i,
          /word choice/i,
          /avoid using the word/i,
          /more than once in a sentence/i
        ]
      },
      {
        id: "grammar_mechanics",
        name: "Grammar & Mechanics",
        matchers: [
          /subject[- ]verb/i,
          /agreement/i,
          /tense/i,
          /comma/i,
          /punctuation/i,
          /spelling/i,
          /apostrophe/i
        ]
      },
      {
        id: "formatting",
        name: "Formatting & Conventions",
        matchers: [
          /MLA/i,
          /header/i,
          /format/i,
          /title/i,
          /author/i
        ]
      },
      { id: "other", name: "Other", matchers: [] }
    ];

    const BUCKET_OVERRIDES = {
      "Avoid quotations in the conclusion": "evidence_integration",
      "Avoid quotations in the introduction": "evidence_integration",
      "Clarify pronouns and antecedents": "grammar_mechanics",
      "Avoid weak verbs": "evidence_integration"
    };

    // Shared bucket color palette (same order as LABEL_BUCKETS)
    // Thesis maroon, Evidence blue, Voice green, Style yellow, Grammar purple, Formatting red, Other teal
    const BUCKET_COLORS = [
      "rgba(169, 13, 34, 1)",    // maroon - Thesis & Organization
      "rgba(52, 152, 219, 1)",   // blue - Evidence & Integration
      "rgba(46, 204, 113, 1)",   // green - Voice & Audience
      "rgba(241, 196, 15, 1)",   // yellow - Style & Clarity
      "rgba(155, 89, 182, 1)",   // purple - Grammar & Mechanics
      "rgba(231, 76, 60, 1)",    // red - Formatting & Conventions
      "rgba(26, 188, 156, 1)",   // teal - Other
    ];

    // Helper function to get bucket color by bucketId
    // Returns color with specified alpha (default 1.0 for full opacity)
    function getBucketColor(bucketId, alpha = 1.0) {
      const bucketIndex = LABEL_BUCKETS.findIndex(b => b.id === bucketId);
      if (bucketIndex === -1) {
        // Fallback to "other" color if bucket not found
        const otherIndex = LABEL_BUCKETS.findIndex(b => b.id === "other");
        const baseColor = BUCKET_COLORS[otherIndex >= 0 ? otherIndex : BUCKET_COLORS.length - 1];
        return baseColor.replace("1)", `${alpha})`);
      }
      const baseColor = BUCKET_COLORS[bucketIndex];
      return baseColor.replace("1)", `${alpha})`);
    }

    function getBucketIdForLabel(label) {
      if (!label) return "other";
      if (BUCKET_OVERRIDES[label]) return BUCKET_OVERRIDES[label];
      for (const b of LABEL_BUCKETS) {
        if (b.id === "other") continue;
        if (b.matchers.some(rx => rx.test(label))) return b.id;
      }
      return "other";
    }

    // ===== Supabase auth setup =====
    const SUPABASE_URL = "https://divdfodsdtfbdwoqvsfy.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRpdmRmb2RzZHRmYmR3b3F2c2Z5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU0MjU1OTksImV4cCI6MjA4MTAwMTU5OX0.fnm_9qX5DqdR0j6y-2mRRkwr8Icm1uRNPbUo6lqzock";

    const { createClient } = supabase;
    const supa = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const form = document.getElementById("studentForm");
    const fileInput = document.getElementById("fileInput");
    const checkBtn = document.getElementById("checkBtn");
    const clearFileBtn = document.getElementById("clearFileBtn");
    const statusArea = document.getElementById("statusArea");
    const resultsCard = document.getElementById("resultsCard");
    const downloadBtn = document.getElementById("downloadBtn");
    const fileList = document.getElementById("fileList");
    const dropZone = document.getElementById("dropZone");
    const markedPreviewCard = document.getElementById("markedPreviewCard");
    const markedPreview = document.getElementById("markedPreview");
    const previewZoom = document.getElementById("previewZoom");
    const revisionPracticeCard = document.getElementById("revisionPracticeCard");
    const sectionSelect = document.getElementById("sectionSelect");
    const issueSelect = document.getElementById("issueSelect");
    const issueButtonsWrap = document.getElementById("issueButtonsWrap");
    const issueExplanationBlock = document.getElementById("issueExplanationBlock");
    const issueExplanation = document.getElementById("issueExplanation");
    const exampleNavRow = document.getElementById("exampleNavRow");
    const exampleNavText = document.getElementById("exampleNavText");
    const nextExampleBtn = document.getElementById("nextExampleBtn");
    const examplesList = document.getElementById("examplesList");
    const allApprovedBanner = document.getElementById("allApprovedBanner");
    const examplesEmptyState = document.getElementById("examplesEmptyState");
    const applyAllToPreviewBtn = document.getElementById("applyAllToPreviewBtn");
    const approvedRewritesWrap = document.getElementById("approvedRewritesWrap");
    const approvedRewritesList = document.getElementById("approvedRewritesList");
    const approvedRewritesToggle = document.getElementById("approvedRewritesToggle");
    const recheckDocumentBtn = document.getElementById("recheckDocumentBtn");
    const downloadRevisionNotesBtn = document.getElementById("downloadRevisionNotesBtn");
    const mostCommonIssuesWrap = document.getElementById("mostCommonIssuesWrap");
    const mciScrollViewport = document.getElementById("mciScrollViewport");
    const mciScrollInner = document.getElementById("mciScrollInner");
    const mostCommonIssuesChartEl = document.getElementById("mostCommonIssuesChart");
    const brandConfirmOverlay = document.getElementById("brandConfirmOverlay");
    const dismissIssueOverlay = document.getElementById("dismissIssueOverlay");
    const dismissOtherText = document.getElementById("dismissOtherText");
    const dismissCharCount = document.getElementById("dismissCharCount");
    const dismissError = document.getElementById("dismissError");
    const dismissCancelBtn = document.getElementById("dismissCancelBtn");
    const dismissConfirmBtn = document.getElementById("dismissConfirmBtn");

    if (brandConfirmOverlay) {
      brandConfirmOverlay.hidden = true;
      brandConfirmOverlay.setAttribute("hidden", "");
    }
    if (dismissIssueOverlay) {
      dismissIssueOverlay.classList.add("hidden");
    }

    if (approvedRewritesToggle) {
      approvedRewritesToggle.addEventListener("click", () => {
        setApprovedRewritesCollapsed(!approvedRewritesCollapsed);
        updateApprovedRewritesToggle(approvedRewritesList ? approvedRewritesList.children.length : 0);
      });
    }

    let mostCommonIssuesChart = null;
    const modeSelect = document.getElementById("mode");
    const assignmentNameInput = document.getElementById("assignmentName");
    const statsPanel = document.getElementById("statsPanel");
    const wordCountStat = document.getElementById("wordCountStat");
    const totalIssuesStat = document.getElementById("totalIssuesStat");
    const topIssueRow = document.getElementById("topIssueRow");
    const topIssueStat = document.getElementById("topIssueStat");
    const techniquesStatWrap = document.getElementById("techniquesStatWrap");
    const techniquesStatList = document.getElementById("techniquesStatList");
    const metricsGrid = document.getElementById("metricsGrid");
    const metricPowerCard = document.getElementById("metricPower");
    const metricVarietyCard = document.getElementById("metricVariety");
    const metricCohesionCard = document.getElementById("metricCohesion");
    const metricPrecisionCard = document.getElementById("metricPrecision");
    const powerScoreText = document.getElementById("powerScoreText");
    const powerMeterFill = document.getElementById("powerMeterFill");
    const powerSubText = document.getElementById("powerSubText");
    const varietyScoreText = document.getElementById("varietyScoreText");
    const varietyMeterFill = document.getElementById("varietyMeterFill");
    const varietySubText = document.getElementById("varietySubText");
    const cohesionScoreText = document.getElementById("cohesionScoreText");
    const cohesionMeterFill = document.getElementById("cohesionMeterFill");
    const cohesionSubText = document.getElementById("cohesionSubText");
    const precisionScoreText = document.getElementById("precisionScoreText");
    const precisionMeterFill = document.getElementById("precisionMeterFill");
    const precisionSubText = document.getElementById("precisionSubText");
    const metricInfoPopover = document.getElementById("metricInfoPopover");
    const metricInfoClose = document.getElementById("metricInfoClose");
    const metricInfoTitle = document.getElementById("metricInfoTitle");
    const metricInfoBody = document.getElementById("metricInfoBody");

    let selectedFile = null;
    const buttonLoadingTimers = new Map();
    let downloadUrl = null;
    let markedBlob = null;
    let currentMarkEvent = null;
    let lastRevisionSectionData = null;
    let currentWordCount = null;
    let currentTechniques = [];
    let detectedWork = null;
    let hasStartedRevising = false;
    let liveLabelCounts = {};
    let dismissedIssues = [];
    let lastStudentMetrics = null;

    const appliedExampleKeys = new Set();
    const approvedExampleKeys = new Set();
    let currentLabel = null;
    let currentExamplesAll = [];
    let currentIndex = 0;
    let currentGuidance = "";
    let currentLabelText = "";
    const draftRewriteByKey = new Map();
    const approvedRewriteByKey = new Map();
    const exampleDataByKey = new Map();
    const examplesByIssueId = new Map();
    const approvedRewrites = [];
    let currentExampleKey = null;
    let approvedRewritesCollapsed = true;
    const issueIdByLabel = new Map();
    const labelByIssueId = new Map();
    const PREVIEW_ONLY_LABELS = new Set([
      "No quotations in topic sentence"
    ]);
    const POWER_VERBS_LABEL = "Avoid weak verbs";
    const POWER_VERBS_INITIAL_COUNT = 5;
    const POWER_VERBS_PAGE_COUNT = 10;
    const POWER_VERBS_STORAGE_PREFIX = "vysti_power_verbs_2025";

    let powerVerbsList = null;
    let powerVerbsLoadPromise = null;
    let activePowerVerbsHelper = null;
    const powerVerbsState = {
      label: null,
      initialVerbs: [],
      pageHistory: [],
      pageIndex: 0,
      recentlyShown: []
    };
    const powerVerbsPopover = {
      el: null,
      grid: null,
      feedback: null,
      nextBtn: null,
      prevBtn: null,
      closeBtn: null,
      anchor: null,
      textarea: null,
      isOpen: false,
      onDocumentClick: null,
      onKeyDown: null,
      onReposition: null
    };

    function hideMarkButtonShowRecheck() {
      if (checkBtn) checkBtn.style.display = "none";
      if (recheckDocumentBtn) recheckDocumentBtn.style.display = "block";
    }

    function showMarkButtonHideRecheck() {
      if (checkBtn) checkBtn.style.display = "block";
      if (recheckDocumentBtn) recheckDocumentBtn.style.display = "none";
    }

    function normLabel(s) {
      return String(s || "").trim().toLowerCase();
    }

    function resetIssueIdMaps() {
      issueIdByLabel.clear();
      labelByIssueId.clear();
    }

    function normalizeIssueId(label) {
      const slug = String(label || "")
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
      return slug || "issue";
    }

    function registerIssueId(label, idCandidate = "") {
      const cleanLabel = String(label || "").trim();
      if (!cleanLabel) return "";
      if (issueIdByLabel.has(cleanLabel)) return issueIdByLabel.get(cleanLabel);
      let base = String(idCandidate || "").trim();
      if (!base) base = normalizeIssueId(cleanLabel);
      let issueId = base;
      let counter = 1;
      while (labelByIssueId.has(issueId) && labelByIssueId.get(issueId) != cleanLabel) {
        issueId = `${base}-${counter}`;
        counter += 1;
      }
      issueIdByLabel.set(cleanLabel, issueId);
      labelByIssueId.set(issueId, cleanLabel);
      return issueId;
    }

    function syncIssueIdMaps(issues, labelCounts) {
      resetIssueIdMaps();
      (issues || []).forEach((issue) => {
        if (!issue || !issue.label) return;
        const issueId = issue.id || issue.issue_id || issue.issueId || "";
        registerIssueId(issue.label, issueId);
      });
      Object.keys(labelCounts || {}).forEach((label) => {
        registerIssueId(label);
      });
    }

    function getIssueIdForLabel(label) {
      return registerIssueId(label);
    }

    function getLabelForIssueId(issueId) {
      return labelByIssueId.get(issueId) || "";
    }

    function auditRevisionIssueBindings({ issueIds = [], labels = [], source = "" } = {}) {
      if (!DEBUG_REVISION_BARS) return;
      const missingIds = [];
      issueIds.forEach((id, idx) => {
        if (!id) {
          missingIds.push({ index: idx, label: labels[idx] || "" });
          return;
        }
        if (!getLabelForIssueId(id)) {
          console.warn("No label mapped for issueId:", id, "source:", source);
        }
      });
      if (missingIds.length) {
        console.warn("Missing issueIds for revision issues:", missingIds, "source:", source);
      }
      if (source === "buttons" && issueButtonsWrap) {
        const btns = issueButtonsWrap.querySelectorAll(".issue-btn");
        btns.forEach((btn) => {
          if (!btn.dataset.issueId) {
            console.warn("Issue button missing issueId:", btn.textContent || "(no label)");
          }
        });
      }
    }

    function isPreviewOnlyLabel(label) {
      const target = normLabel(label);
      for (const lbl of PREVIEW_ONLY_LABELS) {
        if (normLabel(lbl) === target) return true;
      }
      return false;
    }

    function isAvoidWeakVerbsLabel(label) {
      return normLabel(label) === normLabel(POWER_VERBS_LABEL);
    }

    function getPowerVerbsStorageKey(label) {
      const assignmentKey = selectedFile?.name || assignmentNameInput?.value?.trim() || "nofile";
      return `${POWER_VERBS_STORAGE_PREFIX}_${assignmentKey}__${normLabel(label || "")}`;
    }

    function normalizePowerVerbs(data) {
      const list = Array.isArray(data) ? data : [];
      const verbs = [];
      const seen = new Set();
      list.forEach((item) => {
        const value = typeof item === "string" ? item : item?.verb;
        if (!value) return;
        const trimmed = String(value).trim();
        if (!trimmed) return;
        const key = trimmed.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        verbs.push(trimmed);
      });
      return verbs;
    }

    function loadPowerVerbsList() {
      if (powerVerbsList) return Promise.resolve(powerVerbsList);
      if (powerVerbsLoadPromise) return powerVerbsLoadPromise;
      powerVerbsLoadPromise = fetch("power_verbs_2025.json")
        .then((res) => res.ok ? res.json() : [])
        .then((data) => {
          powerVerbsList = normalizePowerVerbs(data);
          return powerVerbsList;
        })
        .catch((error) => {
          console.warn("Failed to load power verbs:", error);
          powerVerbsList = [];
          return powerVerbsList;
        });
      return powerVerbsLoadPromise;
    }

    function sampleUnique(list, count, excludeSet = null) {
      const pool = excludeSet
        ? list.filter((item) => !excludeSet.has(item))
        : list.slice();
      if (pool.length <= count) return pool.slice();
      for (let i = pool.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }
      return pool.slice(0, count);
    }

    function loadStoredPowerVerbs(label) {
      const key = getPowerVerbsStorageKey(label);
      try {
        const raw = localStorage.getItem(key);
        const parsed = raw ? JSON.parse(raw) : [];
        return Array.isArray(parsed) ? parsed.filter(Boolean) : [];
      } catch (error) {
        console.warn("Failed to load stored power verbs:", error);
        return [];
      }
    }

    function storePowerVerbs(label, verbs) {
      const key = getPowerVerbsStorageKey(label);
      try {
        localStorage.setItem(key, JSON.stringify(verbs || []));
      } catch (error) {
        console.warn("Failed to store power verbs:", error);
      }
    }

    function ensureInitialPowerVerbs(label) {
      if (!isAvoidWeakVerbsLabel(label)) return;
      if (powerVerbsState.initialVerbs.length) return;
      const stored = loadStoredPowerVerbs(label);
      if (stored.length) {
        powerVerbsState.initialVerbs = stored.slice(0, POWER_VERBS_INITIAL_COUNT);
        return;
      }
      if (!powerVerbsList || !powerVerbsList.length) return;
      const verbs = sampleUnique(powerVerbsList, POWER_VERBS_INITIAL_COUNT);
      powerVerbsState.initialVerbs = verbs;
      storePowerVerbs(label, verbs);
    }

    function showPowerVerbFeedback(targetEl, message) {
      if (!targetEl) return;
      targetEl.textContent = message;
      if (targetEl._timer) clearTimeout(targetEl._timer);
      targetEl._timer = setTimeout(() => {
        if (targetEl) targetEl.textContent = "";
      }, 1800);
    }

    function insertVerbIntoTextarea(textarea, verb) {
      if (!textarea || document.activeElement !== textarea) return false;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      if (typeof start !== "number" || typeof end !== "number") return false;
      const before = textarea.value.slice(0, start);
      const after = textarea.value.slice(end);
      const needsSpaceBefore = before && !/\s$/.test(before);
      const needsSpaceAfter = after && !/^\s/.test(after);
      const insertText = `${needsSpaceBefore ? " " : ""}${verb}${needsSpaceAfter ? " " : ""}`;
      textarea.value = before + insertText + after;
      const cursor = before.length + insertText.length;
      textarea.setSelectionRange(cursor, cursor);
      textarea.dispatchEvent(new Event("input", { bubbles: true }));
      return true;
    }

    function handlePowerVerbClick(verb, { feedbackEl, textarea } = {}) {
      const didInsert = insertVerbIntoTextarea(textarea, verb);
      const copy = navigator.clipboard?.writeText
        ? navigator.clipboard.writeText(verb)
        : Promise.reject(new Error("Clipboard unavailable"));
      copy
        .then(() => showPowerVerbFeedback(feedbackEl, "Copied!"))
        .catch(() => {
          if (didInsert) {
            showPowerVerbFeedback(feedbackEl, "Inserted!");
          } else {
            showPowerVerbFeedback(feedbackEl, "Copy failed");
          }
        });
    }

    function renderPowerVerbButtons(container, verbs, { feedbackEl, textarea } = {}) {
      if (!container) return;
      container.innerHTML = "";
      if (!verbs || !verbs.length) {
        container.textContent = "Loading suggestions...";
        return;
      }
      verbs.forEach((verb) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "example-btn power-verb-pill";
        btn.textContent = verb;
        btn.addEventListener("click", () => handlePowerVerbClick(verb, { feedbackEl, textarea }));
        container.appendChild(btn);
      });
    }

    function createPowerVerbsPage() {
      if (!powerVerbsList || !powerVerbsList.length) return [];
      const exclude = new Set(powerVerbsState.recentlyShown || []);
      let page = sampleUnique(powerVerbsList, POWER_VERBS_PAGE_COUNT, exclude);
      if (page.length < POWER_VERBS_PAGE_COUNT) {
        page = page.concat(sampleUnique(powerVerbsList, POWER_VERBS_PAGE_COUNT - page.length));
      }
      powerVerbsState.recentlyShown = [...powerVerbsState.recentlyShown, ...page].slice(-40);
      return page;
    }

    function updatePowerVerbsPopoverNav() {
      if (!powerVerbsPopover.prevBtn || !powerVerbsPopover.nextBtn) return;
      powerVerbsPopover.prevBtn.style.display = powerVerbsState.pageIndex > 0 ? "inline-flex" : "none";
    }

    function renderPowerVerbsPopoverPage() {
      if (!powerVerbsPopover.grid) return;
      const page = powerVerbsState.pageHistory[powerVerbsState.pageIndex] || [];
      renderPowerVerbButtons(powerVerbsPopover.grid, page, {
        feedbackEl: powerVerbsPopover.feedback,
        textarea: powerVerbsPopover.textarea
      });
      updatePowerVerbsPopoverNav();
    }

    function goToPowerVerbsPage(index) {
      if (index < 0) return;
      if (index >= powerVerbsState.pageHistory.length) {
        powerVerbsState.pageHistory.push(createPowerVerbsPage());
      }
      powerVerbsState.pageIndex = index;
      renderPowerVerbsPopoverPage();
    }

    function positionPowerVerbsPopover() {
      if (!powerVerbsPopover.el || !powerVerbsPopover.anchor) return;
      const gap = 8;
      const padding = 12;
      const anchorRect = powerVerbsPopover.anchor.getBoundingClientRect();

      powerVerbsPopover.el.style.display = "block";
      powerVerbsPopover.el.style.visibility = "hidden";
      const popRect = powerVerbsPopover.el.getBoundingClientRect();
      const fitsBelow = anchorRect.bottom + gap + popRect.height <= window.innerHeight;

      let top = fitsBelow
        ? anchorRect.bottom + gap
        : anchorRect.top - popRect.height - gap;
      top = Math.max(padding, Math.min(top, window.innerHeight - popRect.height - padding));

      let left = anchorRect.right - popRect.width;
      left = Math.max(padding, Math.min(left, window.innerWidth - popRect.width - padding));

      powerVerbsPopover.el.style.top = `${Math.round(top)}px`;
      powerVerbsPopover.el.style.left = `${Math.round(left)}px`;
      powerVerbsPopover.el.style.visibility = "visible";
    }

    function attachPowerVerbsPopoverListeners() {
      if (powerVerbsPopover.onDocumentClick) return;
      powerVerbsPopover.onDocumentClick = (event) => {
        const target = event.target;
        if (powerVerbsPopover.el?.contains(target)) return;
        if (powerVerbsPopover.anchor?.contains(target)) return;
        closePowerVerbsPopover();
      };
      powerVerbsPopover.onKeyDown = (event) => {
        if (event.key === "Escape") closePowerVerbsPopover();
      };
      powerVerbsPopover.onReposition = () => {
        if (powerVerbsPopover.isOpen) positionPowerVerbsPopover();
      };
      document.addEventListener("mousedown", powerVerbsPopover.onDocumentClick, true);
      document.addEventListener("touchstart", powerVerbsPopover.onDocumentClick, true);
      document.addEventListener("keydown", powerVerbsPopover.onKeyDown, true);
      window.addEventListener("resize", powerVerbsPopover.onReposition);
      window.addEventListener("scroll", powerVerbsPopover.onReposition, true);
    }

    function detachPowerVerbsPopoverListeners() {
      if (!powerVerbsPopover.onDocumentClick) return;
      document.removeEventListener("mousedown", powerVerbsPopover.onDocumentClick, true);
      document.removeEventListener("touchstart", powerVerbsPopover.onDocumentClick, true);
      document.removeEventListener("keydown", powerVerbsPopover.onKeyDown, true);
      window.removeEventListener("resize", powerVerbsPopover.onReposition);
      window.removeEventListener("scroll", powerVerbsPopover.onReposition, true);
      powerVerbsPopover.onDocumentClick = null;
      powerVerbsPopover.onKeyDown = null;
      powerVerbsPopover.onReposition = null;
    }

    function ensurePowerVerbsPopover() {
      if (powerVerbsPopover.el) return;
      const popover = document.createElement("div");
      popover.className = "tour-popover power-verbs-popover";
      popover.style.display = "none";

      const header = document.createElement("div");
      header.className = "power-verbs-popover-header";

      const title = document.createElement("div");
      title.className = "power-verbs-popover-title";
      title.textContent = "More power verbs";

      const closeBtn = document.createElement("button");
      closeBtn.type = "button";
      closeBtn.className = "power-verbs-popover-close";
      closeBtn.setAttribute("aria-label", "Close");
      closeBtn.textContent = "×";
      closeBtn.addEventListener("click", () => closePowerVerbsPopover());

      header.appendChild(title);
      header.appendChild(closeBtn);

      const feedback = document.createElement("div");
      feedback.className = "power-verbs-feedback";
      feedback.setAttribute("aria-live", "polite");

      const grid = document.createElement("div");
      grid.className = "power-verbs-popover-grid";

      const footer = document.createElement("div");
      footer.className = "power-verbs-popover-footer";

      const prevBtn = document.createElement("button");
      prevBtn.type = "button";
      prevBtn.className = "example-btn";
      prevBtn.textContent = "← Prev";
      prevBtn.style.display = "none";
      prevBtn.addEventListener("click", () => {
        goToPowerVerbsPage(powerVerbsState.pageIndex - 1);
        positionPowerVerbsPopover();
      });

      const nextBtn = document.createElement("button");
      nextBtn.type = "button";
      nextBtn.className = "example-btn";
      nextBtn.textContent = "Next →";
      nextBtn.addEventListener("click", () => {
        goToPowerVerbsPage(powerVerbsState.pageIndex + 1);
        positionPowerVerbsPopover();
      });

      footer.appendChild(prevBtn);
      footer.appendChild(nextBtn);

      popover.appendChild(header);
      popover.appendChild(feedback);
      popover.appendChild(grid);
      popover.appendChild(footer);

      document.body.appendChild(popover);

      powerVerbsPopover.el = popover;
      powerVerbsPopover.grid = grid;
      powerVerbsPopover.feedback = feedback;
      powerVerbsPopover.nextBtn = nextBtn;
      powerVerbsPopover.prevBtn = prevBtn;
      powerVerbsPopover.closeBtn = closeBtn;
    }

    function openPowerVerbsPopover(anchorEl, textarea) {
      ensurePowerVerbsPopover();
      powerVerbsPopover.anchor = anchorEl;
      powerVerbsPopover.textarea = textarea;
      powerVerbsPopover.isOpen = true;
      powerVerbsPopover.el.style.display = "block";
      attachPowerVerbsPopoverListeners();

      loadPowerVerbsList().then(() => {
        if (!powerVerbsState.pageHistory.length) {
          powerVerbsState.pageHistory.push(createPowerVerbsPage());
          powerVerbsState.pageIndex = 0;
        }
        renderPowerVerbsPopoverPage();
        requestAnimationFrame(positionPowerVerbsPopover);
      });
    }

    function closePowerVerbsPopover() {
      if (!powerVerbsPopover.el || !powerVerbsPopover.isOpen) return;
      powerVerbsPopover.el.style.display = "none";
      powerVerbsPopover.isOpen = false;
      powerVerbsPopover.anchor = null;
      detachPowerVerbsPopoverListeners();
    }

    function refreshPowerVerbsHelper() {
      if (!activePowerVerbsHelper || !activePowerVerbsHelper.isConnected) return;
      const grid = activePowerVerbsHelper.querySelector("[data-power-verbs-grid]");
      const feedback = activePowerVerbsHelper.querySelector("[data-power-verbs-feedback]");
      const textarea = activePowerVerbsHelper._textarea;
      ensureInitialPowerVerbs(powerVerbsState.label || currentLabelText || currentLabel || "");
      renderPowerVerbButtons(grid, powerVerbsState.initialVerbs, { feedbackEl: feedback, textarea });
    }

    function buildPowerVerbsHelper(label, rewriteTextarea) {
      if (!isAvoidWeakVerbsLabel(label)) return null;
      const helper = document.createElement("div");
      helper.className = "power-verbs-helper";
      helper._textarea = rewriteTextarea;

      const header = document.createElement("div");
      header.className = "power-verbs-header";

      const title = document.createElement("div");
      title.className = "power-verbs-title";
      title.textContent = "Do any of these work?";

      const actions = document.createElement("div");
      actions.className = "power-verbs-actions";

      const feedback = document.createElement("div");
      feedback.className = "power-verbs-feedback";
      feedback.setAttribute("aria-live", "polite");
      feedback.dataset.powerVerbsFeedback = "1";

      const moreBtn = document.createElement("button");
      moreBtn.type = "button";
      moreBtn.className = "secondary-btn";
      moreBtn.textContent = "More options";
      moreBtn.addEventListener("click", () => openPowerVerbsPopover(moreBtn, rewriteTextarea));

      actions.appendChild(feedback);
      actions.appendChild(moreBtn);

      header.appendChild(title);
      header.appendChild(actions);

      const grid = document.createElement("div");
      grid.className = "power-verbs-grid";
      grid.dataset.powerVerbsGrid = "1";

      helper.appendChild(header);
      helper.appendChild(grid);

      activePowerVerbsHelper = helper;
      ensureInitialPowerVerbs(label);
      renderPowerVerbButtons(grid, powerVerbsState.initialVerbs, { feedbackEl: feedback, textarea: rewriteTextarea });

      if (!powerVerbsState.initialVerbs.length) {
        loadPowerVerbsList().then(() => {
          ensureInitialPowerVerbs(label);
          if (helper.isConnected) {
            renderPowerVerbButtons(grid, powerVerbsState.initialVerbs, { feedbackEl: feedback, textarea: rewriteTextarea });
          }
        });
      }

      return helper;
    }

    function handlePowerVerbsIssueChange(label) {
      if (!isAvoidWeakVerbsLabel(label)) {
        powerVerbsState.label = null;
        powerVerbsState.initialVerbs = [];
        powerVerbsState.pageHistory = [];
        powerVerbsState.pageIndex = 0;
        powerVerbsState.recentlyShown = [];
        closePowerVerbsPopover();
        return;
      }
      if (powerVerbsState.label !== label) {
        powerVerbsState.label = label;
        powerVerbsState.initialVerbs = [];
        powerVerbsState.pageHistory = [];
        powerVerbsState.pageIndex = 0;
        powerVerbsState.recentlyShown = [];
        closePowerVerbsPopover();
      }
      loadPowerVerbsList().then(() => {
        if (!isAvoidWeakVerbsLabel(powerVerbsState.label)) return;
        ensureInitialPowerVerbs(powerVerbsState.label);
        refreshPowerVerbsHelper();
      });
    }

    function getPreviewOnlyMessage(label, fallbackMessage) {
      if (isPreviewOnlyLabel(label)) {
        return "Looks like you need to revise your topic sentence. Repair this issue in the Preview";
      }
      return fallbackMessage;
    }

    function currentDismissStorageKey() {
      return `vysti_dismissed_${(selectedFile?.name || "nofile")}`;
    }

    function loadDismissedIssuesFromStorage() {
      const key = currentDismissStorageKey();
      try {
        const raw = localStorage.getItem(key);
        if (!raw) {
          dismissedIssues = [];
          return;
        }
        const parsed = JSON.parse(raw);
        dismissedIssues = Array.isArray(parsed) ? parsed : [];
      } catch (error) {
        console.warn("Failed to load dismissed issues:", error);
        dismissedIssues = [];
      }
    }

    function saveDismissedIssuesToStorage() {
      const key = currentDismissStorageKey();
      try {
        localStorage.setItem(key, JSON.stringify(dismissedIssues || []));
      } catch (error) {
        console.warn("Failed to save dismissed issues:", error);
      }
    }

    function getAppliedStorageKey(label, exampleKey) {
      if (!exampleKey) return "";
      const assignmentKey = selectedFile?.name || assignmentNameInput?.value?.trim() || "nofile";
      const safeLabel = String(label || "nolabel").trim();
      return `vysti_applied_${assignmentKey}__${safeLabel}__${exampleKey}`;
    }

    function loadAppliedFlag(label, exampleKey) {
      const key = getAppliedStorageKey(label, exampleKey);
      if (!key) return false;
      try {
        return localStorage.getItem(key) === "1";
      } catch (error) {
        console.warn("Failed to load applied flag:", error);
        return false;
      }
    }

    function saveAppliedFlag(label, exampleKey, value) {
      const key = getAppliedStorageKey(label, exampleKey);
      if (!key) return;
      try {
        if (value) {
          localStorage.setItem(key, "1");
        } else {
          localStorage.removeItem(key);
        }
      } catch (error) {
        console.warn("Failed to save applied flag:", error);
      }
    }

    function normalizeLabelForMatch(label) {
      return normalizeForMatch(String(label || "")).toLowerCase();
    }

    function isDismissedIssueInstance(label, sentence) {
      if (!label || !sentence || !selectedFile) return false;
      const labelMatch = normalizeLabelForMatch(label);
      const sentenceMatch = normalizeForMatch(sentence);
      return dismissedIssues.some((record) => {
        if (record?.file_name !== selectedFile.name) return false;
        return (
          normalizeLabelForMatch(record?.label) === labelMatch &&
          normalizeForMatch(record?.sentence) === sentenceMatch
        );
      });
    }

    loadDismissedIssuesFromStorage();

    function updateIssueMetadataForLabel(label) {
      const issues = currentMarkEvent?.issues || [];
      const issueData = issues.find((iss) => normLabel(iss?.label) === normLabel(label));
      if (issueData && issueData.explanation) {
        issueExplanation.textContent = issueData.explanation;
        if (issueExplanationBlock) issueExplanationBlock.style.display = "block";
      } else if (issueExplanationBlock) {
        issueExplanationBlock.style.display = "none";
      }
      currentGuidance = issueData?.student_guidance || "";
      currentLabelText = (issueData?.label || label || "").trim();
      return issueData || null;
    }

    function getExampleKeyFromParts(paragraphIndex, sentence) {
      const safePara = String(paragraphIndex ?? 0);
      const safeSentence = String(sentence || "").trim();
      return `${safePara}::${safeSentence}`;
    }

    function getExampleKey(ex) {
      if (!ex) return "";
      const sentence = ex.original_sentence || ex.sentence || "";
      return getExampleKeyFromParts(ex.paragraph_index ?? 0, sentence);
    }

    // Loading indicator style for the main "Mark my essay" button.
    // - true: "Processing |" (blinking cursor)
    // - false: "Processing..." (animated dots)
    const USE_CURSOR_PROMPT_LOADING = true;

    function startButtonLoading(btn, fallbackLabel) {
      if (!btn) return;
      if (!btn.dataset.baseLabel) {
        const label = (btn.textContent || fallbackLabel || "").trim();
        if (label) btn.dataset.baseLabel = label;
      }

      // visually + accessibility
      btn.classList.add("is-loading");
      btn.classList.remove("loading-cursor");
      btn.setAttribute("aria-busy", "true");
      btn.disabled = true;

      // Cursor prompt mode (preferred)
      if (USE_CURSOR_PROMPT_LOADING) {
        // No interval needed; CSS handles the blink.
        btn.classList.add("loading-cursor");
        btn.textContent = "Processing";
        return;
      }

      let dots = 0;
      const tick = () => {
        dots = (dots + 1) % 4; // 0..3
        const suffix = ".".repeat(dots);
        btn.textContent = `Processing${suffix}`;
      };

      tick();
      const timer = window.setInterval(tick, 450);
      buttonLoadingTimers.set(btn, timer);
    }

    function stopButtonLoading(btn, enableWhenDone) {
      if (!btn) return;

      const timer = buttonLoadingTimers.get(btn);
      if (timer) {
        window.clearInterval(timer);
        buttonLoadingTimers.delete(btn);
      }

      btn.classList.remove("is-loading");
      btn.classList.remove("loading-cursor");
      btn.removeAttribute("aria-busy");

      if (btn.dataset.baseLabel) btn.textContent = btn.dataset.baseLabel;

      const shouldEnable = typeof enableWhenDone === "function"
        ? enableWhenDone()
        : !!enableWhenDone;
      btn.disabled = !shouldEnable;
    }

    function applyPreviewZoom() {
      if (!markedPreview || !previewZoom) return;
      markedPreview.style.zoom = previewZoom.value || "1";
    }

    if (previewZoom) {
      previewZoom.addEventListener("change", applyPreviewZoom);
    }

    if (markedPreview) {
      markedPreview.addEventListener("input", () => {
        hasStartedRevising = true;
      }, true);
    }

    function buildMarkFormData({ includeSummaryTable = false } = {}) {
      if (!selectedFile) return null;

      const mode = document.getElementById("mode").value;
      const assignmentName = document.getElementById("assignmentName").value.trim();

      const formData = new FormData();
      formData.append("file", selectedFile);
      formData.append("mode", mode);
      formData.append("include_summary_table", includeSummaryTable ? "true" : "false");
      // Student mode: never highlight thesis devices/strategies
      formData.append("highlight_thesis_devices", "false");
      formData.append("student_mode", "true");

      if (assignmentName) {
        formData.append("assignment_name", assignmentName);
      }

      if (detectedWork && detectedWork.confidence === "high") {
        formData.append("author", detectedWork.author);
        formData.append("title", detectedWork.title);
        formData.append("text_is_minor_work", detectedWork.isMinor ? "true" : "false");
      }

      return formData;
    }

    // ===== Mode explainer card =====
    const MODE_RULE_DEFAULTS = {
      textual_analysis: {
        description: "A formal and academic essay of analysis with all Vysti Rules running.",
        details: [
          "No first-person allowed or personal pronouns",
          "First sentence should state the author, genre, title, and summary.",
          "Requires a closed thesis statement.",
          "Requires quoted evidence in body paragraphs.",
          "Strict requirements on organization, evidence, and language.",
          "Aqua-blue highlights repetitive 'and', weak verbs, and unclarified antecedents",
          "Red strikethroughs forbidden terms."
        ]
      },
      peel_paragraph: {
        description: "One focused analytical paragraph following the Vysti Rules.",
        details: [
          "The first sentence should state the author, genre, title, and summary.",
          "The first sentence should include devices and/or strategies like a closed thesis",
          "No first-person allowed or personal pronouns",
          "Requires quoted evidence in the body of the paragraph.",
          "Strict requirements on organization, evidence, and language.",
          "Aqua-blue highlights repetitive 'and', weak verbs, and unclarified antecedents",
          "Red strikethroughs forbidden terms."
        ]
      },
      reader_response: {
        description: "More personal voice allowed, but still needs argument + evidence.",
        details: [
          "Allows first-person and personal pronouns",
          "Allows contractions and 'which'",
          "First sentence should state the author, genre, title, and summary.",
          "Requires a closed thesis statement.",
          "Requires quoted evidence in body paragraphs.",
          "Strict requirements on organization, evidence, and language.",
          "Aqua-blue highlights repetitive 'and', weak verbs, and unclarified antecedents",
          "Red strikethroughs forbidden terms."
        ]
      },
      argumentation: {
        description: "Argumentation is more open mode beyond textual analysis.",
        details: [
          "Allows for past tense.",
          "Allows first-person and personal pronouns",
          "Aqua-blue highlights repetitive 'and', weak verbs, and unclarified antecedents",
          "Red strikethroughs forbidden terms.",
        ]
      }
    };

    // Mode explainer elements
    const modeBadge = document.getElementById("modeBadge");
    const modeTagEl = document.getElementById("modeTag");
    const modeDesc = document.getElementById("modeDesc");
    const modeMoreBtn = document.getElementById("modeMoreBtn");
    const modeDetails = document.getElementById("modeDetails");
    const modeDetailsList = document.getElementById("modeDetailsList");

    function setModeExplainer(mode) {
      const cfg = MODE_RULE_DEFAULTS[mode] || MODE_RULE_DEFAULTS.textual_analysis;
      const label = modeSelect.options[modeSelect.selectedIndex]?.textContent || mode;

      if (modeBadge) modeBadge.textContent = label;
      if (modeTagEl) modeTagEl.textContent = cfg.tag || "";
      if (modeDesc) modeDesc.textContent = cfg.description || "";

      if (modeDetailsList) {
        modeDetailsList.innerHTML = "";
        (cfg.details || []).forEach((item) => {
          const li = document.createElement("li");
          li.textContent = item;
          modeDetailsList.appendChild(li);
        });
      }

      const hasDetails = Array.isArray(cfg.details) && cfg.details.length > 0;
      if (modeMoreBtn) modeMoreBtn.hidden = !hasDetails;

      if (modeMoreBtn && modeDetails) {
        modeMoreBtn.setAttribute("aria-expanded", "false");
        modeDetails.hidden = true;
        modeMoreBtn.textContent = "Want more details?";
      }
    }

    // Expand / collapse once
    if (modeMoreBtn && modeDetails) {
      modeMoreBtn.addEventListener("click", () => {
        const expanded = modeMoreBtn.getAttribute("aria-expanded") === "true";
        modeMoreBtn.setAttribute("aria-expanded", String(!expanded));
        modeDetails.hidden = expanded;
        modeMoreBtn.textContent = expanded ? "Want more details?" : "Hide details";
      });
    }

    // Initialize mode explainer
    if (modeSelect) {
      setModeExplainer(modeSelect.value);
      modeSelect.addEventListener("change", () => {
        setModeExplainer(modeSelect.value);
        updateStatsPanel(liveLabelCounts);
        if (lastStudentMetrics) {
          renderMetrics(lastStudentMetrics);
        }
      });
    }

    // ===== Student helpers tour flags =====
    const FORCE_STUDENT_HELPERS = false;
    const TOUR_HIDE_KEY = "vysti_student_tour_hide";
    const TOUR_DONE_KEY = "vysti_student_tour_completed";
    const STUDENT_HELPERS_DISABLED_KEY = "vysti_student_helpers_disabled";

    function shouldShowStudentHelpers() {
      if (FORCE_STUDENT_HELPERS) return true;
      const disabled = localStorage.getItem(STUDENT_HELPERS_DISABLED_KEY);
      const completed = localStorage.getItem(TOUR_DONE_KEY);
      const legacyHidden = localStorage.getItem(TOUR_HIDE_KEY);
      return !disabled && !completed && !legacyHidden;
    }

    // ===== Auth + role guard =====
    let studentHelpersStartedThisLoad = false;
    async function refreshAuthUI() {
      const { data } = await supa.auth.getSession();
      const session = data.session;

      if (!session) {
        window.location.replace("/signin.html");
        return;
      }

      // Set role to student on successful auth guard
      localStorage.setItem("vysti_role", "student");

      // Logged in as student
      form.style.display = "grid";

      if (!studentHelpersStartedThisLoad && shouldShowStudentHelpers()) {
        studentHelpersStartedThisLoad = true;

        // Make sure layout is ready before positioning the helper window arrows
        requestAnimationFrame(() => {
          setTimeout(() => {
            startTour({ force: FORCE_STUDENT_HELPERS });
          }, 50);
        });
      }
    }

    // Initial auth check
    refreshAuthUI();
    supa.auth.onAuthStateChange((_event, _session) => {
      refreshAuthUI();
    });

    // ===== Switch mode handler =====
    const switchModeBtn = document.getElementById("switchModeBtn");
    if (switchModeBtn) {
      switchModeBtn.addEventListener("click", () => {
        localStorage.setItem("vysti_role", "teacher");
        window.location.href = "/index.html";
      });
    }

    // ===== Logout handler =====
    const logoutBtn = document.getElementById("logoutBtn");
    logoutBtn.addEventListener("click", async () => {
      await supa.auth.signOut();
      localStorage.removeItem("vysti_role");
      window.location.replace("/signin.html");
    });

    const repeatTutorialBtn = document.getElementById("repeatTutorialBtn");
    if (repeatTutorialBtn) {
      repeatTutorialBtn.addEventListener("click", () => {
        clearStudentHelperSuppression();
        if (tourState.active) {
          closeTour("dismissed");
        }
        startTourForCurrentState({ force: true });
      });
    }

    let repeatTutorialPopover = null;
    let repeatTutorialPopoverVisible = false;

    function ensureRepeatTutorialPopover() {
      if (repeatTutorialPopover) return repeatTutorialPopover;
      repeatTutorialPopover = document.createElement("div");
      repeatTutorialPopover.className = "repeat-tutorial-popover";
      repeatTutorialPopover.setAttribute("role", "tooltip");
      repeatTutorialPopover.style.display = "none";
      document.body.appendChild(repeatTutorialPopover);
      return repeatTutorialPopover;
    }

    function positionRepeatTutorialPopover() {
      if (!repeatTutorialBtn || !repeatTutorialPopover) return;
      const pad = 12;
      const rect = repeatTutorialBtn.getBoundingClientRect();

      repeatTutorialPopover.style.position = "fixed";

      let left = rect.right - repeatTutorialPopover.offsetWidth;
      let top = rect.bottom + 8;

      left = Math.max(pad, Math.min(left, window.innerWidth - repeatTutorialPopover.offsetWidth - pad));

      if (top + repeatTutorialPopover.offsetHeight > window.innerHeight - pad) {
        top = rect.top - repeatTutorialPopover.offsetHeight - 8;
      }
      top = Math.max(pad, Math.min(top, window.innerHeight - repeatTutorialPopover.offsetHeight - pad));

      repeatTutorialPopover.style.left = `${Math.round(left)}px`;
      repeatTutorialPopover.style.top = `${Math.round(top)}px`;
    }

    function showRepeatTutorialPopover() {
      if (!repeatTutorialBtn) return;
      const popover = ensureRepeatTutorialPopover();
      popover.textContent = repeatTutorialBtn.dataset.tip || "Repeat the tutorial";
      popover.style.display = "block";
      popover.style.visibility = "hidden";
      positionRepeatTutorialPopover();
      popover.style.visibility = "visible";
      repeatTutorialPopoverVisible = true;
    }

    function hideRepeatTutorialPopover() {
      if (!repeatTutorialPopover) return;
      repeatTutorialPopover.style.display = "none";
      repeatTutorialPopoverVisible = false;
    }

    function handleRepeatTutorialPopoverPosition() {
      if (!repeatTutorialPopoverVisible) return;
      positionRepeatTutorialPopover();
    }

    if (repeatTutorialBtn) {
      repeatTutorialBtn.addEventListener("mouseenter", showRepeatTutorialPopover);
      repeatTutorialBtn.addEventListener("focus", showRepeatTutorialPopover);
      repeatTutorialBtn.addEventListener("mouseleave", hideRepeatTutorialPopover);
      repeatTutorialBtn.addEventListener("blur", hideRepeatTutorialPopover);
      window.addEventListener("resize", handleRepeatTutorialPopoverPosition, { passive: true });
      window.addEventListener("scroll", handleRepeatTutorialPopoverPosition, true);
    }

    function handleAssignmentNameFocus() {
      if (!assignmentNameInput) return;
      if (!assignmentNameInput.value.trim()) {
        assignmentNameInput.value = "Assignment 01";
        requestAnimationFrame(() => assignmentNameInput.select());
      }
    }

    if (assignmentNameInput) {
      assignmentNameInput.addEventListener("focus", handleAssignmentNameFocus);
      assignmentNameInput.addEventListener("click", handleAssignmentNameFocus);
    }

    // ===== File handling (single file only) =====
    function updateFileUI() {
      fileList.innerHTML = "";
      clearFileBtn.style.display = "none";
      
      if (selectedFile) {
        const li = document.createElement("li");
        li.textContent = selectedFile.name;
        fileList.appendChild(li);
        clearFileBtn.style.display = "block";
        checkBtn.disabled = false;
      } else {
        checkBtn.disabled = true;
      }
    }

    function totalIssuesFromLabelCounts(labelCounts) {
      if (!labelCounts || typeof labelCounts !== "object") return 0;
      return Object.values(labelCounts).reduce((sum, v) => sum + (Number(v) || 0), 0);
    }

    function updateStatsPanel(labelCounts) {
      if (!statsPanel) return;
      const counts = labelCounts && typeof labelCounts === "object" ? labelCounts : {};
      const totalIssues = totalIssuesFromLabelCounts(counts);

      if (wordCountStat) {
        wordCountStat.textContent = (currentWordCount === null || currentWordCount === undefined)
          ? "—"
          : String(currentWordCount);
      }
      if (totalIssuesStat) {
        totalIssuesStat.textContent = String(totalIssues);
      }

      const entries = Object.entries(counts)
        .filter(([label, count]) => label && (Number(count) || 0) > 0)
        .sort((a, b) => {
          const diff = (Number(b[1]) || 0) - (Number(a[1]) || 0);
          if (diff !== 0) return diff;
          return String(a[0]).localeCompare(String(b[0]));
        });

      if (topIssueRow && topIssueStat) {
        if (entries.length > 0) {
          const [label, count] = entries[0];
          topIssueStat.textContent = `${label} (${count})`;
          topIssueRow.style.display = "flex";
        } else {
          topIssueRow.style.display = "none";
          topIssueStat.textContent = "";
        }
      }

      if (!techniquesStatWrap || !techniquesStatList) return;
      const mode = modeSelect ? modeSelect.value : "";
      if (mode === "argumentation") {
        techniquesStatWrap.style.display = "none";
        techniquesStatList.textContent = "";
        return;
      }

      if (!Array.isArray(currentTechniques) || currentTechniques.length === 0) {
        techniquesStatWrap.style.display = "none";
        techniquesStatList.textContent = "";
        return;
      }

      const sorted = currentTechniques
        .filter((item) => item && item.name && (Number(item.count) || 0) > 0)
        .slice()
        .sort((a, b) => {
          const countDiff = (Number(b?.count) || 0) - (Number(a?.count) || 0);
          if (countDiff !== 0) return countDiff;
          const nameA = String(a?.name || "");
          const nameB = String(b?.name || "");
          return nameA.localeCompare(nameB);
        });

      if (sorted.length === 0) {
        techniquesStatWrap.style.display = "none";
        techniquesStatList.textContent = "";
        return;
      }

      const maxItems = 6;
      techniquesStatList.innerHTML = "";
      sorted.slice(0, maxItems).forEach((item) => {
        const row = document.createElement("div");
        row.textContent = `${item.name} (${item.count})`;
        techniquesStatList.appendChild(row);
      });
      const remaining = sorted.length - maxItems;
      if (remaining > 0) {
        const moreRow = document.createElement("div");
        moreRow.textContent = `+ ${remaining} more`;
        techniquesStatList.appendChild(moreRow);
      }
      techniquesStatWrap.style.display = "block";
    }

    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    function stripQuotedText(s) {
      return String(s || "").replace(/"[^"]*"/g, " ");
    }

    function tokenizeWords(s) {
      return String(s || "").toLowerCase().match(/[a-z']+/g) || [];
    }

    function countRegexMatches(text, regex) {
      const matches = String(text || "").match(regex);
      return matches ? matches.length : 0;
    }

    function splitSentencesSimple(s) {
      return String(s || "")
        .replace(/\s+/g, " ")
        .split(/(?<=[.!?])\s+/)
        .map((x) => x.trim())
        .filter(Boolean);
    }

    function splitParagraphsSimple(s) {
      return String(s || "")
        .split(/\n{2,}/)
        .map((p) => p.trim())
        .filter(Boolean);
    }

    const WEAK_VERBS = new Set([
      "show","shows","showed","showing",
      "use","uses","used","using",
      "make","makes","made","making",
      "get","gets","got","getting",
      "have","has","had","having",
      "do","does","did","doing",
      "is","are","was","were","be","being","been"
    ]);

    const PRONOUN_STARTERS = new Set([
      "this","it","they","he","she","we","i","you"
    ]);

    const SENTENCE_STARTER_SKIPS = new Set([
      "however","moreover","furthermore","additionally","therefore","thus",
      "consequently","nevertheless","nonetheless","meanwhile"
    ]);

    const TRANSITIONS = [
      "on the other hand",
      "for example",
      "for instance",
      "in addition",
      "as a result",
      "however",
      "moreover",
      "furthermore",
      "additionally",
      "therefore",
      "thus",
      "consequently",
      "nevertheless",
      "nonetheless",
      "meanwhile"
    ];

    const COHESION_STOP_WORDS = new Set([
      "the","a","an","and","or","but","if","then","so","because","since","as",
      "while","when","after","before","though","although","however","therefore",
      "thus","moreover","furthermore","additionally","also","from","into","onto",
      "with","within","without","of","to","in","on","at","by","for","about",
      "over","under","between","through","during","is","are","was","were","be",
      "been","being","am","have","has","had","do","does","did","doing","that",
      "this","these","those","it","its","their","they","them","he","she","his",
      "her","we","our","us","you","your","i","me","my","mine","yours","ours",
      "theirs","not","no","yes","can","could","would","should","may","might",
      "must","will","just","very","really","more","most","less","least","such",
      "than","too","each","every","some","any","all","both","either","neither",
      "nor","own","same","other","another","there","here","then","now","who",
      "whom","which","what","where","why","how","up","down","out","off","again",
      "further","once","ever","never","across","around","behind","beyond","near",
      "among","amongst","via"
    ]);

    const SUBJECTIVE_TERMS = [
      "successfully",
      "successful",
      "powerful"
    ];

    const METRIC_INFO = {
      power: {
        title: "Power",
        body: "Power measures how specific your verb choices are (avoiding weak verbs like show/use).",
        tips: [
          "Swap show/use for precise verbs (illustrates, highlights, underscores).",
          "Avoid repeating the same verb across sentences.",
          "Aim for verbs that express analysis, not reporting."
        ]
      },
      variety: {
        title: "Variety",
        body: "Variety measures how repetitive your sentence openings are (pronoun/noun starts vs. varied starters).",
        tips: [
          "Start some sentences with a clause (Although/While/When...).",
          "Start with a prepositional phrase (In/Across/Through...).",
          "Avoid too many This/It/They starts in a row."
        ]
      },
      cohesion: {
        title: "Cohesion",
        body: "Cohesion measures how clearly your paragraphs connect using transitions and linking language.",
        tips: [
          "Use transitions sparingly and vary them.",
          "Repeat a key word from the prior paragraph to link ideas.",
          "Don’t stack Moreover/Furthermore repeatedly."
        ]
      },
      precision: {
        title: "Precision",
        body: "Precision measures removable wordiness (phrases that often weaken academic style).",
        tips: [
          "Cut filler like \"the use of\", \"the author\", and \"in conclusion\".",
          "Reduce extra \"and\" chains; split into clearer sentences.",
          "Avoid \"reader/audience\" unless the text directly supports it."
        ]
      }
    };

    function getSentenceStarterWord(sentence) {
      const tokens = tokenizeWords(sentence);
      if (tokens.length === 0) return "";
      let idx = 0;
      while (idx < tokens.length && SENTENCE_STARTER_SKIPS.has(tokens[idx])) {
        idx += 1;
      }
      return tokens[idx] || tokens[0] || "";
    }

    function normalizeCohesionToken(token) {
      let t = String(token || "").toLowerCase();
      if (t.endsWith("ing") && t.length > 5) t = t.slice(0, -3);
      else if (t.endsWith("ed") && t.length > 4) t = t.slice(0, -2);
      else if (t.endsWith("s") && t.length > 4) t = t.slice(0, -1);
      return t;
    }

    function getCohesionKeyTokens(sentence) {
      return (tokenizeWords(sentence) || [])
        .map(normalizeCohesionToken)
        .filter((tok) => tok.length >= 3 && !COHESION_STOP_WORDS.has(tok));
    }

    function detectTransitionStart(sentence) {
      const tokens = tokenizeWords(sentence || "");
      if (tokens.length === 0) return "";
      let idx = 0;
      while (idx < tokens.length && SENTENCE_STARTER_SKIPS.has(tokens[idx])) {
        idx += 1;
      }
      const windowTokens = tokens.slice(idx, idx + 4);
      if (windowTokens.length === 0) return "";
      for (const phrase of TRANSITIONS) {
        const phraseTokens = phrase.split(" ");
        if (phraseTokens.length > windowTokens.length) continue;
        let matches = true;
        for (let i = 0; i < phraseTokens.length; i += 1) {
          if (windowTokens[i] !== phraseTokens[i]) {
            matches = false;
            break;
          }
        }
        if (matches) return phrase;
      }
      return "";
    }

    function computeMetricsFromText(text, mode) {
      const clean = stripQuotedText(normalizeTypography(text || ""));
      const cleanLower = clean.toLowerCase().replace(/\s+/g, " ").trim();
      const words = tokenizeWords(cleanLower);
      const totalWords = words.length;

      let weakCount = 0;
      let showCount = 0;
      let useCount = 0;
      for (const w of words) {
        if (WEAK_VERBS.has(w)) weakCount += 1;
        if (w === "show" || w === "shows" || w === "showed" || w === "showing") showCount += 1;
        if (w === "use" || w === "uses" || w === "used" || w === "using") useCount += 1;
      }
      const weakRatePer100 = totalWords ? (weakCount / totalWords) * 100 : 0;
      const powerScore = clamp(Math.round(100 - weakRatePer100 * 8), 0, 100);
      const powerDetails = [];
      if (showCount > 0) powerDetails.push(`show (${showCount})`);
      if (useCount > 0) powerDetails.push(`use (${useCount})`);
      const powerSub = powerDetails.length
        ? `Weak verbs: ${powerDetails.join(", ")}`
        : `Weak verbs: ${weakCount}`;

      const sentences = splitSentencesSimple(clean);
      let pronounStarts = 0;
      for (const sentence of sentences) {
        const starter = getSentenceStarterWord(sentence);
        if (starter && PRONOUN_STARTERS.has(starter)) {
          pronounStarts += 1;
        }
      }
      const pronounStartRate = sentences.length ? pronounStarts / sentences.length : 0;
      const varietyScore = clamp(Math.round(100 - pronounStartRate * 120), 0, 100);

      const paragraphs = splitParagraphsSimple(clean);
      const sentenceCount = sentences.length;
      let transitionStarts = 0;
      const transitionSet = new Set();
      for (const sentence of sentences) {
        const transition = detectTransitionStart(sentence);
        if (transition) {
          transitionStarts += 1;
          transitionSet.add(transition);
        }
      }
      const uniqueTransitions = transitionSet.size;
      const transitionRate = sentenceCount ? transitionStarts / sentenceCount : 0;
      const transitionScoreRaw = 1 - Math.abs(transitionRate - 0.08) / 0.08;
      let transitionScore = clamp(transitionScoreRaw, 0, 1) * 40;
      const spamPenalty = Math.max(0, transitionStarts - uniqueTransitions * 2) * 3;
      transitionScore = Math.max(0, transitionScore - spamPenalty);

      const keyTokenSets = sentences.map((sentence) => new Set(getCohesionKeyTokens(sentence)));
      let boundaryHits = 0;
      for (let i = 0; i < keyTokenSets.length - 1; i += 1) {
        const currentSet = keyTokenSets[i];
        const nextSet = keyTokenSets[i + 1];
        let hit = false;
        for (const tok of currentSet) {
          if (nextSet.has(tok)) {
            hit = true;
            break;
          }
        }
        if (hit) boundaryHits += 1;
      }
      const boundaryRate = sentenceCount > 1 ? boundaryHits / (sentenceCount - 1) : 0;
      const boundaryScore = 60 * boundaryRate;
      let cohesionScore = clamp(Math.round(boundaryScore + transitionScore), 0, 100);
      const cohesionSub = `Transitions: ${transitionStarts} • Boundary links: ${boundaryHits}/${Math.max(0, sentenceCount - 1)}`;

      if (DEBUG_METRICS) {
        console.log({ sentenceCount, transitionStarts, uniqueTransitions, boundaryHits, cohesionScore });
      }

      const andCount = countRegexMatches(cleanLower, /\band\b/g);
      const whichCount = countRegexMatches(cleanLower, /\bwhich\b/g);
      const readerCount = countRegexMatches(cleanLower, /\breader\b/g);
      const audienceCount = countRegexMatches(cleanLower, /\baudience\b/g);
      const readerAudienceCount = readerCount + audienceCount;
      const useOfCount = countRegexMatches(cleanLower, /\bthe\s+use\s+of\b/g);
      const authorCount = countRegexMatches(cleanLower, /\bthe\s+author\b/g);
      const inConclusionCount = countRegexMatches(cleanLower, /\bin\s+conclusion\b/g);
      let subjectiveCount = 0;
      SUBJECTIVE_TERMS.forEach((term) => {
        const pattern = new RegExp(`\\b${term.replace(/\s+/g, "\\s+")}\\b`, "g");
        subjectiveCount += countRegexMatches(cleanLower, pattern);
      });

      const per100 = (count) => (totalWords ? (count / totalWords) * 100 : 0);
      const precisionPenalty = (per100(andCount) * 4)
        + (per100(whichCount) * 8)
        + (per100(readerAudienceCount) * 10)
        + (per100(useOfCount) * 12)
        + (per100(authorCount) * 12)
        + (per100(inConclusionCount) * 15)
        + (per100(subjectiveCount) * 10);
      const precisionScore = clamp(Math.round(100 - precisionPenalty), 0, 100);

      const clutterItems = [
        { label: "and", count: andCount },
        { label: "which", count: whichCount },
        { label: "reader/audience", count: readerAudienceCount },
        { label: "the use of", count: useOfCount },
        { label: "the author", count: authorCount },
        { label: "in conclusion", count: inConclusionCount },
        { label: "subjective words", count: subjectiveCount }
      ];
      const topClutter = clutterItems
        .filter((item) => item.count > 0)
        .sort((a, b) => {
          const diff = b.count - a.count;
          if (diff !== 0) return diff;
          return a.label.localeCompare(b.label);
        })
        .slice(0, 3)
        .map((item) => `${item.label} (${item.count})`);
      const precisionSub = topClutter.length ? `Top clutter: ${topClutter.join(", ")}` : "Top clutter: none";

      return {
        power: {
          score: powerScore,
          sub: powerSub
        },
        variety: {
          score: varietyScore,
          sub: `Pronoun starts: ${pronounStarts}/${sentences.length}`
        },
        cohesion: {
          score: cohesionScore,
          sub: cohesionSub
        },
        precision: {
          score: precisionScore,
          sub: precisionSub
        },
        meta: {
          paragraphs: paragraphs.length,
          sentences: sentenceCount,
          mode: mode || ""
        }
      };
    }

    function renderSingleMetric(scoreEl, meterEl, subEl, metric) {
      if (!scoreEl || !meterEl || !subEl) return;
      if (!metric || typeof metric.score !== "number") {
        scoreEl.textContent = "—";
        meterEl.style.width = "0%";
        scoreEl.classList.remove("perfect");
        meterEl.classList.remove("perfect");
        subEl.textContent = "";
        return;
      }
      const scoreValue = clamp(metric.score, 0, 100);
      const isPerfect = scoreValue === 100;
      scoreEl.textContent = `${scoreValue}/100`;
      meterEl.style.width = `${scoreValue}%`;
      scoreEl.classList.toggle("perfect", isPerfect);
      meterEl.classList.toggle("perfect", isPerfect);
      subEl.textContent = metric.sub || "";
    }

    function renderMetrics(metrics) {
      if (!metricsGrid) return;
      lastStudentMetrics = metrics || null;

      renderSingleMetric(powerScoreText, powerMeterFill, powerSubText, metrics?.power);
      renderSingleMetric(varietyScoreText, varietyMeterFill, varietySubText, metrics?.variety);
      renderSingleMetric(precisionScoreText, precisionMeterFill, precisionSubText, metrics?.precision);

      const sentenceCount = metrics?.meta?.sentences || 0;
      const mode = metrics?.meta?.mode || "";
      const hideCohesion = mode === "peel_paragraph";
      if (metricCohesionCard) metricCohesionCard.style.display = hideCohesion ? "none" : "block";

      if (!metrics || hideCohesion) {
        renderSingleMetric(cohesionScoreText, cohesionMeterFill, cohesionSubText, null);
      } else if (sentenceCount < 2) {
        cohesionScoreText.textContent = "—";
        cohesionMeterFill.style.width = "0%";
        cohesionScoreText.classList.remove("perfect");
        cohesionMeterFill.classList.remove("perfect");
        cohesionSubText.textContent = "Add sentence links (transitions/boundaries)";
      } else {
        renderSingleMetric(cohesionScoreText, cohesionMeterFill, cohesionSubText, metrics?.cohesion);
      }
      if (metricPrecisionCard) metricPrecisionCard.style.display = "block";
    }

    function closeMetricPopover() {
      if (!metricInfoPopover) return;
      metricInfoPopover.classList.add("hidden");
    }

    function openMetricPopover(anchorEl, key) {
      if (!metricInfoPopover || !metricInfoTitle || !metricInfoBody || !anchorEl) return;
      const info = METRIC_INFO[key];
      if (!info) return;

      metricInfoTitle.textContent = info.title || "";
      metricInfoBody.innerHTML = "";

      const bodyCopy = document.createElement("div");
      bodyCopy.textContent = info.body || "";
      metricInfoBody.appendChild(bodyCopy);

      const tipsTitle = document.createElement("div");
      tipsTitle.className = "metric-popover-tips-title";
      tipsTitle.textContent = "Tips to improve";
      metricInfoBody.appendChild(tipsTitle);

      const tipsList = document.createElement("ul");
      tipsList.className = "metric-popover-list";
      (info.tips || []).forEach((tip) => {
        const li = document.createElement("li");
        li.textContent = tip;
        tipsList.appendChild(li);
      });
      metricInfoBody.appendChild(tipsList);

      metricInfoPopover.classList.remove("hidden");
      metricInfoPopover.style.visibility = "hidden";
      metricInfoPopover.style.display = "block";

      const gap = 10;
      const padding = 12;
      const rect = anchorEl.getBoundingClientRect();
      const popRect = metricInfoPopover.getBoundingClientRect();
      const fitsBelow = rect.bottom + gap + popRect.height <= window.innerHeight;

      let top = fitsBelow ? rect.bottom + gap : rect.top - popRect.height - gap;
      top = Math.max(padding, Math.min(top, window.innerHeight - popRect.height - padding));

      let left = rect.left + rect.width / 2 - popRect.width / 2;
      left = Math.max(padding, Math.min(left, window.innerWidth - popRect.width - padding));

      metricInfoPopover.style.top = `${Math.round(top)}px`;
      metricInfoPopover.style.left = `${Math.round(left)}px`;
      metricInfoPopover.style.visibility = "visible";
    }

    document.addEventListener("click", (e) => {
      const btn = e.target.closest(".metric-info-btn");
      if (btn) {
        const key = btn.dataset.metric;
        openMetricPopover(btn, key);
        return;
      }
      if (metricInfoPopover && !metricInfoPopover.classList.contains("hidden")) {
        const clickedInside = e.target.closest("#metricInfoPopover");
        if (!clickedInside) closeMetricPopover();
      }
    });

    if (metricInfoClose) {
      metricInfoClose.addEventListener("click", closeMetricPopover);
    }

    async function getMetricsTextSource() {
      const previewText = extractPreviewText();
      if (previewText) return previewText;
      if (!selectedFile || !mammoth) return "";
      try {
        const arrayBuffer = await selectedFile.arrayBuffer();
        if (mammoth.convertToRawText) {
          const raw = await mammoth.convertToRawText({ arrayBuffer });
          return raw?.value || "";
        }
        if (mammoth.convertToHtml) {
          const htmlResult = await mammoth.convertToHtml({ arrayBuffer });
          return stripTags(htmlResult?.value || "");
        }
      } catch (err) {
        console.warn("Metrics fallback text extraction failed:", err);
      }
      return "";
    }

    async function refreshStudentMetrics() {
      const text = await getMetricsTextSource();
      if (!text) {
        renderMetrics(null);
        return;
      }
      const mode = modeSelect ? modeSelect.value : "";
      const metrics = computeMetricsFromText(text, mode);
      renderMetrics(metrics);
    }

    function setApplyAttention(applyBtn) {
      if (!applyBtn) return;
      applyBtn.classList.add("apply-attention");
      if (applyBtn._attentionTimer) clearTimeout(applyBtn._attentionTimer);
      applyBtn._attentionTimer = setTimeout(() => {
        applyBtn.classList.remove("apply-attention");
        applyBtn._attentionTimer = null;
      }, 6000);
    }

    function clearApplyAttention(applyBtn) {
      if (!applyBtn) return;
      applyBtn.classList.remove("apply-attention");
      if (applyBtn._attentionTimer) {
        clearTimeout(applyBtn._attentionTimer);
        applyBtn._attentionTimer = null;
      }
    }

    function upsertApprovedRewrite(entry) {
      if (!entry || !entry.exampleKey) return;
      const existingIndex = approvedRewrites.findIndex(
        (item) => item.exampleKey === entry.exampleKey
      );
      if (existingIndex >= 0) {
        approvedRewrites[existingIndex] = { ...approvedRewrites[existingIndex], ...entry };
      } else {
        approvedRewrites.push(entry);
      }
    }

    function removeApprovedRewriteByKey(exampleKey) {
      if (!exampleKey) return;
      const idx = approvedRewrites.findIndex((item) => item.exampleKey === exampleKey);
      if (idx >= 0) {
        approvedRewrites.splice(idx, 1);
      }
    }

    function setApprovedRewritesCollapsed(collapsed) {
      approvedRewritesCollapsed = !!collapsed;
      if (approvedRewritesWrap) {
        approvedRewritesWrap.dataset.collapsed = approvedRewritesCollapsed ? "true" : "false";
      }
      if (approvedRewritesToggle) {
        approvedRewritesToggle.setAttribute("aria-expanded", String(!approvedRewritesCollapsed));
      }
    }

    function updateApprovedRewritesToggle(visibleCount) {
      if (!approvedRewritesToggle) return;
      const countText = Number.isFinite(visibleCount) ? ` (${visibleCount})` : "";
      approvedRewritesToggle.textContent = `${approvedRewritesCollapsed ? "Show" : "Hide"} approved rewrites${countText}`;
    }

    function renderApprovedRewritesList() {
      if (!approvedRewritesList || !approvedRewritesWrap) return;
      approvedRewritesList.innerHTML = "";

      const approvedForList = approvedRewrites.filter(
        (entry) => entry.exampleKey && entry.exampleKey !== currentExampleKey
      );

      if (!approvedForList.length) {
        approvedRewritesWrap.style.display = "none";
        updateApplyAllUI();
        return;
      }

      approvedRewritesWrap.style.display = "block";
      setApprovedRewritesCollapsed(approvedRewritesCollapsed);
      updateApprovedRewritesToggle(approvedForList.length);

      approvedForList.forEach((entry) => {
        const li = document.createElement("li");
        li.className = "approved-rewrite-card";
        li.dataset.exampleKey = entry.exampleKey;
        li.dataset.approvedRewrite = entry.rewriteText || "";
        li.dataset.label = entry.label || "";
        li._exampleData = entry.examplePayload || null;

        const labelDiv = document.createElement("div");
        labelDiv.className = "approved-rewrite-label";
        labelDiv.textContent = entry.label || "Issue";

        const textDiv = document.createElement("div");
        textDiv.className = "approved-rewrite-text";
        textDiv.textContent = entry.rewriteText || "";

        const statusDiv = document.createElement("div");
        statusDiv.className = "rewrite-status";

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "approved-rewrite-actions";

        const applyBtn = document.createElement("button");
        applyBtn.className = "example-btn apply-to-preview-btn";
        applyBtn.textContent = "Apply to Preview";
        applyBtn.onclick = () => {
          const applied = applyRewriteToPreviewByKey({
            exampleKey: entry.exampleKey,
            rewriteText: entry.rewriteText,
            exampleData: entry.examplePayload,
            statusDiv,
            applyBtn,
            exampleRow: li
          });
          if (applied) {
            renderCurrentExample();
            updateApplyAllUI();
          }
        };

        actionsDiv.appendChild(applyBtn);
        li.appendChild(labelDiv);
        li.appendChild(textDiv);
        li.appendChild(statusDiv);
        li.appendChild(actionsDiv);
        approvedRewritesList.appendChild(li);
      });
      updateApplyAllUI();
    }

    function updateApplyAllUI(totalApprovedCount = approvedRewrites.length) {
      if (!applyAllToPreviewBtn) return;
      const approvedCount = totalApprovedCount;
      if (approvedCount >= 2) {
        applyAllToPreviewBtn.style.display = "block";
        applyAllToPreviewBtn.disabled = false;
        applyAllToPreviewBtn.classList.add("apply-attention");
      } else {
        applyAllToPreviewBtn.style.display = "none";
        applyAllToPreviewBtn.disabled = true;
        applyAllToPreviewBtn.classList.remove("apply-attention");
      }
    }

    function resetRevisionPracticeUI() {
      if (revisionPracticeCard) revisionPracticeCard.style.display = "none";
      if (issueExplanationBlock) issueExplanationBlock.style.display = "none";
      if (examplesList) examplesList.innerHTML = "";
      if (allApprovedBanner) allApprovedBanner.style.display = "none";
      if (examplesEmptyState) examplesEmptyState.style.display = "none";
      if (approvedRewritesList) approvedRewritesList.innerHTML = "";
      if (approvedRewritesWrap) approvedRewritesWrap.style.display = "none";
      approvedRewrites.length = 0;
      currentExampleKey = null;
      approvedRewritesCollapsed = true;
      setApprovedRewritesCollapsed(true);
      approvedRewriteByKey.clear();
      approvedExampleKeys.clear();
      draftRewriteByKey.clear();
      exampleDataByKey.clear();
      examplesByIssueId.clear();
      if (applyAllToPreviewBtn) {
        applyAllToPreviewBtn.style.display = "none";
        applyAllToPreviewBtn.disabled = true;
        applyAllToPreviewBtn.classList.remove("apply-attention");
      }
      if (downloadRevisionNotesBtn) downloadRevisionNotesBtn.style.display = "none";
      if (exampleNavRow) exampleNavRow.style.display = "none";
      if (exampleNavText) exampleNavText.textContent = "";
    }

    function revokeApprovedRewrite({ exampleKey, exampleRow, applyBtn, statusDiv }) {
      if (!exampleKey) return;
      approvedRewriteByKey.delete(exampleKey);
      approvedExampleKeys.delete(exampleKey);
      setExampleApprovalState(exampleKey, false);
      removeApprovedRewriteByKey(exampleKey);
      renderApprovedRewritesList();
      if (exampleRow) {
        exampleRow.classList.remove("example-approved", "example-applied");
        delete exampleRow.dataset.applied;
        delete exampleRow.dataset.approvedRewrite;
      }
      if (applyBtn) {
        applyBtn.disabled = true;
        clearApplyAttention(applyBtn);
      }
      if (statusDiv) {
        statusDiv.textContent = "Rewrite changed — approval cleared.";
        statusDiv.className = "rewrite-status visible bad";
      }
      if (examplesList && exampleRow) {
        examplesList.innerHTML = "";
        examplesList.appendChild(exampleRow);
      }
      updateApplyAllUI();
      updateAllApprovedBanner(currentExamplesAll);
    }

    function hideExamplesEmptyState() {
      if (examplesEmptyState) examplesEmptyState.style.display = "none";
    }

    function showExamplesEmptyState(message) {
      if (examplesList) examplesList.innerHTML = "";
      if (!examplesEmptyState) return;
      examplesEmptyState.textContent = message;
      examplesEmptyState.style.display = "block";
    }

    function isExampleApproved(example) {
      if (!example) return false;
      if (example.approved === true) return true;
      const key = getExampleKey(example);
      return key ? approvedExampleKeys.has(key) : false;
    }

    function isExampleApplied(example) {
      if (!example) return false;
      if (example.applied_to_preview === true) return true;
      const key = getExampleKey(example);
      return key ? appliedExampleKeys.has(key) : false;
    }

    function setExampleApprovalState(exampleKey, approved) {
      if (!exampleKey) return;
      currentExamplesAll.forEach((ex) => {
        if (getExampleKey(ex) === exampleKey) {
          ex.approved = !!approved;
        }
      });
    }

    function setExampleAppliedState(exampleKey, applied, label) {
      if (!exampleKey) return;
      const appliedValue = !!applied;
      currentExamplesAll.forEach((ex) => {
        if (getExampleKey(ex) === exampleKey) {
          ex.applied_to_preview = appliedValue;
        }
      });
      const exampleData = exampleDataByKey.get(exampleKey);
      if (exampleData) {
        exampleData.applied_to_preview = appliedValue;
      }
      saveAppliedFlag(label || currentLabel || "", exampleKey, appliedValue);
    }

    function updateAllApprovedBanner(examples) {
      if (!allApprovedBanner) return;
      const list = Array.isArray(examples) ? examples : [];
      const hasExamples = list.length > 0;
      const allApproved = hasExamples && list.every((ex) => isExampleApproved(ex));
      const allApplied = hasExamples && list.every((ex) => isExampleApplied(ex));
      allApprovedBanner.style.display = allApproved && !allApplied ? "block" : "none";
    }

    function escapeRegExp(str) {
      return String(str).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function extractQuotedTerms(text) {
      const t = String(text || "");
      const out = [];
      const patterns = [
        /'([^']+)'/g,
        /"([^"]+)"/g,
        /[‘']([^’']+)[’']/g,
        /[“"]([^”"]+)[”"]/g
      ];

      for (const re of patterns) {
        let m;
        while ((m = re.exec(t)) !== null) {
          const term = (m[1] || "").trim();
          if (term) out.push(term);
        }
      }
      return Array.from(new Set(out));
    }

    function findFoundTerms(sentence, labelText) {
      const s = String(sentence || "");
      const candidates = extractQuotedTerms(labelText);

      const found = [];
      const seen = new Set();

      for (const term of candidates) {
        if (!term) continue;

        let matchText = null;

        // If it's a simple word, prefer word-boundary match
        if (/^[A-Za-z0-9_]+$/.test(term)) {
          const re = new RegExp(`\\b${escapeRegExp(term)}\\b`, "i");
          const m = re.exec(s);
          if (m) matchText = m[0];
        } else {
          // Otherwise do a case-insensitive substring match
          const idx = s.toLowerCase().indexOf(term.toLowerCase());
          if (idx !== -1) matchText = s.slice(idx, idx + term.length);
        }

        if (matchText) {
          const key = matchText.toLowerCase();
          if (!seen.has(key)) {
            seen.add(key);
            found.push(matchText);
          }
        }
      }

      return found;
    }

    function formatFound(foundTerms) {
      if (!foundTerms || foundTerms.length === 0) return "that word/phrase";
      const quoted = foundTerms.map(w => `'${w}'`);
      if (quoted.length === 1) return quoted[0];
      if (quoted.length === 2) return `${quoted[0]} or ${quoted[1]}`;
      return `${quoted.slice(0, -1).join(", ")}, or ${quoted[quoted.length - 1]}`;
    }

    function resolveStudentGuidance(template, sentence, labelText) {
      const tmpl = String(template || "");
      if (!tmpl.includes("{FOUND}")) return tmpl;
      const foundTerms = findFoundTerms(sentence, labelText);
      const replacement = formatFound(foundTerms);
      return tmpl.split("{FOUND}").join(replacement);
    }

    function getRotationExamples() {
      return (currentExamplesAll || []).filter((ex) => {
        const key = getExampleKey(ex);
        if (!key) return false;
        if (appliedExampleKeys.has(key)) return false;
        if (isDismissedIssueInstance(ex?.label || currentLabel || "", ex?.sentence || "")) return false;
        return !approvedExampleKeys.has(key);
      });
    }

    function updateExampleNav(totalCount) {
      if (!exampleNavRow || !exampleNavText || !nextExampleBtn) return;
      if (!totalCount || totalCount <= 0) {
        exampleNavRow.style.display = "none";
        return;
      }
      exampleNavRow.style.display = "flex";
      exampleNavText.textContent = "";
      exampleNavText.style.display = "none";
      nextExampleBtn.disabled = totalCount <= 1;
    }

    function autosizeTextarea(el, maxHeight = 220) {
      if (!el) return;
      el.style.height = "auto";
      const nextHeight = Math.min(el.scrollHeight, maxHeight);
      el.style.height = `${nextHeight}px`;
      el.style.overflowY = el.scrollHeight > maxHeight ? "auto" : "hidden";
    }

    function renderCurrentExample() {
      if (!examplesList) return;

      const rotationExamples = getRotationExamples();
      updateAllApprovedBanner(currentExamplesAll);
      if (!rotationExamples.length) {
        const hasExamples = Array.isArray(currentExamplesAll) && currentExamplesAll.length > 0;
        const allApproved = hasExamples && currentExamplesAll.every((ex) => isExampleApproved(ex));
        const allApplied = hasExamples && currentExamplesAll.every((ex) => isExampleApplied(ex));
        if (allApproved && !allApplied) {
          hideExamplesEmptyState();
        } else {
          showExamplesEmptyState(
            getPreviewOnlyMessage(
              currentLabel || "",
              "No more examples for this issue. Click another bar to practice a different issue."
            )
          );
        }
        updateExampleNav(0);
        currentExampleKey = null;
        renderApprovedRewritesList();
        updateApplyAllUI();
        return;
      }

      hideExamplesEmptyState();
      currentIndex = ((currentIndex % rotationExamples.length) + rotationExamples.length) % rotationExamples.length;
      const ex = rotationExamples[currentIndex];
      const exampleKey = getExampleKey(ex);
      currentExampleKey = exampleKey || null;

      examplesList.innerHTML = "";
      activePowerVerbsHelper = null;

      const li = document.createElement("li");
      li.className = "example-item";
      li.dataset.label = currentLabel || ex?.label || "";
      if (exampleKey) li.dataset.exampleKey = exampleKey;

      const guidanceDiv = document.createElement("div");
      guidanceDiv.className = "example-guidance";
      if (currentGuidance) {
        const guidanceLabel = document.createElement("div");
        guidanceLabel.className = "example-guidance-label";
        guidanceLabel.textContent = "Student guidance";
        const guidanceText = document.createElement("div");
        guidanceText.className = "example-guidance-text";
        guidanceText.textContent = resolveStudentGuidance(
          currentGuidance,
          ex.sentence || "",
          currentLabelText || currentLabel || ""
        );
        guidanceDiv.appendChild(guidanceLabel);
        guidanceDiv.appendChild(guidanceText);
      } else {
        guidanceDiv.style.display = "none";
      }

      const exampleMetaDiv = document.createElement("div");
      exampleMetaDiv.className = "example-meta";
      exampleMetaDiv.textContent = `Issue ${currentIndex + 1} of ${rotationExamples.length}`;

      const rewriteTextarea = document.createElement("textarea");
      rewriteTextarea.className = "example-rewrite";
      rewriteTextarea.placeholder = "Edit directly here...";
      const originalSentence = ex.sentence || "";
      li.dataset.originalSentence = originalSentence;
      li.dataset.paragraphIndex = String(ex.paragraph_index ?? "");
      li._exampleData = ex;

      const approvedRewrite = approvedRewriteByKey.get(exampleKey);
      const draftRewrite = draftRewriteByKey.get(exampleKey);
      rewriteTextarea.value = approvedRewrite || draftRewrite || originalSentence;
      autosizeTextarea(rewriteTextarea);

      rewriteTextarea.addEventListener("focus", () => {
        cursorHighlightExampleInPreview(ex);
      });
      rewriteTextarea.addEventListener("input", () => {
        cursorHighlightExampleInPreview(ex);
        autosizeTextarea(rewriteTextarea);
        if (exampleKey) {
          draftRewriteByKey.set(exampleKey, rewriteTextarea.value);
        }
        if (exampleKey && (approvedExampleKeys.has(exampleKey) || li.dataset.approvedRewrite)) {
          const applyBtn = li.querySelector(".apply-to-preview-btn");
          revokeApprovedRewrite({
            exampleKey,
            exampleRow: li,
            applyBtn,
            statusDiv: rewriteStatusDiv
          });
        }
      });

      const powerVerbsHelper = buildPowerVerbsHelper(currentLabelText || currentLabel || "", rewriteTextarea);

      const rewriteStatusDiv = document.createElement("div");
      rewriteStatusDiv.className = "rewrite-status";

      const actionsDiv = document.createElement("div");
      actionsDiv.className = "example-actions";

      const resetExampleBtn = document.createElement("button");
      resetExampleBtn.className = "example-btn";
      resetExampleBtn.textContent = "Reset example";
      resetExampleBtn.onclick = () => {
        rewriteTextarea.value = originalSentence;
        autosizeTextarea(rewriteTextarea);
        if (exampleKey) {
          draftRewriteByKey.set(exampleKey, originalSentence);
        }
      };

      const copyRewriteBtn = document.createElement("button");
      copyRewriteBtn.className = "example-btn";
      copyRewriteBtn.textContent = "Copy your rewrite";
      copyRewriteBtn.onclick = () => {
        navigator.clipboard.writeText(rewriteTextarea.value).then(() => {
          copyRewriteBtn.textContent = "Copied!";
          setTimeout(() => copyRewriteBtn.textContent = "Copy your rewrite", 2000);
        });
      };

      const findInPreviewBtn = document.createElement("button");
      findInPreviewBtn.className = "example-btn";
      findInPreviewBtn.textContent = "Find in preview";
      findInPreviewBtn.onclick = () => {
        if (markedPreviewCard.style.display === "none" || !markedPreview || !markedPreview.innerText.trim()) {
          rewriteStatusDiv.textContent = "Click \"Mark my essay\" to load the preview first.";
          rewriteStatusDiv.className = "rewrite-status visible";
          rewriteStatusDiv.classList.remove("ok", "bad");
          return;
        }
        highlightAndScrollToExample(ex, rewriteStatusDiv);
      };

      const checkRewriteBtn = document.createElement("button");
      checkRewriteBtn.className = "example-btn";
      checkRewriteBtn.textContent = "Check rewrite";
      checkRewriteBtn.onclick = async () => {
        await checkRewrite(currentLabel || ex?.label || "", ex, rewriteTextarea, rewriteStatusDiv, checkRewriteBtn);
      };

      const applyToPreviewBtn = document.createElement("button");
      applyToPreviewBtn.className = "example-btn apply-to-preview-btn";
      applyToPreviewBtn.textContent = "Apply to Preview";
      applyToPreviewBtn.disabled = true;
      applyToPreviewBtn.onclick = () => {
        const rewriteText = approvedRewriteByKey.get(exampleKey);
        const applied = applyRewriteToPreviewByKey({
          exampleKey,
          rewriteText,
          exampleData: ex,
          statusDiv: rewriteStatusDiv,
          applyBtn: applyToPreviewBtn,
          exampleRow: li
        });
        if (applied) {
          renderCurrentExample();
          updateApplyAllUI();
        }
      };

      const dismissIssueBtn = document.createElement("button");
      dismissIssueBtn.className = "example-btn example-action remove-issue-btn";
      dismissIssueBtn.textContent = "Dismiss issue";
      dismissIssueBtn.onclick = async () => {
        await dismissIssue(currentLabel || ex?.label || "", ex, rewriteStatusDiv, dismissIssueBtn);
      };

      actionsDiv.appendChild(resetExampleBtn);
      actionsDiv.appendChild(copyRewriteBtn);
      actionsDiv.appendChild(findInPreviewBtn);
      actionsDiv.appendChild(checkRewriteBtn);
      actionsDiv.appendChild(applyToPreviewBtn);
      actionsDiv.appendChild(dismissIssueBtn);

      // Keyboard shortcut: Ctrl+Enter (Windows) / Cmd+Enter (Mac)
      rewriteTextarea.addEventListener("keydown", async (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
          e.preventDefault();
          await checkRewrite(currentLabel || ex?.label || "", ex, rewriteTextarea, rewriteStatusDiv, checkRewriteBtn);
        }
      });

      if (exampleKey && approvedExampleKeys.has(exampleKey) && approvedRewrite) {
        applyToPreviewBtn.disabled = false;
        setApplyAttention(applyToPreviewBtn);
      }

      li.appendChild(guidanceDiv);
      li.appendChild(exampleMetaDiv);
      li.appendChild(rewriteTextarea);
      if (powerVerbsHelper) li.appendChild(powerVerbsHelper);
      li.appendChild(rewriteStatusDiv);
      li.appendChild(actionsDiv);

      examplesList.appendChild(li);
      updateExampleNav(rotationExamples.length);
      updateApplyAllUI();
      renderApprovedRewritesList();
      updateAllApprovedBanner(currentExamplesAll);
    }

    function refreshIssueCountUI() {
      if (!lastRevisionSectionData || !issueSelect) return;

      lastRevisionSectionData.labelCounts = { ...liveLabelCounts };
      renderIssueButtonsFromSectionData(
        lastRevisionSectionData,
        lastRevisionSectionData.sectionOrder
      );

      const currentIssueId = currentLabel ? getIssueIdForLabel(currentLabel) : "";
      const sortedLabels = Object.entries(liveLabelCounts)
        .filter(([, count]) => (count || 0) > 0)
        .sort((a, b) => (b[1] || 0) - (a[1] || 0))
        .map(([label]) => String(label || "").trim())
        .filter(Boolean);

      issueSelect.innerHTML = '<option value="">Select an issue...</option>';
      sortedLabels.forEach((label) => {
        const option = document.createElement("option");
        const issueId = getIssueIdForLabel(label);
        option.value = issueId;
        option.dataset.issueLabel = label;
        const count = liveLabelCounts[label] || 0;
        option.textContent = `${label} (${count})`;
        issueSelect.appendChild(option);
      });

      if (currentIssueId && liveLabelCounts[currentLabel]) {
        issueSelect.value = currentIssueId;
      }
    }

    function clearFile() {
      // Safety: stop any in-progress button loader
      stopButtonLoading(checkBtn, () => !!selectedFile);
      showMarkButtonHideRecheck();
      if (resultsCard) resultsCard.style.display = "none";
      selectedFile = null;
      hasStartedRevising = false;
      fileInput.value = "";
      downloadUrl = null;
      markedBlob = null;
      downloadBtn.style.display = "none";
      statusArea.textContent = "";
      statusArea.className = "status-area";
      liveLabelCounts = {};
      resetIssueIdMaps();
      appliedExampleKeys.clear();
      approvedExampleKeys.clear();
      currentLabel = null;
      currentExamplesAll = [];
      currentIndex = 0;
      currentGuidance = "";
      currentLabelText = "";
      draftRewriteByKey.clear();
      approvedRewriteByKey.clear();
      exampleDataByKey.clear();
      examplesByIssueId.clear();
      approvedRewrites.length = 0;
      markedPreviewCard.style.display = "none";
      markedPreview.innerHTML = "";
      resetRevisionPracticeUI();
      issueSelect.innerHTML = '<option value="">Select an issue...</option>';
      if (issueButtonsWrap) issueButtonsWrap.innerHTML = "";
      if (recheckDocumentBtn) recheckDocumentBtn.disabled = true;
      currentMarkEvent = null;
      currentWordCount = null;
      currentTechniques = [];
      detectedWork = null;
      if (statsPanel) statsPanel.style.display = "none";
      if (wordCountStat) wordCountStat.textContent = "—";
      if (totalIssuesStat) totalIssuesStat.textContent = "—";
      if (topIssueRow) topIssueRow.style.display = "none";
      if (topIssueStat) topIssueStat.textContent = "";
      if (techniquesStatWrap) techniquesStatWrap.style.display = "none";
      if (techniquesStatList) techniquesStatList.textContent = "";
      // Hide + reset Most Common Issues chart
      if (mostCommonIssuesWrap) mostCommonIssuesWrap.style.display = "none";
      if (mostCommonIssuesChart) {
        mostCommonIssuesChart.destroy();
        mostCommonIssuesChart = null;
      }
      renderMetrics(null);

      updateFileUI();
    }

    clearFileBtn.addEventListener("click", clearFile);

    // Click drop zone to open file picker
    dropZone.addEventListener("click", () => fileInput.click());

    dropZone.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        fileInput.click();
      }
    });

    // ===== Extract metadata from docx =====
    
    // Helper: Strip HTML tags and get plain text
    function stripTags(html) {
      const tmp = document.createElement("div");
      tmp.innerHTML = html;
      return tmp.textContent || tmp.innerText || "";
    }
    
    // Helper: Normalize typography (curly quotes to straight quotes, non-breaking spaces, whitespace)
    function normalizeTypography(s) {
      return (s || "")
        .replace(/\u00A0/g, " ")
        // smart double quotes + guillemets → "
        .replace(/[\u201C\u201D\u201E\u201F\u00AB\u00BB]/g, '"')
        // smart single quotes/apostrophes → '
        .replace(/[\u2018\u2019\u201A\u201B]/g, "'")
        // primes sometimes appear as quotes
        .replace(/[\u2032\u2035]/g, "'")
        .replace(/[\u2033\u2036]/g, '"')
        // normalize dashes
        .replace(/[\u2013\u2014]/g, "-")
        .replace(/\s+/g, " ")
        .trim();
    }
    
    // Helper: Normalize punctuation (curly quotes/apostrophes to straight ones, non-breaking spaces)
    function normalizePunct(s) {
      // keep legacy callsites; normalizeTypography already handles quotes/apostrophes
      return normalizeTypography(s);
    }
    
    // Helper: Check if a period is part of an initial or abbreviation
    function isInitialOrAbbrevDot(t, i) {
      if (t[i] !== ".") return false;
      const before = t.slice(0, i + 1);
      const after = t.slice(i + 1);

      // single-letter initial: "F." "M." etc, followed by space + capital
      if (/\b[A-Z]\.$/.test(before) && /^\s+[A-Z]/.test(after)) return true;

      // common abbrevs
      if (/\b(?:Mr|Ms|Mrs|Dr|Prof|Sr|Jr|St)\.$/.test(before) && /^\s+[A-Z]/.test(after)) return true;

      // U.S. / U.K. style
      if (/\b[A-Z]\.[A-Z]\.$/.test(before) && /^\s+[A-Z]/.test(after)) return true;

      return false;
    }

    // Helper: Find the index of the sentence end, accounting for quotes and initials
    function findSentenceEndIndex(text) {
      const t = normalizeTypography(text);
      let inQuotes = false;

      for (let i = 0; i < t.length; i++) {
        const ch = t[i];

        // IMPORTANT: only treat double quotes as quotes. Never treat apostrophe as a quote delimiter.
        if (ch === '"') inQuotes = !inQuotes;
        if (inQuotes) continue;

        if (ch === "." || ch === "!" || ch === "?") {
          if (ch === "." && isInitialOrAbbrevDot(t, i)) continue;
          return i;
        }
      }
      return -1;
    }

    // Helper: Check if text has sentence-ending punctuation
    function hasSentenceEnd(text) {
      return findSentenceEndIndex(text) !== -1;
    }
    
    // Helper: Check if text looks like a student essay-title header format
    function isEssayTitleHeaderLine(text) {
      const s = normalizeTypography(text);
      // "Quotation": Topic in Essay Title
      return /^"[^"]+"\s*:\s*.+/.test(s) && !hasSentenceEnd(s);
    }
    
    // Helper: Check if text looks like a header or title line (not an intro sentence)
    function isLikelyHeaderOrTitle(text) {
      const plainText = normalizeTypography(text);
      
      // First check: Skip student essay-title header format
      if (isEssayTitleHeaderLine(plainText)) {
        return true;
      }
      
      // 1) ANY paragraph without sentence-ending punctuation is likely a header/title
      // (unless it's extremely long, which suggests it's actual content)
      if (!hasSentenceEnd(plainText) && plainText.length <= 220) {
        return true;
      }
      
      // Keep the old check for backward compatibility with very short lines
      if (plainText.length <= 80 && !hasSentenceEnd(plainText)) {
        return true;
      }
      
      // 2) Looks like a date line
      if (/\b\d{1,2}\/\d{1,2}(\/\d{2,4})?\b/.test(plainText)) {
        return true;
      }
      const monthMatch = /\b(january|february|march|april|may|june|july|august|september|october|november|december)\b/i.test(plainText);
      if (monthMatch && /\d/.test(plainText)) {
        return true;
      }
      
      // 3) Looks like a teacher/class line
      if (/\b(Mr\.|Ms\.|Mrs\.|Dr\.|Professor|Prof\.)\b/i.test(plainText)) {
        return true;
      }
      
      // 4) Looks like a student name line (1-4 tokens, all Title Case, no punctuation, no digits)
      const tokens = plainText.split(/\s+/).filter(t => t.length > 0);
      if (tokens.length >= 1 && tokens.length <= 4) {
        const allTitleCase = tokens.every(t => /^[A-Z][a-z]*$/.test(t));
        const noDigits = !/\d/.test(plainText);
        const noSentencePunct = !/[.!?]/.test(plainText);
        if (allTitleCase && noDigits && noSentencePunct) {
          return true;
        }
      }
      
      // 5) Looks like "Homework / Essay / Paper / Assignment" heading
      if (/^(homework|essay|paper|assignment)\b/i.test(plainText)) {
        return true;
      }
      
      return false;
    }
    
    // Helper: Count words in text
    function countWords(text) {
      const words = (text || "").match(/\b[A-Za-z]+\b/g) || [];
      return words.length;
    }
    
    // Helper: Clean title by removing surrounding quotes and trailing punctuation
    function cleanTitle(t) {
      t = normalizeTypography(t);
      t = t.replace(/^[\"']+/, "").replace(/[\"']+$/, "");
      // strip common trailing punctuation that's inside quotes in prose
      t = t.replace(/[,\.;:]+$/g, "");
      return t.trim();
    }
    
    // Helper: Extract first sentence from plain text
    function getFirstSentence(text) {
      const t = normalizeTypography(text);
      const idx = findSentenceEndIndex(t);
      return idx === -1 ? t : t.slice(0, idx + 1).trim();
    }
    
    async function extractMetaFromDocx(file) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        const result = await mammoth.convertToHtml({ arrayBuffer });
        const html = result.value;
        
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        
        // Parse HTML into a list of paragraphs with metadata
        const paras = Array.from(doc.querySelectorAll("p"))
          .map(p => {
            const html = p.innerHTML.trim();
            const plain = stripTags(html).trim();
            return {
              html,
              plain,
              wordCount: countWords(plain)
            };
          })
          .filter(p => p.plain.length > 0);
        
        if (paras.length === 0) return null;
        
        // Find the intro paragraph using priority selection:
        // A) First paragraph that: NOT header/title AND has sentence end AND >= 8 words
        // B) First paragraph that: NOT header/title AND has sentence end AND >= 5 words
        // C) First paragraph that: NOT header/title (but still requires sentence end)
        let introParagraphHtml = null;
        let introParagraphPlain = null;
        
        // Priority A: >= 8 words with sentence end
        for (const para of paras) {
          if (isLikelyHeaderOrTitle(para.plain)) continue;
          if (hasSentenceEnd(para.plain) && para.wordCount >= 8) {
            introParagraphHtml = para.html;
            introParagraphPlain = para.plain;
            break;
          }
        }
        
        // Priority B: >= 5 words with sentence end
        if (!introParagraphHtml) {
          for (const para of paras) {
            if (isLikelyHeaderOrTitle(para.plain)) continue;
            if (hasSentenceEnd(para.plain) && para.wordCount >= 5) {
              introParagraphHtml = para.html;
              introParagraphPlain = para.plain;
              break;
            }
          }
        }
        
        // Priority C: Any non-header paragraph with sentence end
        if (!introParagraphHtml) {
          for (const para of paras) {
            if (isLikelyHeaderOrTitle(para.plain)) continue;
            if (hasSentenceEnd(para.plain)) {
              introParagraphHtml = para.html;
              introParagraphPlain = para.plain;
              break;
            }
          }
        }
        
        if (!introParagraphHtml || !introParagraphPlain) {
          return null;
        }
        
        // IMPORTANT: Split intro paragraph on <br> if present to isolate intro sentence
        // Mammoth sometimes outputs student title + intro sentence in the same <p>
        let introSentenceHtml = introParagraphHtml;
        let selectedSegmentPlain = introParagraphPlain;
        
        // Split into segments by <br>
        const frag = document.createElement("div");
        frag.innerHTML = introParagraphHtml;
        
        const segments = [];
        let buf = [];
        
        // Walk through child nodes and split on <br>
        frag.childNodes.forEach(node => {
          if (node.nodeName === "BR") {
            if (buf.length > 0) {
              segments.push(buf);
              buf = [];
            }
          } else {
            buf.push(node);
          }
        });
        if (buf.length > 0) {
          segments.push(buf);
        }
        
        // If we found segments (meaning there were <br> tags), try to pick the first real sentence
        if (segments.length > 1) {
          let selectedSegment = null;
          
          // Priority 1: First segment with sentence end AND >= 8 words
          for (const buf of segments) {
            const segDiv = document.createElement("div");
            buf.forEach(n => {
              try {
                segDiv.appendChild(n.cloneNode(true));
              } catch (e) {
                // Skip nodes that can't be cloned (e.g., some text nodes)
              }
            });
            const segHtml = segDiv.innerHTML.trim();
            const segPlain = stripTags(segHtml).trim();
            
            // Skip essay title header segments
            if (isEssayTitleHeaderLine(segPlain)) continue;
            if (isLikelyHeaderOrTitle(segPlain)) continue;
            
            const wc = countWords(segPlain);
            
            if (hasSentenceEnd(segPlain) && wc >= 8) {
              selectedSegment = { html: segHtml, plain: segPlain };
              break;
            }
          }
          
          // Priority 2: First segment with sentence end AND >= 5 words
          if (!selectedSegment) {
            for (const buf of segments) {
              const segDiv = document.createElement("div");
              buf.forEach(n => {
                try {
                  segDiv.appendChild(n.cloneNode(true));
                } catch (e) {
                  // Skip nodes that can't be cloned
                }
              });
              const segHtml = segDiv.innerHTML.trim();
              const segPlain = stripTags(segHtml).trim();
              
              // Skip essay title header segments
              if (isEssayTitleHeaderLine(segPlain)) continue;
              if (isLikelyHeaderOrTitle(segPlain)) continue;
              
              const wc = countWords(segPlain);
              
              if (hasSentenceEnd(segPlain) && wc >= 5) {
                selectedSegment = { html: segHtml, plain: segPlain };
                break;
              }
            }
          }
          
          // If we found a selected segment, use it
          if (selectedSegment) {
            introSentenceHtml = selectedSegment.html;
            selectedSegmentPlain = selectedSegment.plain;
          }
          // Otherwise, fallback to whole paragraph (already set above)
        }
        
        // Extract first sentence from the selected segment
        const firstSentencePlain = getFirstSentence(selectedSegmentPlain);
        const firstSentenceNorm = normalizeTypography(firstSentencePlain);
        
        let detectedTitle = null;
        let detectedAuthor = null;
        let isMinor = true;
        
        // Extract title from intro sentence segment ONLY (not from essay title line)
        const frag2 = document.createElement("div");
        frag2.innerHTML = introSentenceHtml;
        
        // Helper: Check if element or any ancestor is italic
        function isItalicAncestor(el) {
          let current = el;
          while (current && current !== frag2) {
            if (current.nodeType === Node.ELEMENT_NODE) {
              const tagName = current.tagName?.toLowerCase();
              if (tagName === "em" || tagName === "i") return true;
              const style = current.style?.fontStyle || window.getComputedStyle(current).fontStyle;
              if (style && style.includes("italic")) return true;
            }
            current = current.parentNode;
          }
          return false;
        }
        
        // Collect italic phrases using TreeWalker
        const italicPhrases = [];
        const walker = document.createTreeWalker(
          frag2,
          NodeFilter.SHOW_TEXT,
          null
        );
        
        let currentPhrase = "";
        let node = walker.nextNode();
        
        while (node) {
          const isItalic = isItalicAncestor(node);
          const text = node.textContent || "";
          
          if (isItalic) {
            // Add text to current phrase
            currentPhrase += text;
          } else {
            // Non-italic node
            if (currentPhrase) {
              // If we have a phrase building, check if this is whitespace between italic nodes
              if (text.trim() === "" && text.length > 0) {
                // Single whitespace-only node between italic nodes - add space and continue
                currentPhrase += " ";
              } else {
                // Non-whitespace or empty - finalize the phrase
                if (currentPhrase.trim()) {
                  italicPhrases.push(currentPhrase);
                }
                currentPhrase = "";
              }
            }
          }
          
          node = walker.nextNode();
        }
        
        // Don't forget the last phrase if we ended in italic text
        if (currentPhrase.trim()) {
          italicPhrases.push(currentPhrase);
        }
        
        // Filter and normalize phrases
        const validPhrases = italicPhrases
          .map(p => normalizeTypography(p).trim())
          .filter(p => {
            if (p.length < 2 || p.length > 160) return false;
            // Not just punctuation/quotes
            if (/^[^\w]+$/.test(p)) return false;
            return true;
          });
        
        // Pick best phrase (prefer longest; tie-breaker: more Title-Cased words)
        if (validPhrases.length > 0) {
          function countTitleCaseWords(s) {
            const words = s.match(/\b[A-Z][a-z]+\b/g) || [];
            return words.length;
          }
          
          validPhrases.sort((a, b) => {
            if (b.length !== a.length) return b.length - a.length;
            return countTitleCaseWords(b) - countTitleCaseWords(a);
          });
          
          detectedTitle = cleanTitle(validPhrases[0]);
          isMinor = false;
        }
        
        // If no italics, check for quoted text (Minor work)
        if (!detectedTitle) {
          const quoted = Array.from(firstSentenceNorm.matchAll(/"([^"]+)"/g))
            .map(m => ({
              text: (m[1] || "").trim(),
              idx: m.index ?? 0
            }))
            .filter(x => x.text && x.text.length >= 2 && x.text.length <= 120);

          if (quoted.length) {
            // Prefer a quote that looks like a work title in context:
            // e.g., "essay "Title"", "article "Title"", "novel "Title"", etc.
            const workWords = /(essay|article|novel|poem|short story|story|play|film|movie|book|chapter|speech|song|album)\b/i;

            const hasNonQuestion = quoted.some(q => !q.text.includes("?"));

            function scoreCandidate(q) {
              const left = firstSentenceNorm.slice(Math.max(0, q.idx - 45), q.idx);
              let score = 0;

              if (workWords.test(left)) score += 10;         // strongest signal
              if (q.idx < firstSentenceNorm.length / 2) score += 2; // earlier is better

              // Questions are often quoted prompts, not titles (but allow if it's the only option)
              if (q.text.includes("?") && hasNonQuestion) score -= 6;

              return score;
            }

            quoted.sort((a, b) => scoreCandidate(b) - scoreCandidate(a) || a.idx - b.idx);

            detectedTitle = cleanTitle(quoted[0].text);
            isMinor = true;
          }
        }
        
        // Extract author from first sentence
        const NAME_STOPWORDS = new Set([
          "In","On","At","From","With","Without","By","For","To","As",
          "When","While","After","Before","During","Since","Because","Although","Though",
          "The","A","An","This","That","These","Those"
        ]);

        function cleanPossessive(tok) {
          return tok.replace(/['']s$/, "");
        }
        
        function isNameToken(tok) {
          if (!tok) return false;
          if (NAME_STOPWORDS.has(tok)) return false;

          // Initial: "F."
          if (/^[A-Z]\.$/.test(tok)) return true;

          // Single capital (rare but allow)
          if (/^[A-Z]$/.test(tok)) return true;

          // Name word: "Richard", "Selzer", "O'Connor", "Mary-Jane"
          if (/^[A-Z][a-z]+(?:[''][A-Z][a-z]+)?(?:-[A-Z][a-z]+(?:[''][A-Z][a-z]+)?)*$/.test(tok)) return true;

          return false;
        }

        function cleanAuthorName(s) {
          s = normalizeTypography(s);
          const parts = s.split(/\s+/).filter(Boolean);
          while (parts.length > 1 && NAME_STOPWORDS.has(parts[0])) parts.shift();
          return parts.join(" ");
        }
        
        function extractProperNounName(sentence, detectedTitle) {
          const toks = (sentence.match(/[A-Za-z'.-]+/g) || []).filter(Boolean);
          const titleKey = (detectedTitle || "").toLowerCase().replace(/[^a-z]+/g, " ").trim();
          const titleWords = new Set(titleKey.split(/\s+/).filter(Boolean));
          
          const candidates = [];
          let run = [];
          
          for (const raw of toks) {
            const tok = cleanPossessive(raw);
            // Skip stopwords at the start of a run
            if (run.length === 0 && NAME_STOPWORDS.has(tok)) continue;
            if (isNameToken(raw)) {
              run.push(tok);
              if (run.length > 6) run.shift();
            } else {
              if (run.length >= 2) candidates.push(run.slice());
              run = [];
            }
          }
          if (run.length >= 2) candidates.push(run.slice());
          
          // Filter out candidates that overlap heavily with title words
          const filtered = candidates
            .map(arr => arr.join(" "))
            .filter(name => {
              const words = name.toLowerCase().split(/\s+/);
              const overlap = words.filter(w => titleWords.has(w)).length;
              return overlap === 0;
            });
          
          if (filtered.length > 0) {
            const result = filtered[0];
            // Remove leading stopword if present
            const parts = result.split(/\s+/);
            if (parts.length > 1 && NAME_STOPWORDS.has(parts[0])) {
              return parts.slice(1).join(" ");
            }
            return result;
          }
          return null;
        }

        // Priority: possessive anywhere (best for "In Richard Selzer's …")
        const NAME_TOKEN = "(?:[A-Z]\\.|[A-Z][a-z]+(?:[''][A-Z][a-z]+)?(?:-[A-Z][a-z]+(?:[''][A-Z][a-z]+)?)*)";
        const NAME_RUN = `${NAME_TOKEN}(?:\\s+${NAME_TOKEN}){0,6}`;

        let possMatches = Array.from(firstSentenceNorm.matchAll(new RegExp(`\\b(${NAME_RUN})['']s\\b`, "g")));
        if (possMatches.length) {
          // choose longest then earliest
          possMatches.sort((a,b) => b[1].split(/\s+/).length - a[1].split(/\s+/).length || (a.index ?? 0) - (b.index ?? 0));
          detectedAuthor = cleanAuthorName(possMatches[0][1]);
        }

        // Next: "by Author"
        if (!detectedAuthor) {
          const by = firstSentenceNorm.match(new RegExp(`\\b[Bb]y\\s+(${NAME_RUN})\\b`));
          if (by) detectedAuthor = cleanAuthorName(by[1]);
        }

        // Fallback: improved proper-noun run extraction
        if (!detectedAuthor) {
          detectedAuthor = extractProperNounName(firstSentenceNorm, detectedTitle);
        }
        
        // Sanity tests (non-breaking)
        try {
          // Test: getFirstSentence should not stop at initials
          const test1 = getFirstSentence("In F. Scott Fitzgerald's novel \"The Great Gatsby,\" ...");
          console.assert(test1.includes("Fitzgerald"), "getFirstSentence should include Fitzgerald and not stop at F.");
          
          // Test: possessive author extraction works for curly apostrophe
          const test2Norm = normalizeTypography("In Richard Selzer's story \"The Knife,\" ...");
          const test2Matches = Array.from(test2Norm.matchAll(new RegExp(`\\b(${NAME_RUN})['']s\\b`, "g")));
          console.assert(test2Matches.length > 0 && test2Matches[0][1].includes("Selzer"), "Possessive author extraction should work for curly apostrophe");
          
          // Test: quoted title extraction works for curly quotes
          const test3Norm = normalizeTypography("In \"The Knife,\" Richard Selzer...");
          const test3Quoted = Array.from(test3Norm.matchAll(/"([^"]+)"/g));
          console.assert(test3Quoted.length > 0, "Quoted title extraction should work for curly quotes after normalization");
        } catch (testError) {
          // Silently ignore test errors to not break production
        }
        
        // Calculate word count: sum wordCount for paragraphs that are NOT header/title
        let wordCount = 0;
        for (const para of paras) {
          if (!isLikelyHeaderOrTitle(para.plain)) {
            wordCount += para.wordCount;
          }
        }
        
        return { title: detectedTitle, author: detectedAuthor, isMinor, wordCount };
      } catch (error) {
        console.error("Error extracting metadata:", error);
        return null;
      }
    }

    // File selection
    fileInput.addEventListener("change", async (e) => {
      const files = e.target.files;
      if (files && files.length > 0) {
        selectedFile = files[0];
        if (statsPanel) statsPanel.style.display = "none";
        loadDismissedIssuesFromStorage();
        updateFileUI();
        showMarkButtonHideRecheck();

        const meta = await extractMetaFromDocx(selectedFile);
        detectedWork = null;
        if (meta?.title && meta?.author) {
          detectedWork = {
            author: meta.author,
            title: meta.title,
            isMinor: !!meta.isMinor,
            confidence: "high"
          };
        } else if (meta?.title || meta?.author) {
          detectedWork = {
            author: meta?.author || "",
            title: meta?.title || "",
            isMinor: !!meta?.isMinor,
            confidence: "low"
          };
        }
        if (meta && meta.wordCount !== undefined) {
          currentWordCount = meta.wordCount;
          updateStatsPanel(liveLabelCounts);
        }
        startPostUploadTour();
      }
    });

    // Global file drag/drop guard:
    // - Prevent browser from opening/navigating to dropped files anywhere on the page.
    // - Only allow our custom handling when the drop target is inside #dropZone.
    // - Use capture phase so we intercept before the browser/default handlers.
    function isFileDragEvent(e) {
      const dt = e.dataTransfer;
      if (!dt) return false;

      // "Files" appears in types during file drag in most browsers
      const types = dt.types ? Array.from(dt.types) : [];
      if (types.includes("Files")) return true;

      // Fallback (some browsers/devtools quirks)
      return !!(dt.files && dt.files.length);
    }

    function isInsideDropZone(target) {
      return dropZone && target instanceof Node && dropZone.contains(target);
    }

    function guardFileDnD(e) {
      // Only interfere with file drags/drops (do not break text dragging inside inputs)
      if (!isFileDragEvent(e)) return;

      // Always cancel default so the browser never opens/navigates to the file
      e.preventDefault();

      // If NOT inside the dropZone, block any other handlers too
      if (!isInsideDropZone(e.target)) {
        e.stopPropagation();

        // Optional UX hint: show "not allowed" cursor on dragover
        if (e.type === "dragover") {
          try { e.dataTransfer.dropEffect = "none"; } catch (_) {}
        }
      }
    }

    // Capture phase + passive:false so preventDefault always works.
    ["dragenter", "dragover", "drop"].forEach((evt) => {
      window.addEventListener(evt, guardFileDnD, { capture: true, passive: false });
    });

    // Drag & drop
    ["dragenter", "dragover"].forEach(evt => {
      dropZone.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.add("dragover");
      });
    });

    ["dragleave", "dragend"].forEach(evt => {
      dropZone.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove("dragover");
      });
    });

    dropZone.addEventListener("drop", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove("dragover");

      if (e.dataTransfer && e.dataTransfer.files) {
        const files = Array.from(e.dataTransfer.files);
        const docxFiles = files.filter(f => /\.docx$/i.test(f.name));
        if (docxFiles.length > 1) {
          statusArea.textContent = "Please drop only one .docx file.";
          statusArea.className = "status-area error";
          return;
        }
        const docxFile = docxFiles[0];
        if (docxFile) {
          selectedFile = docxFile;
          if (statsPanel) statsPanel.style.display = "none";
          loadDismissedIssuesFromStorage();
          // Update file input programmatically
          const dt = new DataTransfer();
          dt.items.add(docxFile);
          fileInput.files = dt.files;
          updateFileUI();
          showMarkButtonHideRecheck();

          const meta = await extractMetaFromDocx(selectedFile);
          detectedWork = null;
          if (meta?.title && meta?.author) {
            detectedWork = {
              author: meta.author,
              title: meta.title,
              isMinor: !!meta.isMinor,
              confidence: "high"
            };
          } else if (meta?.title || meta?.author) {
            detectedWork = {
              author: meta?.author || "",
              title: meta?.title || "",
              isMinor: !!meta?.isMinor,
              confidence: "low"
            };
          }
          if (meta && meta.wordCount !== undefined) {
            currentWordCount = meta.wordCount;
            updateStatsPanel(liveLabelCounts);
          }
          startPostUploadTour();
        } else {
          statusArea.textContent = "Please upload a .docx file.";
          statusArea.className = "status-area error";
        }
      }
    });

    // ===== Form submission =====
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      resetRevisionPracticeUI();
      if (statsPanel) statsPanel.style.display = "none";

      if (!selectedFile) {
        statusArea.textContent = "Please select a .docx file.";
        statusArea.className = "status-area error";
        if (resultsCard) resultsCard.style.display = "block";
        return;
      }

      // Get session
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        statusArea.textContent = "You must be logged in.";
        statusArea.className = "status-area error";
        if (resultsCard) resultsCard.style.display = "block";
        return;
      }

      const formData = buildMarkFormData({ includeSummaryTable: false });
      if (!formData) {
        statusArea.textContent = "Please select a .docx file.";
        statusArea.className = "status-area error";
        if (resultsCard) resultsCard.style.display = "block";
        return;
      }

      // Update UI (don’t show Uploading... in Results; show it on the button instead)
      if (resultsCard) resultsCard.style.display = "none";
      statusArea.textContent = "";
      statusArea.className = "status-area";
      downloadBtn.style.display = "none";
      if (mostCommonIssuesWrap) mostCommonIssuesWrap.style.display = "none";
      if (mostCommonIssuesChart) {
        mostCommonIssuesChart.destroy();
        mostCommonIssuesChart = null;
      }
      startButtonLoading(checkBtn, "Mark my essay");

      try {
        // Call API
        const API_URL = "https://vysti-rules.onrender.com/mark";
        const response = await fetch(API_URL, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${sessionData.session.access_token}`,
          },
          body: formData,
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(`HTTP ${response.status}: ${text.substring(0, 100)}`);
        }

        const techHeader = response.headers.get("X-Vysti-Techniques");
        if (techHeader) {
          try {
            const parsed = JSON.parse(techHeader);
            currentTechniques = Array.isArray(parsed) ? parsed : [];
          } catch (err) {
            console.warn("Failed to parse techniques header:", err);
            currentTechniques = [];
          }
        } else {
          currentTechniques = [];
        }

        const blob = await response.blob();
        markedBlob = blob;
        downloadUrl = URL.createObjectURL(blob);
        
        const baseName = selectedFile.name.replace(/\.docx$/i, "");
        downloadBtn.onclick = async () => {
          if (!selectedFile || !markedPreview) return;

          const previewText = extractPreviewText();
          if (!previewText) {
            statusArea.textContent = "Could not extract text from preview.";
            statusArea.className = "status-area error";
            if (resultsCard) resultsCard.style.display = "block";
            return;
          }

          startButtonLoading(downloadBtn, "Download marked essay");
          try {
            const { data: sessionData } = await supa.auth.getSession();
            if (!sessionData || !sessionData.session) {
              throw new Error("You must be logged in.");
            }

            const currentMode = modeSelect ? modeSelect.value : "textual_analysis";
            const API_BASE = "https://vysti-rules.onrender.com";
            const markTextPayload = {
              file_name: selectedFile.name,
              text: previewText,
              mode: currentMode,
              highlight_thesis_devices: false,
              include_summary_table: true,
              student_mode: true,
            };
            if (detectedWork && detectedWork.confidence === "high") {
              markTextPayload.titles = [{
                author: detectedWork.author,
                title: detectedWork.title,
                is_minor: detectedWork.isMinor
              }];
            }
            const response = await fetch(`${API_BASE}/mark_text`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${sessionData.session.access_token}`,
              },
              body: JSON.stringify(markTextPayload),
            });

            if (!response.ok) {
              const text = await response.text();
              throw new Error(`HTTP ${response.status}: ${text.substring(0, 100)}`);
            }

            const downloadBlob = await response.blob();
            const tempUrl = URL.createObjectURL(downloadBlob);
            const a = document.createElement("a");
            a.href = tempUrl;
            a.download = `${baseName}_marked.docx`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(tempUrl), 0);
          } catch (error) {
            console.error("Error generating download:", error);
            statusArea.textContent = `Error: ${error.message}`;
            statusArea.className = "status-area error";
            if (resultsCard) resultsCard.style.display = "block";
          } finally {
            stopButtonLoading(downloadBtn, () => true);
          }
        };

        // Render marked essay preview
        try {
          markedPreview.innerHTML = "";
          const buf = await blob.arrayBuffer();
          if (typeof docx !== "undefined" && docx.renderAsync) {
            await docx.renderAsync(buf, markedPreview, null, { inWrapper: true });
            removeRewritePracticeTagsFromPreview(markedPreview);
            // Make preview editable
            markedPreview.contentEditable = "true";
            markedPreview.spellcheck = true;
            markedPreview.classList.add("preview-editable");
            applyPreviewZoom();
            updateStatsPanel(liveLabelCounts);
            await refreshStudentMetrics();
            applyDismissalsToPreviewDOM();
            makePreviewLabelsClickable();
            markedPreviewCard.style.display = "block";
          } else {
            // Fallback: show message if docx-preview not loaded
            markedPreview.innerHTML = "<p>Preview not available. Please download the file to view.</p>";
            markedPreviewCard.style.display = "block";
            updateStatsPanel(liveLabelCounts);
            await refreshStudentMetrics();
          }
        } catch (previewError) {
          console.error("Error rendering preview:", previewError);
          markedPreview.innerHTML = "<p>Error rendering preview. Please download the file to view.</p>";
          markedPreviewCard.style.display = "block";
          updateStatsPanel(liveLabelCounts);
          await refreshStudentMetrics();
        }

        if (recheckDocumentBtn) {
          recheckDocumentBtn.disabled = false;
        }
        hideMarkButtonShowRecheck();

        hasStartedRevising = false;
        statusArea.textContent = "";
        statusArea.className = "status-area success";
        downloadBtn.style.display = "block";
        if (resultsCard) resultsCard.style.display = "block";
        
        // Load revision practice data
        await loadRevisionPractice();

        const totalIssues = totalIssuesFromLabelCounts(liveLabelCounts);
        if (totalIssues === 0) {
          statusArea.textContent = "Document appears to pass all of Vysti's rules. Ready to download.";
          if (mostCommonIssuesWrap) {
            mostCommonIssuesWrap.style.display = "none";
            mostCommonIssuesWrap.dataset.hasData = "false";
          }
          if (revisionPracticeCard) revisionPracticeCard.style.display = "none";
        }

        ensurePostPreviewTourVisibility();
        startPostPreviewTour();

      } catch (error) {
        console.error("Error:", error);
        statusArea.textContent = `Error: ${error.message}`;
        statusArea.className = "status-area error";
        if (resultsCard) resultsCard.style.display = "block";
      } finally {
        stopButtonLoading(checkBtn, () => !!selectedFile);
      }
    });

    // ===== Revision Practice =====
    // Handle section selection (set up once)
    sectionSelect.addEventListener("change", (e) => {
      const selectedSection = e.target.value;
      const sectionData = window.revisionSectionData;
      
      if (!sectionData) {
        return;
      }
      
      // Clear issue selection when section changes
      issueSelect.value = "";
      if (issueExplanationBlock) issueExplanationBlock.style.display = "none";
      examplesList.innerHTML = "";
      if (approvedRewritesList) approvedRewritesList.innerHTML = "";
      if (approvedRewritesWrap) approvedRewritesWrap.style.display = "none";
      downloadRevisionNotesBtn.style.display = "none";
      approvedRewriteByKey.clear();
      approvedExampleKeys.clear();
      updateApplyAllUI();
      
      // Repopulate issueSelect with labels in selected section
      issueSelect.innerHTML = '<option value="">Select an issue...</option>';
      
      let labelsToShow = [];
      if (!selectedSection || selectedSection === "") {
        // Show all labels
        labelsToShow = Object.keys(sectionData.labelCounts);
      } else {
        // Show labels in selected section
        labelsToShow = sectionData.sectionLabels[selectedSection] || [];
      }
      
      // Sort by count desc
      const sortedLabels = labelsToShow
        .map(label => ({
          label,
          count: sectionData.labelCounts[label] || 0
        }))
        .sort((a, b) => b.count - a.count)
        .map(item => item.label);
      
      sortedLabels.forEach(label => {
        const option = document.createElement("option");
        const issueId = getIssueIdForLabel(label);
        option.value = issueId;
        option.dataset.issueLabel = label;
        const count = sectionData.labelCounts[label] || 0;
        option.textContent = `${label} (${count})`;
        issueSelect.appendChild(option);
      });
    });

    function scrollToExamples() {
      if (!revisionPracticeCard) return;
      const header = revisionPracticeCard.querySelector(".revision-practice-title");
      if (!header) return;
      const topbar = document.querySelector(".topbar");
      const offset = (topbar ? topbar.getBoundingClientRect().height : 0) + 12;
      const y = header.getBoundingClientRect().top + window.scrollY - offset;
      window.scrollTo({ top: y, behavior: "smooth" });
    }

    function scrollToPreviewHeader() {
      const header = document.querySelector("#markedPreviewCard .preview-header");
      if (!header) return;
      const topbar = document.querySelector(".topbar");
      const offset = (topbar ? topbar.getBoundingClientRect().height : 0) + 12;
      const y = header.getBoundingClientRect().top + window.scrollY - offset;
      window.scrollTo({ top: y, behavior: "smooth" });
    }

    function extractLabelFromArrowText(text) {
      if (!text) return null;
      const m = String(text).trim().match(/^→\s*(.+?)\s*$/);
      if (!m) return null;
      const label = m[1].trim();
      if (!label) return null;
      return label;
    }

    function onPreviewLabelClick(e) {
      const target = e.target instanceof Element ? e.target : e.target.parentElement;
      if (!target) return;
      const sp = target.closest("span");
      if (!sp) return;

      const txt = (sp.textContent || "").trim();
      if (!/^→\s*/.test(txt)) return;

      const label = extractLabelFromArrowText(txt);
      if (!label) return;

      e.preventDefault();
      e.stopPropagation();
      const issueId = getIssueIdForLabel(label);
      void openRevisionExampleFromIssueId(issueId, label);
    }

    function makePreviewLabelsClickable() {
      if (!markedPreview) return;

      if (!markedPreview.dataset.vystiLabelClickBound) {
        markedPreview.addEventListener("click", onPreviewLabelClick, true);
        markedPreview.dataset.vystiLabelClickBound = "1";
      }

      const spans = Array.from(markedPreview.querySelectorAll("span"));
      spans.forEach((sp) => {
        const t = (sp.textContent || "").trim();
        if (!t.includes("→")) return;
        if (!/^→\s*/.test(t)) return;
        if (t.length > 140) return;
        sp.classList.add("vysti-clickable-label");
        sp.setAttribute("title", "Click to revise this issue");
      });
    }

    async function jumpToPreviewForTopicSentenceIssue() {
      if (!markedPreviewCard || markedPreviewCard.style.display === "none") return;
      if (!markedPreview || !markedPreview.innerText.trim()) return;

      const paras = Array.from(markedPreview.querySelectorAll("p"));
      const targetPara = paras.find((p) => (p.textContent || "").includes('"')) || paras[0];
      if (!targetPara) return;

      const txt = (targetPara.textContent || "").trim();
      if (!txt) return;
      const firstSentence = txt.match(/^(.+?[.!?])\s/)?.[1] || txt;

      clearPreviewHighlights();
      const spans =
        highlightExactTextInElement(targetPara, firstSentence) ||
        highlightAnchoredSentenceInElement(
          targetPara,
          firstSentence,
          buildAnchorCandidates(firstSentence)
        );

      if (Array.isArray(spans)) {
        spans.forEach((span) => span.classList.add("vysti-cursor-highlight"));
      }

      scrollToPreviewHeader();
    }

    async function openRevisionExampleFromIssueId(issueId, fallbackLabel = "") {
      const label = getLabelForIssueId(issueId) || fallbackLabel || "";
      if (!label) {
        console.warn("No examples loaded for issueId:", issueId);
        showExamplesEmptyState("No examples found for this issue yet.");
        updateAllApprovedBanner([]);
        return;
      }
      handlePowerVerbsIssueChange(label);
      if (revisionPracticeCard) revisionPracticeCard.style.display = "block";
      if (issueSelect && issueSelect.value !== issueId) {
        issueSelect.value = issueId;
      }
      updateIssueMetadataForLabel(label);
      if (isPreviewOnlyLabel(label)) {
        currentLabel = label;
        currentExamplesAll = [];
        currentIndex = 0;
        if (examplesList) {
          examplesList.innerHTML = "";
          examplesList.style.display = "none";
        }
        if (allApprovedBanner) {
          allApprovedBanner.style.display = "none";
        }
        if (examplesEmptyState) {
          examplesEmptyState.style.display = "block";
          examplesEmptyState.textContent = getPreviewOnlyMessage(label, "");
        }
        if (approvedRewritesList) approvedRewritesList.innerHTML = "";
        if (approvedRewritesWrap) approvedRewritesWrap.style.display = "none";
        if (downloadRevisionNotesBtn) downloadRevisionNotesBtn.style.display = "none";
        if (exampleNavRow) exampleNavRow.style.display = "none";
        if (applyAllToPreviewBtn) {
          applyAllToPreviewBtn.style.display = "none";
          applyAllToPreviewBtn.disabled = true;
          applyAllToPreviewBtn.classList.remove("apply-attention");
        }
        approvedRewrites.length = 0;
        approvedRewriteByKey.clear();
        approvedExampleKeys.clear();
        updateApplyAllUI();
        requestAnimationFrame(() => {
          void jumpToPreviewForTopicSentenceIssue();
        });
        return;
      }
      if (examplesList) examplesList.style.display = "";
      await loadIssueExamples(label);
      requestAnimationFrame(() => scrollToExamples());
    }
    
    // Handle issue selection (set up once)
    issueSelect.addEventListener("change", async (e) => {
      const selectedIssueId = e.target.value;
      const selectedOption = e.target.selectedOptions ? e.target.selectedOptions[0] : null;
      const selectedLabel = (selectedOption && selectedOption.dataset)
        ? selectedOption.dataset.issueLabel
        : getLabelForIssueId(selectedIssueId);
      handlePowerVerbsIssueChange(selectedLabel);
      if (!selectedIssueId) {
        if (issueExplanationBlock) issueExplanationBlock.style.display = "none";
        examplesList.innerHTML = "";
        if (allApprovedBanner) allApprovedBanner.style.display = "none";
        if (approvedRewritesList) approvedRewritesList.innerHTML = "";
        if (approvedRewritesWrap) approvedRewritesWrap.style.display = "none";
        approvedRewrites.length = 0;
        if (applyAllToPreviewBtn) {
          applyAllToPreviewBtn.style.display = "none";
          applyAllToPreviewBtn.disabled = true;
          applyAllToPreviewBtn.classList.remove("apply-attention");
        }
        approvedRewriteByKey.clear();
        approvedExampleKeys.clear();
        if (exampleNavRow) exampleNavRow.style.display = "none";
        currentLabel = null;
        currentExamplesAll = [];
        currentIndex = 0;
        currentGuidance = "";
        currentLabelText = "";
        downloadRevisionNotesBtn.style.display = "none";
        updateApplyAllUI();
        return;
      }

      await openRevisionExampleFromIssueId(selectedIssueId, selectedLabel || "");
    });

    if (applyAllToPreviewBtn) {
      applyAllToPreviewBtn.addEventListener("click", async () => {
        if (!approvedRewrites.length) return;
        const approvedItems = approvedRewrites.slice();
        for (const item of approvedItems) {
          const exampleKey = item.exampleKey || "";
          const rewriteText = item.rewriteText || "";
          const exampleData = item.examplePayload || exampleDataByKey.get(exampleKey) || null;
          applyRewriteToPreviewByKey({
            exampleKey,
            rewriteText,
            exampleData,
            statusDiv: null,
            applyBtn: null,
            exampleRow: null,
            scroll: false
          });
        }
        currentExamplesAll.forEach((ex) => {
          const key = getExampleKey(ex);
          if (key && appliedExampleKeys.has(key)) {
            setExampleAppliedState(key, true, currentLabel || "");
          }
        });
        renderCurrentExample();
        updateApplyAllUI();
        updateAllApprovedBanner(currentExamplesAll);
      });
    }

    if (nextExampleBtn) {
      nextExampleBtn.addEventListener("click", () => {
        const rotation = getRotationExamples();
        if (!rotation.length) return;
        currentIndex = (currentIndex + 1) % rotation.length;
        renderCurrentExample();
      });
    }

    let activeIssueBtn = null;

    function renderIssueButtonsFromSectionData(sectionData, sectionOrder) {
      if (!issueButtonsWrap) return;
      issueButtonsWrap.innerHTML = "";
      activeIssueBtn = null;

      if (!sectionData || !sectionData.sectionLabels || !sectionData.labelCounts) {
        return;
      }

      const labelCounts = sectionData.labelCounts || {};
      const sectionLabels = sectionData.sectionLabels || {};

      const order = Array.isArray(sectionOrder) && sectionOrder.length
        ? sectionOrder
        : Object.keys(sectionLabels);

      order.forEach((sectionName) => {
        const labels = (sectionLabels[sectionName] || []).slice();
        if (!labels.length) return;

        // Sort issues within the section by count desc
        labels.sort((a, b) => (labelCounts[b] || 0) - (labelCounts[a] || 0));

        const block = document.createElement("div");
        block.className = "issue-section-block";

        const heading = document.createElement("div");
        heading.className = "issue-section-heading";
        heading.textContent = sectionName;

        const row = document.createElement("div");
        row.className = "issue-button-row";

        labels.forEach((label) => {
          const count = labelCounts[label] || 0;
          if (count <= 0) return;
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "issue-btn";
          btn.classList.add("tt");
          btn.setAttribute("data-tip", "Click to see example");
          const issueId = getIssueIdForLabel(label);
          btn.dataset.issueId = issueId;
          btn.dataset.issueLabel = label;

          btn.textContent = `${label} (${count})`;
          const bucketId = getBucketIdForLabel(label);
          btn.dataset.bucketId = bucketId;
          btn.style.setProperty("--issue-border", getBucketColor(bucketId, 1.0));
          btn.style.setProperty("--issue-bg", getBucketColor(bucketId, 0.12));
          btn.style.setProperty("--issue-bg-hover", getBucketColor(bucketId, 0.18));
          btn.style.setProperty("--issue-ring", getBucketColor(bucketId, 0.22));

          btn.addEventListener("click", () => {
            // Active style
            if (activeIssueBtn) activeIssueBtn.classList.remove("active");
            activeIssueBtn = btn;
            activeIssueBtn.classList.add("active");

            // Ensure issueSelect contains ALL labels so any button can work
            if (sectionSelect) {
              sectionSelect.value = "";
              sectionSelect.dispatchEvent(new Event("change"));
            }

            // Trigger existing issueSelect flow (loads explanation + examples)
            if (issueSelect) {
              issueSelect.value = issueId;
              issueSelect.dispatchEvent(new Event("change"));
            }
          });

          row.appendChild(btn);
        });

        block.appendChild(heading);
        block.appendChild(row);
        issueButtonsWrap.appendChild(block);
      });

      auditRevisionIssueBindings({ source: "buttons" });
    }

    // Wrap text for tooltip display
    function wrapTooltipText(text, maxLineLen = 70) {
      const words = text.split(/\s+/).filter(Boolean);
      const lines = [];
      let line = "";
      for (const w of words) {
        const test = line ? line + " " + w : w;
        if (test.length > maxLineLen) {
          if (line) lines.push(line);
          line = w;
        } else {
          line = test;
        }
      }
      if (line) lines.push(line);
      return lines;
    }

    function firstSentence(text) {
      const t = String(text || "").replace(/\s+/g, " ").trim();
      if (!t) return "";
      const m = t.match(/^(.+?[.!?])(\s|$)/);
      if (m) return m[1].trim();
      return t.length > 180 ? t.slice(0, 177).trim() + "..." : t;
    }

    function positionMostCommonIssuesTooltip(chart, tooltip, tooltipEl) {
      const rect = chart.canvas.getBoundingClientRect();
      const offset = 12;
      const padding = 8;
      let left = rect.left + tooltip.caretX + offset;
      let top = rect.top + tooltip.caretY - offset - tooltipEl.offsetHeight;

      const maxLeft = window.innerWidth - tooltipEl.offsetWidth - padding;
      if (left > maxLeft) left = maxLeft;
      if (left < padding) left = padding;

      if (top < padding) {
        top = rect.top + tooltip.caretY + offset;
      }
      const maxTop = window.innerHeight - tooltipEl.offsetHeight - padding;
      if (top > maxTop) top = maxTop;

      tooltipEl.style.left = `${left}px`;
      tooltipEl.style.top = `${top}px`;
    }

    function getMostCommonIssuesTooltipEl() {
      let tooltipEl = document.getElementById("mostCommonIssuesTooltip");
      if (tooltipEl) return tooltipEl;

      tooltipEl = document.createElement("div");
      tooltipEl.id = "mostCommonIssuesTooltip";
      tooltipEl.className = "mci-tooltip tour-popover";
      tooltipEl.style.opacity = "0";
      tooltipEl.style.position = "fixed";
      tooltipEl.style.pointerEvents = "none";

      tooltipEl.innerHTML = `
        <div class="mci-tooltip-header">
          <div class="tour-title"></div>
        </div>
        <div class="tour-body mci-body">
          <div class="mci-count"></div>
          <div class="mci-explanation"></div>
        </div>
        <div class="mci-hint">Click the bar chart to revise</div>
      `;

      document.body.appendChild(tooltipEl);
      return tooltipEl;
    }

    function externalMostCommonIssuesTooltip(context) {
      const { chart, tooltip } = context;
      const tooltipEl = getMostCommonIssuesTooltipEl();

      if (!tooltip || tooltip.opacity === 0) {
        tooltipEl.style.opacity = "0";
        return;
      }

      const dataPoint = tooltip.dataPoints?.[0];
      if (!dataPoint) {
        tooltipEl.style.opacity = "0";
        return;
      }

      const titleEl = tooltipEl.querySelector(".tour-title");
      const countEl = tooltipEl.querySelector(".mci-count");
      const explanationEl = tooltipEl.querySelector(".mci-explanation");

      const label = dataPoint.label || "";
      const count = dataPoint.formattedValue || "0";
      const explanation = dataPoint.dataset?.explanations?.[dataPoint.dataIndex] || "";

      if (titleEl) titleEl.textContent = label;
      if (countEl) countEl.textContent = `Count: ${count}`;
      if (explanationEl) {
        explanationEl.textContent = explanation;
        explanationEl.style.display = explanation ? "block" : "none";
      }

      tooltipEl.style.opacity = "1";
      positionMostCommonIssuesTooltip(chart, tooltip, tooltipEl);
    }

    function applyDismissalsToLabelCounts(labelCounts) {
      const out = { ...(labelCounts || {}) };
      if (!selectedFile) return out;
      const countsToSubtract = {};
      dismissedIssues
        .filter((record) => record?.file_name === selectedFile.name)
        .forEach((record) => {
          const label = String(record?.label || "").trim();
          if (!label) return;
          countsToSubtract[label] = (countsToSubtract[label] || 0) + 1;
        });

      Object.entries(countsToSubtract).forEach(([label, sub]) => {
        const cur = Number(out[label] || 0);
        const next = Math.max(0, cur - sub);
        if (next === 0) delete out[label];
        else out[label] = next;
      });
      return out;
    }

    function filterDismissedExamples(label, examples) {
      return (examples || []).filter((ex) => {
        return !isDismissedIssueInstance(label || ex?.label || "", ex?.sentence || "");
      });
    }

    function renderMostCommonIssues(labelCounts) {
      if (!mostCommonIssuesWrap || !mostCommonIssuesChartEl) return;

      updateStatsPanel(labelCounts);

      const TOP_N = 30;
      const entries = Object.entries(labelCounts || {})
        .filter(([label, count]) => label && (count || 0) > 0)
        .sort((a, b) => (b[1] || 0) - (a[1] || 0))
        .slice(0, TOP_N);

      if (entries.length === 0) {
        mostCommonIssuesWrap.style.display = "none";
        mostCommonIssuesWrap.dataset.hasData = "false";
        const tooltipEl = document.getElementById("mostCommonIssuesTooltip");
        if (tooltipEl) tooltipEl.style.opacity = "0";
        if (mostCommonIssuesChart) {
          mostCommonIssuesChart.destroy();
          mostCommonIssuesChart = null;
        }
        return;
      }

      const labels = entries.map(([label]) => label);
      const issueIds = labels.map((lbl) => getIssueIdForLabel(lbl));
      const values = entries.map(([, count]) => count || 0);
      const bucketIds = labels.map((lbl) => getBucketIdForLabel(lbl));
      const barBg = bucketIds.map((id) => getBucketColor(id, 0.60));
      const barBorder = bucketIds.map((id) => getBucketColor(id, 1.0));
      const issues = currentMarkEvent?.issues || [];
      const shortExplanationByLabel = {};
      issues.forEach((iss) => {
        const lbl = String(iss?.label || "").trim();
        if (!lbl) return;
        const shortText = iss?.short_explanation
          ? String(iss.short_explanation)
          : firstSentence(iss?.explanation);
        if (shortText && !shortExplanationByLabel[lbl]) {
          shortExplanationByLabel[lbl] = shortText;
        }
      });
      const explanations = labels.map((lbl) => shortExplanationByLabel[lbl] || "");

      mostCommonIssuesWrap.style.display = "block";
      mostCommonIssuesWrap.dataset.hasData = "true";

      if (mostCommonIssuesChart) {
        mostCommonIssuesChart.destroy();
        mostCommonIssuesChart = null;
      }

      const viewport = mciScrollViewport;
      const inner = mciScrollInner;
      if (viewport && currentMarkEvent?.id != null) {
        const markId = String(currentMarkEvent.id);
        if (viewport.dataset.markEventId !== markId) {
          delete viewport.dataset.hasScrolled;
          viewport.dataset.markEventId = markId;
        }
      }
      const viewportWidth = viewport ? viewport.clientWidth : mostCommonIssuesWrap.clientWidth;
      const pxPerBar = 80;
      const canvasWidth = Math.max(viewportWidth, entries.length * pxPerBar);
      mostCommonIssuesChartEl.width = canvasWidth;
      mostCommonIssuesChartEl.style.width = `${canvasWidth}px`;
      mostCommonIssuesChartEl.style.height = "280px";
      if (inner) inner.style.width = `${canvasWidth}px`;

      const shouldResetScroll = viewport && !viewport.dataset.hasScrolled;
      if (viewport && shouldResetScroll) viewport.scrollLeft = 0;
      if (viewport) {
        viewport.addEventListener("scroll", () => {
          viewport.dataset.hasScrolled = "1";
        }, { once: true });
      }

      const ctx = mostCommonIssuesChartEl.getContext("2d");
      mostCommonIssuesChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [{
            data: values,
            backgroundColor: barBg,
            borderColor: barBorder,
            borderWidth: 1,
            explanations: explanations,
            issueIds: issueIds
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              enabled: false,
              external: externalMostCommonIssuesTooltip
            }
          },
          onHover: (event, elements, chart) => {
            const targetChart = chart || mostCommonIssuesChart;
            if (!targetChart?.canvas) return;
            targetChart.canvas.style.cursor = elements?.length ? "pointer" : "default";
          },
          onClick: (event, elements, chart) => {
            const targetChart = chart || mostCommonIssuesChart;
            if (!targetChart) return;
            const hits = targetChart.getElementsAtEventForMode(
              event,
              "nearest",
              { intersect: true },
              true
            );
            if (!hits.length) return;
            const idx = hits[0].index;
            const label = targetChart.data.labels?.[idx];
            const issueId = targetChart.data.datasets?.[0]?.issueIds?.[idx];
            void openRevisionExampleFromIssueId(issueId || "", label || "");
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: { precision: 0 }
            },
            x: {
              ticks: {
                autoSkip: true,
                maxRotation: 45,
                minRotation: 0,
                font: {
                  size: 14,
                  weight: "600"
                },
                callback: (value, idx) => {
                  const lbl = labels[idx] || "";
                  return lbl.length > 26 ? `${lbl.slice(0, 25)}…` : lbl;
                }
              }
            }
          }
        }
      });
      auditRevisionIssueBindings({ issueIds, labels, source: "chart" });
    }

    async function loadRevisionPractice() {
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session || !selectedFile) {
        return;
      }

      lastRevisionSectionData = null;

      try {
        // Get latest mark event for this user and file
        const { data: markEvents, error: markError } = await supa
          .from("mark_events")
          .select("id, label_counts, issues, created_at, file_name")
          .eq("user_id", sessionData.session.user.id)
          .eq("file_name", selectedFile.name)
          .order("created_at", { ascending: false })
          .limit(1);

        if (markError) {
          console.error("Error loading mark events:", markError);
          sectionSelect.innerHTML = '<option value="">All sections</option>';
          issueSelect.innerHTML = '<option value="">Examples will appear here after marking.</option>';
          renderIssueButtonsFromSectionData(null);
          return;
        }

        if (!markEvents || markEvents.length === 0) {
          sectionSelect.innerHTML = '<option value="">All sections</option>';
          issueSelect.innerHTML = '<option value="">Examples will appear here after marking.</option>';
          renderIssueButtonsFromSectionData(null);
          return;
        }

        currentMarkEvent = markEvents[0];
        const rawLabelCounts = { ...(currentMarkEvent.label_counts || {}) };
        const filteredLabelCounts = applyDismissalsToLabelCounts(rawLabelCounts);
        liveLabelCounts = { ...filteredLabelCounts };
        const labelCounts = liveLabelCounts;
        syncIssueIdMaps(currentMarkEvent?.issues || [], labelCounts);
        
        if (resultsCard) resultsCard.style.display = "block";
        try {
          renderMostCommonIssues(liveLabelCounts);
        } catch (chartError) {
          console.warn("Most common issues chart failed to render:", chartError);
        }
        if (statsPanel) {
          statsPanel.style.display = "block";
          updateStatsPanel(liveLabelCounts);
        }
        
        // Build section index by querying issue_examples
        let examplesQuery = supa
          .from("issue_examples")
          .select("label, paragraph_index")
          .eq("user_id", sessionData.session.user.id)
          .eq("file_name", selectedFile.name);
        
        // Filter by mark_event_id if available
        if (currentMarkEvent.id) {
          examplesQuery = examplesQuery.eq("mark_event_id", currentMarkEvent.id);
        }
        
        const { data: examplesData, error: examplesError } = await examplesQuery;
        
        if (examplesError) {
          console.warn("Error loading examples for section index:", examplesError);
        }
        
        // Determine intro_idx_est and conclusion_idx_est from paragraph_index values
        const paraIndices = (examplesData || [])
          .map(ex => ex.paragraph_index)
          .filter(idx => idx != null && typeof idx === 'number');
        
        const intro_idx_est = paraIndices.length > 0 ? Math.min(...paraIndices) : 0;
        const conclusion_idx_est = paraIndices.length > 0 ? Math.max(...paraIndices) : 0;
        
        // Build label-to-section mapping
        // For each label, find its dominant paragraph_index (most frequent)
        const labelParaCounts = {};
        (examplesData || []).forEach(ex => {
          const label = String(ex.label || "").trim();
          const paraIdx = ex.paragraph_index;
          if (!label || paraIdx == null) return;
          
          if (!labelParaCounts[label]) {
            labelParaCounts[label] = {};
          }
          labelParaCounts[label][paraIdx] = (labelParaCounts[label][paraIdx] || 0) + 1;
        });
        
        // Determine section for each label
        const labelToSection = {};
        const sectionLabels = {
          "Title and Introduction": [],
          "Conclusion": [],
        };
        const bodySections = {}; // "Nth Body Paragraph" -> [labels]
        
        Object.keys(labelCounts).forEach(label => {
          const labelLower = label.toLowerCase();
          const paraCounts = labelParaCounts[label] || {};
          
          // Find dominant paragraph_index
          let dominantParaIdx = null;
          let maxCount = 0;
          Object.entries(paraCounts).forEach(([paraIdx, count]) => {
            if (count > maxCount) {
              maxCount = count;
              dominantParaIdx = parseInt(paraIdx, 10);
            }
          });
          
          // Bucket into section
          let section = null;
          if (dominantParaIdx === intro_idx_est || 
              labelLower.includes("title") || 
              labelLower.includes("thesis") || 
              labelLower.includes("first sentence") || 
              labelLower.includes("introduction")) {
            section = "Title and Introduction";
            sectionLabels["Title and Introduction"].push(label);
          } else if (dominantParaIdx === conclusion_idx_est || 
                     labelLower.includes("conclusion")) {
            section = "Conclusion";
            sectionLabels["Conclusion"].push(label);
          } else if (dominantParaIdx != null) {
            const bodyNum = dominantParaIdx - intro_idx_est;
            const sectionName = formatBodySectionName(bodyNum);
            section = sectionName;
            if (!bodySections[sectionName]) {
              bodySections[sectionName] = [];
            }
            bodySections[sectionName].push(label);
          } else {
            // Fallback: put in Title and Introduction if we can't determine
            section = "Title and Introduction";
            sectionLabels["Title and Introduction"].push(label);
          }
          
          labelToSection[label] = section;
        });
        
        // Merge body sections into sectionLabels
        Object.keys(bodySections).forEach(sectionName => {
          sectionLabels[sectionName] = bodySections[sectionName];
        });
        
        // Store section data for filtering
        window.revisionSectionData = {
          labelToSection,
          sectionLabels,
          labelCounts
        };
        lastRevisionSectionData = window.revisionSectionData;
        
        // Populate sectionSelect (only include sections with at least one label)
        sectionSelect.innerHTML = '<option value="">All sections</option>';
        // Sort body sections numerically (Body paragraph 1, 2, 10, not 1, 10, 2)
        const bodySectionNames = Object.keys(bodySections).sort((a, b) => {
          const numA = parseInt(a.match(/\d+/)?.[0] || "0", 10);
          const numB = parseInt(b.match(/\d+/)?.[0] || "0", 10);
          return numA - numB;
        });
        const sectionOrder = ["Title and Introduction", ...bodySectionNames, "Conclusion"];
        window.revisionSectionData.sectionOrder = sectionOrder;
        renderIssueButtonsFromSectionData(window.revisionSectionData, sectionOrder);
        sectionOrder.forEach(sectionName => {
          if (sectionLabels[sectionName] && sectionLabels[sectionName].length > 0) {
            const option = document.createElement("option");
            option.value = sectionName;
            option.textContent = sectionName;
            sectionSelect.appendChild(option);
          }
        });
        
        // Populate issueSelect with all labels (sorted by count desc)
        const sortedLabels = Object.entries(labelCounts)
          .sort((a, b) => (b[1] || 0) - (a[1] || 0))
          .map(([label]) => String(label || "").trim())
          .filter(Boolean);
        
        issueSelect.innerHTML = '<option value="">Select an issue...</option>';
        sortedLabels.forEach(label => {
          const option = document.createElement("option");
          const issueId = getIssueIdForLabel(label);
          option.value = issueId;
          option.dataset.issueLabel = label;
          const count = labelCounts[label] || 0;
          option.textContent = `${label} (${count})`;
          issueSelect.appendChild(option);
        });

      } catch (error) {
        console.error("Error loading revision practice:", error);
        sectionSelect.innerHTML = '<option value="">All sections</option>';
        issueSelect.innerHTML = '<option value="">Examples will appear here after marking.</option>';
        renderIssueButtonsFromSectionData(null);
      }
    }

    async function loadIssueExamples(label) {
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session || !selectedFile) {
        return;
      }

      try {
        if (examplesList) examplesList.innerHTML = "";
        if (examplesList) examplesList.style.display = "";
        if (approvedRewritesList) approvedRewritesList.innerHTML = "";
        if (approvedRewritesWrap) approvedRewritesWrap.style.display = "none";
        approvedRewrites.length = 0;
        if (applyAllToPreviewBtn) {
          applyAllToPreviewBtn.style.display = "none";
          applyAllToPreviewBtn.disabled = true;
          applyAllToPreviewBtn.classList.remove("apply-attention");
        }
        approvedRewriteByKey.clear();
        approvedExampleKeys.clear();

        // Get explanation from issues array
        const issueData = updateIssueMetadataForLabel(label);

        // Get examples from issue_examples
        // Fetch 50 rows to allow deduplication while still getting 10 unique examples
        // Filter by mark_event_id if available (prevents stale examples after recheck)
        let examples = null;
        let error = null;
        
        if (currentMarkEvent && currentMarkEvent.id) {
          // Try filtered query with mark_event_id
          const { data, error: err } = await supa
            .from("issue_examples")
            .select("label, sentence, paragraph_index, created_at")
            .eq("user_id", sessionData.session.user.id)
            .eq("file_name", selectedFile.name)
            .eq("label", label)
            .eq("mark_event_id", currentMarkEvent.id)
            .order("created_at", { ascending: false })
            .limit(50);
          
          if (err) {
            // If mark_event_id column doesn't exist (older DB), fallback to old query
            console.warn("mark_event_id filter failed, falling back to old query:", err);
            const { data: fallbackData, error: fallbackError } = await supa
              .from("issue_examples")
              .select("label, sentence, paragraph_index, created_at")
              .eq("user_id", sessionData.session.user.id)
              .eq("file_name", selectedFile.name)
              .eq("label", label)
              .order("created_at", { ascending: false })
              .limit(50);
            examples = fallbackData;
            error = fallbackError;
          } else {
            examples = data;
          }
        } else {
          // No mark_event_id available, use old query
          const { data: fallbackData, error: fallbackError } = await supa
            .from("issue_examples")
            .select("label, sentence, paragraph_index, created_at")
            .eq("user_id", sessionData.session.user.id)
            .eq("file_name", selectedFile.name)
            .eq("label", label)
            .order("created_at", { ascending: false })
            .limit(50);
          examples = fallbackData;
          error = fallbackError;
        }

        if (error) {
          console.error("Error loading examples:", error);
          hideExamplesEmptyState();
          updateAllApprovedBanner([]);
          examplesList.innerHTML = "<li>Error loading examples.</li>";
          if (exampleNavRow) exampleNavRow.style.display = "none";
          currentExamplesAll = [];
          currentIndex = 0;
          return;
        }

        // Sort: first by created_at desc (latest run first), then by paragraph_index asc (doc order)
        const sortedExamples = (examples || []).sort((a, b) => {
          // First, sort by created_at descending (latest first)
          const timeA = new Date(a.created_at || 0).getTime();
          const timeB = new Date(b.created_at || 0).getTime();
          if (timeA !== timeB) {
            return timeB - timeA; // Descending
          }
          // If created_at is the same (same mark event), sort by paragraph_index ascending
          const paraA = a.paragraph_index ?? 999999;
          const paraB = b.paragraph_index ?? 999999;
          return paraA - paraB;
        });

        // Deduplicate examples by paragraph + sentence, and skip applied examples
        const uniq = [];
        const seenSent = new Set();
        for (const ex of sortedExamples) {
          const s = String(ex?.sentence || "").trim();
          if (!s) continue;
          const paraIndex = ex?.paragraph_index ?? "";
          const key = getExampleKeyFromParts(paraIndex ?? 0, s);
          if (loadAppliedFlag(label, key)) {
            appliedExampleKeys.add(key);
          }
          if (appliedExampleKeys.has(key)) continue;
          if (seenSent.has(key)) continue;
          seenSent.add(key);
          if (typeof ex.applied_to_preview !== "boolean") {
            ex.applied_to_preview = false;
          }
          uniq.push(ex);
          if (uniq.length >= 10) break; // Cap at 10 examples
        }
        const filteredUniq = filterDismissedExamples(label, uniq);
        const labelChanged = currentLabel !== label;
        currentLabel = label;
        currentExamplesAll = filteredUniq;
        const issueId = getIssueIdForLabel(label);
        examplesByIssueId.set(issueId, filteredUniq || []);
        if (labelChanged) currentIndex = 0;

        currentExamplesAll.forEach((ex) => {
          const key = getExampleKey(ex);
          if (key && !exampleDataByKey.has(key)) {
            exampleDataByKey.set(key, ex);
          }
        });

        if (!filteredUniq || filteredUniq.length === 0) {
          if (issueId) {
            console.warn("No examples loaded for issueId:", issueId);
          }
          const hadAnyExamples = Array.isArray(examples) && examples.length > 0;
          const hadDismissals = uniq && uniq.length > 0;
          const emptyMessage = !hadAnyExamples
            ? "No examples found for this issue yet."
            : hadDismissals
              ? "All examples for this issue have been dismissed. Click another bar to revise a different issue."
              : getPreviewOnlyMessage(
                  label,
                  "No more examples for this issue. Click another bar to practice a different issue."
                );
          showExamplesEmptyState(emptyMessage);
          updateAllApprovedBanner([]);
          if (exampleNavRow) exampleNavRow.style.display = "none";
          downloadRevisionNotesBtn.style.display = "none";
          updateApplyAllUI();
          return;
        }

        hideExamplesEmptyState();
        updateAllApprovedBanner(currentExamplesAll);
        renderCurrentExample();

        downloadRevisionNotesBtn.style.display = "block";
        downloadRevisionNotesBtn.onclick = () => {
          downloadRevisionNotes(label, currentExamplesAll);
        };

      } catch (error) {
        console.error("Error loading issue examples:", error);
        hideExamplesEmptyState();
        examplesList.innerHTML = "<li>Error loading examples.</li>";
        if (exampleNavRow) exampleNavRow.style.display = "none";
        currentExamplesAll = [];
        currentIndex = 0;
      }
    }

    async function loadRandomIssueForTraining() {
      let candidates = [];
      const chartIssueIds = mostCommonIssuesChart?.data?.datasets?.[0]?.issueIds;
      if (Array.isArray(chartIssueIds) && chartIssueIds.length) {
        candidates = chartIssueIds.slice();
      } else if (lastRevisionSectionData?.labelCounts) {
        candidates = Object.entries(lastRevisionSectionData.labelCounts)
          .filter(([lbl, ct]) => lbl && (ct || 0) > 0)
          .sort((a, b) => (b[1] || 0) - (a[1] || 0))
          .slice(0, 8)
          .map(([lbl]) => getIssueIdForLabel(lbl));
      }
      if (!candidates.length) return null;

      const issueId = candidates[Math.floor(Math.random() * candidates.length)];
      const label = getLabelForIssueId(issueId) || "";

      if (sectionSelect) {
        sectionSelect.value = "";
        sectionSelect.dispatchEvent(new Event("change"));
      }
      if (issueSelect) {
        issueSelect.value = issueId;
      }

      await openRevisionExampleFromIssueId(issueId, label);

      const btn = issueButtonsWrap?.querySelector(
        `.issue-btn[data-issue-id="${CSS.escape(issueId)}"]`
      );
      if (btn) {
        if (activeIssueBtn) activeIssueBtn.classList.remove("active");
        activeIssueBtn = btn;
        activeIssueBtn.classList.add("active");
      }

      return issueId;
    }

    // ===== Preview highlighting helpers =====
    function getPreviewBlocks() {
      if (!markedPreview) return [];
      
      // Prefer: markedPreview.querySelectorAll(".docx p, .docx li, p, li")
      let blocks = Array.from(markedPreview.querySelectorAll(".docx p, .docx li, p, li"));
      
      // Filter out empty innerText
      blocks = blocks.filter(block => (block.innerText || "").trim().length > 0);
      
      // If none found, fallback to markedPreview.querySelectorAll("p, li, div") filtered
      if (blocks.length === 0) {
        blocks = Array.from(markedPreview.querySelectorAll("p, li, div"));
        blocks = blocks.filter(block => (block.innerText || "").trim().length > 0);
      }
      
      return blocks;
    }

    function normalizeForMatch(text) {
      return (text || "")
        .replace(/[\u201C\u201D\u201E\u201F]/g, '"')  // curly quotes to straight
        .replace(/[\u2018\u2019\u201A\u201B]/g, "'")  // curly quotes to straight
        .replace(/[\u2013\u2014]/g, "-")  // en dash and em dash to hyphen
        .replace(/\u00AD/g, "")  // remove soft hyphens
        .replace(/\u00A0/g, " ")  // non-breaking spaces to normal spaces
        .replace(/[\u200B-\u200D\uFEFF]/g, "")  // remove zero-width chars
        .replace(/\s+/g, " ")  // collapse whitespace
        .trim();
    }

    function unwrapNode(el) {
      const parent = el.parentNode;
      if (!parent) return;
      while (el.firstChild) {
        parent.insertBefore(el.firstChild, el);
      }
      parent.removeChild(el);
      parent.normalize();
    }

    function clearPreviewHighlights() {
      // Unwrap any highlight spans
      const highlightedSpans = markedPreview.querySelectorAll("span.vysti-preview-hit[data-vysti-hit='1']");
      highlightedSpans.forEach(unwrapNode);
      
      // Remove classes from any elements
      const highlighted = markedPreview.querySelectorAll(".vysti-preview-hit, .vysti-preview-hit-block");
      highlighted.forEach(el => {
        el.classList.remove("vysti-preview-hit", "vysti-preview-hit-block");
      });
    }

    function normalizeCharForMatch(ch) {
      // Convert curly quotes to straight
      if (ch === '\u201C' || ch === '\u201D' || ch === '\u201E' || ch === '\u201F') return '"';
      if (ch === '\u2018' || ch === '\u2019' || ch === '\u201A' || ch === '\u201B') return "'";
      // Convert en dash and em dash to hyphen
      if (ch === '\u2013' || ch === '\u2014') return '-';
      // Convert NBSP to space
      if (ch === '\u00A0') return ' ';
      // Strip soft hyphen and zero-width chars
      if (ch === '\u00AD' || (ch >= '\u200B' && ch <= '\u200D') || ch === '\uFEFF') return '';
      // Treat any whitespace as space
      if (/\s/.test(ch)) return ' ';
      return ch;
    }

    // Helper: Check if a text node is a Vysti label run (starts with "→")
    function isVystiLabelTextNode(node) {
      if (node.nodeType !== Node.TEXT_NODE) return false;
      
      // Check if the node's textContent (trimmed) starts with "→"
      const text = (node.textContent || "").trim();
      if (text.startsWith("→")) return true;
      
      // Also check the closest SPAN's textContent (handles cases where docx-preview splits arrow + label across nodes)
      let current = node.parentElement;
      while (current && current.tagName !== "SPAN") {
        current = current.parentElement;
      }
      if (current && current.tagName === "SPAN") {
        const spanText = (current.textContent || "").trim();
        if (spanText.startsWith("→")) return true;
      }
      
      return false;
    }

    // Helper: Check if a text node is any Vysti artifact (arrow labels or rewrite-practice tags)
    function isVystiArtifactTextNode(node) {
      if (node.nodeType !== Node.TEXT_NODE) return false;
      
      // Check for arrow labels using existing helper
      if (isVystiLabelTextNode(node)) return true;
      
      // Check for rewrite-practice tag
      const text = (node.textContent || "").trim();
      // Match the exact phrase from marker.py: " * Rewrite this paragraph for practice  *"
      // Also handle case-insensitive and variations in whitespace
      const rewritePattern = /^\s*\*\s*Rewrite this paragraph for practice\s*\*\s*$/i;
      if (rewritePattern.test(text)) return true;
      
      // Also check the closest SPAN's textContent (handles cases where docx-preview splits text across nodes)
      let current = node.parentElement;
      while (current && current.tagName !== "SPAN") {
        current = current.parentElement;
      }
      if (current && current.tagName === "SPAN") {
        const spanText = (current.textContent || "").trim();
        if (rewritePattern.test(spanText)) return true;
      }
      
      return false;
    }

    function removeRewritePracticeTagsFromPreview(rootEl) {
      if (!rootEl) return;
      const rewritePattern = /\s*\*\s*Rewrite this paragraph for practice\s*\*\s*/i;
      const replacePattern = new RegExp(rewritePattern.source, "gi");
      const walker = document.createTreeWalker(
        rootEl,
        NodeFilter.SHOW_TEXT,
        null
      );
      const matchedNodes = [];
      let node;
      while ((node = walker.nextNode())) {
        if (rewritePattern.test(node.textContent || "")) {
          matchedNodes.push(node);
        }
      }
      matchedNodes.forEach((textNode) => {
        const original = textNode.textContent || "";
        const cleaned = original.replace(replacePattern, "").trim();
        if (cleaned) {
          textNode.textContent = cleaned;
        } else {
          const parent = textNode.parentNode;
          textNode.remove();
          if (parent && parent.childNodes.length === 0) {
            parent.remove();
          }
        }
      });
      rootEl.normalize();
    }

    // Helper: Extract clean text from an element, excluding Vysti artifacts
    function extractCleanTextFromElement(el) {
      if (!el) return "";
      
      const walker = document.createTreeWalker(
        el,
        NodeFilter.SHOW_TEXT,
        null
      );
      
      const textParts = [];
      let node;
      
      while ((node = walker.nextNode())) {
        // Skip Vysti artifacts (arrow labels and rewrite-practice tags)
        if (isVystiArtifactTextNode(node)) continue;
        
        const text = node.textContent || "";
        if (text.trim()) {
          textParts.push(text);
        }
      }
      
      // Concatenate all text parts
      let combined = textParts.join("");
      
      // Normalize whitespace:
      // - Convert NBSP to space
      combined = combined.replace(/\u00A0/g, " ");
      // - Collapse multiple whitespace to single spaces
      combined = combined.replace(/\s+/g, " ");
      // - Trim
      combined = combined.trim();
      
      return combined;
    }

    function buildNormalizedTextMap(rootEl) {
      const walker = document.createTreeWalker(rootEl, NodeFilter.SHOW_TEXT, null);
      const posMap = [];
      let normText = "";
      let lastWasSpace = false;

      let node;
      while ((node = walker.nextNode())) {
        // Skip Vysti label runs (text starting with "→")
        if (isVystiLabelTextNode(node)) continue;
        
        const t = node.textContent || "";
        for (let i = 0; i < t.length; i++) {
          let ch = normalizeCharForMatch(t[i]);
          if (ch === "") continue;

          if (ch === " ") {
            if (normText.length === 0 || lastWasSpace) continue;
            lastWasSpace = true;
          } else {
            lastWasSpace = false;
          }

          normText += ch;
          posMap.push({ node, offset: i });
        }
      }

      return { normText, posMap };
    }

    // Helper: Wrap a substring of a single Text node by splitting it
    function wrapTextNodeSubstring(node, startOffset, endOffsetInclusive) {
      if (node.nodeType !== Node.TEXT_NODE) return null;
      
      const text = node.textContent || "";
      const endOffsetExclusive = endOffsetInclusive + 1;
      
      // Split at endOffsetExclusive if needed
      if (endOffsetExclusive < text.length) {
        const afterNode = node.splitText(endOffsetExclusive);
        // afterNode is now the node after the split
      }
      
      // Split at startOffset if needed (now node might have been shortened)
      let targetNode = node;
      if (startOffset > 0) {
        targetNode = node.splitText(startOffset);
      }
      
      // Now targetNode contains the substring we want to wrap
      const span = document.createElement("span");
      span.className = "vysti-preview-hit";
      span.setAttribute("data-vysti-hit", "1");
      
      // Wrap the targetNode
      const parent = targetNode.parentNode;
      if (parent) {
        parent.insertBefore(span, targetNode);
        span.appendChild(targetNode);
      }
      
      return span;
    }

    // Multi-span wrapper that handles ranges across multiple text nodes
    function wrapMappedRangeMulti(posMap, startIdx, endIdx) {
      if (startIdx < 0 || endIdx < startIdx || endIdx >= posMap.length) {
        return null;
      }
      
      // Build segments by grouping consecutive entries with the same node
      const segments = [];
      let currentSegment = null;
      
      for (let i = startIdx; i <= endIdx; i++) {
        const pos = posMap[i];
        if (!pos || !pos.node) continue;
        
        if (!currentSegment || currentSegment.node !== pos.node) {
          // Start new segment
          if (currentSegment) {
            segments.push(currentSegment);
          }
          currentSegment = {
            node: pos.node,
            startOffset: pos.offset,
            endOffset: pos.offset
          };
        } else {
          // Extend current segment
          currentSegment.endOffset = pos.offset;
        }
      }
      
      if (currentSegment) {
        segments.push(currentSegment);
      }
      
      if (segments.length === 0) return null;
      
      // Group segments by node, then process each node's segments in reverse offset order
      // This ensures that when we split a node, earlier offsets in the same node are still valid
      const nodeToSegments = new Map();
      for (const seg of segments) {
        if (!nodeToSegments.has(seg.node)) {
          nodeToSegments.set(seg.node, []);
        }
        nodeToSegments.get(seg.node).push(seg);
      }
      
      const createdSpans = [];
      
      // Process each node's segments separately, in reverse offset order
      for (const [originalNode, nodeSegments] of nodeToSegments) {
        // Sort by endOffset descending (process highest offsets first)
        nodeSegments.sort((a, b) => b.endOffset - a.endOffset);
        
        for (const seg of nodeSegments) {
          // Use the original node reference - wrapTextNodeSubstring handles splitting
          const span = wrapTextNodeSubstring(seg.node, seg.startOffset, seg.endOffset);
          if (span) {
            createdSpans.push(span);
          }
        }
      }
      
      // Sort spans by DOM order
      createdSpans.sort((a, b) => {
        const pos = a.compareDocumentPosition(b);
        if (pos & Node.DOCUMENT_POSITION_FOLLOWING) return -1;
        if (pos & Node.DOCUMENT_POSITION_PRECEDING) return 1;
        return 0;
      });
      
      return createdSpans.length > 0 ? createdSpans : null;
    }

    function highlightExactTextInElement(rootEl, targetSentence) {
      const target = normalizeForMatch(targetSentence);
      if (!target) return null;

      const { normText, posMap } = buildNormalizedTextMap(rootEl);

      const start = normText.indexOf(target);
      if (start === -1) return null;

      const end = start + target.length - 1;
      return wrapMappedRangeMulti(posMap, start, end);
    }

    function buildAnchorCandidates(target) {
      const lens = [80, 60, 45, 35, 25, 18];
      const prefixes = [];
      const suffixes = [];

      for (const L of lens) {
        let p = target.substring(0, Math.min(L, target.length));
        const cut = p.lastIndexOf(" ");
        if (cut > 12) p = p.substring(0, cut);
        if (p.length >= 12 && !prefixes.includes(p)) prefixes.push(p);
      }

      for (const L of lens) {
        let s = target.substring(Math.max(0, target.length - L));
        const cut = s.indexOf(" ");
        if (cut !== -1 && (s.length - (cut + 1)) >= 12) s = s.substring(cut + 1);
        if (s.length >= 12 && !suffixes.includes(s)) suffixes.push(s);
      }

      return { prefixes, suffixes };
    }

    function highlightAnchoredSentenceInElement(rootEl, sentence) {
      const target = normalizeForMatch(sentence);
      if (!target) return null;

      const { normText, posMap } = buildNormalizedTextMap(rootEl);
      const { prefixes, suffixes } = buildAnchorCandidates(target);

      // Prevent "highlight half the paragraph" accidents
      const maxAllowed = Math.max(220, target.length * 3 + 120);

      for (const prefix of prefixes) {
        const start = normText.indexOf(prefix);
        if (start === -1) continue;

        for (const suffix of suffixes) {
          const endStart = normText.indexOf(suffix, start + prefix.length);
          if (endStart === -1) continue;

          const end = endStart + suffix.length - 1;
          const spanLen = end - start + 1;

          if (spanLen <= 0 || spanLen > maxAllowed) continue;

          const spans = wrapMappedRangeMulti(posMap, start, end);
          if (spans && spans.length > 0) return spans;
        }
      }

      return null;
    }

    function scoreBlockMatch(sentence, blockText) {
      const normSentence = normalizeForMatch(sentence);
      const normBlock = normalizeForMatch(blockText);

      if (!normSentence || !normBlock) return 0.0;

      // Perfect match if the normalized block contains the full normalized sentence.
      if (normBlock.includes(normSentence)) return 1.0;

      // Token scoring fallback:
      // - Prefer longer tokens to avoid false positives.
      // - But if the sentence is short (or gets split by injected "→ ..."), relax token length.
      const tokenize = (minLen) =>
        normSentence
          .replace(/[^\w\s]/g, " ")
          .split(/\s+/)
          .filter((t) => t.length >= minLen);

      let tokens = tokenize(4);
      if (tokens.length === 0) tokens = tokenize(3);
      if (tokens.length === 0) tokens = tokenize(2);

      if (tokens.length === 0) return 0.0;

      const blockLower = normBlock.toLowerCase();
      let hits = 0;
      for (const token of tokens) {
        if (blockLower.includes(token.toLowerCase())) hits++;
      }

      return hits / tokens.length;
    }

    function findBestPreviewBlockForExample(example) {
      const blocks = getPreviewBlocks();
      if (blocks.length === 0) return null;

      const sentence = (example?.sentence || "").trim();
      const paraIndex = example?.paragraph_index;

      // If there's no usable sentence text, fall back deterministically.
      if (!sentence) {
        if (typeof paraIndex === "number") {
          const idx = Math.max(0, Math.min(blocks.length - 1, paraIndex));
          return blocks[idx] || blocks[0] || null;
        }
        return blocks[0] || null;
      }

      // 1) Global best (search all blocks). This protects us when paragraph_index is offset
      // by title/name/spacing blocks at the top of docx-preview.
      let globalBest = blocks[0];
      let globalBestScore = -1;

      for (let i = 0; i < blocks.length; i++) {
        const score = scoreBlockMatch(sentence, blocks[i].innerText || "");
        if (score > globalBestScore) {
          globalBestScore = score;
          globalBest = blocks[i];
          if (score === 1.0) break; // can't beat perfect
        }
      }

      // If paragraph_index is missing, just use the global best.
      if (typeof paraIndex !== "number") {
        return globalBest;
      }

      // 2) Local window best (prefer local when it's confident, but widen near top of document)
      const candidates = [];
      const bases = [paraIndex, paraIndex - 1, paraIndex + 1];

      for (const base of bases) {
        if (typeof base !== "number") continue;

        const backward = 4;

        // Near the top, docx-preview often adds extra blocks (title/name/blank lines),
        // so we search farther forward to avoid missing the true first body paragraph.
        const forward = base <= 2 ? 12 : 4;

        const start = Math.max(0, base - backward);
        const end = Math.min(blocks.length - 1, base + forward);

        for (let i = start; i <= end; i++) {
          const score = scoreBlockMatch(sentence, blocks[i].innerText || "");
          candidates.push({ block: blocks[i], score, index: i });
          if (score === 1.0) return blocks[i];
        }
      }

      candidates.sort((a, b) => b.score - a.score);
      const bestLocal = candidates[0];

      // If local is good, use it.
      if (bestLocal && bestLocal.score >= 0.3) {
        return bestLocal.block;
      }

      // Otherwise, if global is decent, use it (THIS fixes first-sentence problems).
      if (globalBestScore >= 0.3) {
        return globalBest;
      }

      // Last resort: old deterministic fallback.
      const fallbackIdx = Math.max(0, Math.min(blocks.length - 1, paraIndex));
      const fallbackIdx2 = Math.max(0, Math.min(blocks.length - 1, paraIndex - 1));
      return blocks[fallbackIdx] || blocks[fallbackIdx2] || globalBest || null;
    }

    function highlightAndScrollToExample(example, statusDivOptional, options = {}) {
      clearPreviewHighlights();
      
      const sentence = example?.sentence || "";
      const blockEl = findBestPreviewBlockForExample(example);
      
      if (!blockEl) {
        if (statusDivOptional) {
          statusDivOptional.textContent = "Couldn't locate it in the preview automatically. Use Copy + paste manually.";
        }
        return { ok: false, hits: [], blockEl: null, used: "none" };
      }
      
      let hits = highlightExactTextInElement(blockEl, sentence);
      let used = "exact";

      // NEW: if exact fails, try anchored match (handles injected "→ ..." text inside the sentence)
      if (!hits || hits.length === 0) {
        hits = highlightAnchoredSentenceInElement(blockEl, sentence);
        used = "anchor";
      }

      if (hits && hits.length > 0) {
        const first = hits[0];
        const last = hits[hits.length - 1];

        if (options.scroll !== false) {
          // Scroll to first span
          first.scrollIntoView({ behavior: "smooth", block: "center" });

          // Create selection range that selects the full sentence
          try {
            // Find first text node in first span
            let firstTextNode = first.firstChild;
            while (firstTextNode && firstTextNode.nodeType !== Node.TEXT_NODE) {
              firstTextNode = firstTextNode.firstChild;
            }
            
            // Find first text node in last span
            let lastTextNode = last.firstChild;
            while (lastTextNode && lastTextNode.nodeType !== Node.TEXT_NODE) {
              lastTextNode = lastTextNode.firstChild;
            }
            
            if (firstTextNode && lastTextNode) {
              const range = document.createRange();
              range.setStart(firstTextNode, 0);
              range.setEnd(lastTextNode, lastTextNode.textContent.length);
              
              const sel = window.getSelection();
              sel.removeAllRanges();
              sel.addRange(range);
            }
          } catch (e) {
            // Fallback: select all spans
            try {
              const range = document.createRange();
              range.setStartBefore(first);
              range.setEndAfter(last);
              const sel = window.getSelection();
              sel.removeAllRanges();
              sel.addRange(range);
            } catch (e2) {}
          }

          if (markedPreview) markedPreview.focus();
        }

        if (statusDivOptional) {
          statusDivOptional.textContent = "Highlighted the sentence in the preview. Paste your rewrite to replace it.";
        }
        return { ok: true, hits: hits, blockEl: blockEl, used: used };
      }

      // Only now do paragraph fallback
      console.debug("[FindPreview fallback]", {
        label: example?.label,
        paragraph_index: example?.paragraph_index,
        sentence: example?.sentence,
        normSentence: normalizeForMatch(example?.sentence || "").slice(0, 200),
        normBlock: normalizeForMatch(blockEl?.innerText || "").slice(0, 200),
      });
      blockEl.classList.add("vysti-preview-hit-block");
      blockEl.scrollIntoView({ behavior: "smooth", block: "center" });
      if (markedPreview) markedPreview.focus();
      if (statusDivOptional) {
        statusDivOptional.textContent = "Found the paragraph, but couldn't isolate the exact sentence. You can still paste manually.";
      }
      return { ok: true, hits: [], blockEl: blockEl, used: "paragraph" };
    }

    function cursorHighlightExampleInPreview(example) {
      if (!markedPreview) return;
      clearPreviewHighlights();

      const sentence = example?.sentence || "";
      const paragraphEl = findBestPreviewBlockForExample(example);
      if (!paragraphEl) return;

      let hits = highlightExactTextInElement(paragraphEl, sentence);
      if (!hits || hits.length === 0) {
        hits = highlightAnchoredSentenceInElement(
          paragraphEl,
          sentence,
          buildAnchorCandidates(sentence)
        );
      }

      if (hits && hits.length > 0) {
        hits.forEach((span) => span.classList.add("vysti-cursor-highlight"));
      }
    }

    function brandedConfirm({ title, body, okText = "Remove", cancelText = "Cancel" } = {}) {
      const overlay = document.getElementById("brandConfirmOverlay");
      const titleEl = document.getElementById("brandConfirmTitle");
      const bodyEl = document.getElementById("brandConfirmBody");
      const okBtn = document.getElementById("brandConfirmOk");
      const cancelBtn = document.getElementById("brandConfirmCancel");
      const closeBtn = overlay?.querySelector(".brand-confirm-close");

      if (!overlay || !titleEl || !bodyEl || !okBtn || !cancelBtn || !closeBtn) {
        return Promise.resolve(window.confirm(body || "Are you sure?"));
      }

      return new Promise((resolve) => {
        let resolved = false;

        const cleanup = () => {
          overlay.hidden = true;
          document.removeEventListener("keydown", onKeyDown);
          overlay.removeEventListener("click", onOverlayClick);
          okBtn.removeEventListener("click", onOk);
          cancelBtn.removeEventListener("click", onCancel);
          closeBtn.removeEventListener("click", onCancel);
        };

        const finish = (result) => {
          if (resolved) return;
          resolved = true;
          cleanup();
          resolve(result);
        };

        const onOk = () => finish(true);
        const onCancel = () => finish(false);
        const onOverlayClick = (event) => {
          if (event.target === overlay) {
            finish(false);
          }
        };
        const onKeyDown = (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            finish(false);
          }
        };

        titleEl.textContent = title || "Confirm";
        bodyEl.textContent = body || "";
        okBtn.textContent = okText || "Remove";
        cancelBtn.textContent = cancelText || "Cancel";

        overlay.hidden = false;
        okBtn.focus();

        document.addEventListener("keydown", onKeyDown);
        overlay.addEventListener("click", onOverlayClick);
        okBtn.addEventListener("click", onOk);
        cancelBtn.addEventListener("click", onCancel);
        closeBtn.addEventListener("click", onCancel);
      });
    }

    function removeIssueLabelAndHighlight(label, example, options = {}) {
      const {
        statusDiv = null,
        actionBtn = null,
        scroll = true,
        allowParagraphFallback = false,
        silent = false
      } = options;

      if (markedPreviewCard.style.display === "none" || !markedPreview || !markedPreview.innerText.trim()) {
        if (!silent && statusDiv) {
          statusDiv.textContent = "Click \"Mark my essay\" to load the preview first.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return { ok: false };
      }

      const result = highlightAndScrollToExample(example, null, { scroll });
      if (!result.ok || !result.blockEl) {
        if (!silent && statusDiv) {
          statusDiv.textContent = "Couldn't locate the sentence in the preview.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return { ok: false };
      }

      if (!allowParagraphFallback && (!result.hits || result.hits.length === 0)) {
        if (!silent && statusDiv) {
          statusDiv.textContent = "Couldn't isolate the exact sentence in preview. Try Find in preview first.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return { ok: false };
      }

      const blockEl = result.blockEl;
      const labelText = `→ ${label}`;
      const normalizeWhitespace = (text) => (text || "").replace(/\s+/g, " ").trim();
      const arrowCandidates = Array.from(blockEl.querySelectorAll("span, a"))
        .filter(el => {
          const text = normalizeWhitespace(el.textContent);
          return text.startsWith("→") && text.includes(label);
        });

      if (arrowCandidates.length === 0) {
        if (!silent && statusDiv) {
          statusDiv.textContent = "Couldn't find the issue label in the preview.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return { ok: false };
      }

      let selectedLabelEl = arrowCandidates[0];
      if (result.hits && result.hits.length > 0) {
        try {
          const range = document.createRange();
          range.setStartBefore(result.hits[0]);
          range.setEndAfter(result.hits[result.hits.length - 1]);
          const intersecting = arrowCandidates.find(el => range.intersectsNode(el));
          if (intersecting) {
            selectedLabelEl = intersecting;
          } else {
            const firstHitRect = result.hits[0].getBoundingClientRect();
            let closest = arrowCandidates[0];
            let closestDist = Number.POSITIVE_INFINITY;
            arrowCandidates.forEach(el => {
              const rect = el.getBoundingClientRect();
              const dist = Math.abs(rect.top - firstHitRect.top);
              if (dist < closestDist) {
                closest = el;
                closestDist = dist;
              }
            });
            selectedLabelEl = closest;
          }
        } catch (e) {
          selectedLabelEl = arrowCandidates[0];
        }
      }

      let removalTarget = selectedLabelEl;
      if (selectedLabelEl.parentElement && selectedLabelEl.parentElement.tagName === "SPAN") {
        const parentText = normalizeWhitespace(selectedLabelEl.parentElement.textContent);
        const childText = normalizeWhitespace(selectedLabelEl.textContent);
        if (parentText === childText) {
          removalTarget = selectedLabelEl.parentElement;
        }
      }

      if (normalizeWhitespace(removalTarget.textContent) !== normalizeWhitespace(labelText)) {
        // Still remove the best label match to avoid leaving the arrow label behind.
      }

      const hasInlineHighlight = (el) => {
        if (!el || el.nodeType !== Node.ELEMENT_NODE) return false;
        if (el.style && (el.style.backgroundColor || el.style.background)) return true;
        return !!el.querySelector("*[style*='background']");
      };

      const clearInlineHighlight = (el) => {
        if (!el || el.nodeType !== Node.ELEMENT_NODE) return;
        if (el.style) {
          el.style.backgroundColor = "";
          el.style.background = "";
        }
        el.querySelectorAll("*").forEach(child => {
          if (child.style) {
            child.style.backgroundColor = "";
            child.style.background = "";
          }
        });
      };

      let sibling = removalTarget.previousSibling;
      while (sibling) {
        if (sibling.nodeType !== Node.ELEMENT_NODE) break;
        const el = sibling;
        if (!hasInlineHighlight(el)) break;
        clearInlineHighlight(el);
        sibling = sibling.previousSibling;
      }

      removalTarget.remove();

      clearPreviewHighlights();
      if (markedPreview) markedPreview.normalize();

      if (!silent && statusDiv) {
        statusDiv.textContent = "Dismissed from preview. (This will stay dismissed after Recheck.)";
        statusDiv.className = "rewrite-status visible ok";
      }
      if (actionBtn) actionBtn.disabled = true;

      const exampleRow = actionBtn?.closest(".example-item");
      if (exampleRow) {
        exampleRow.classList.add("example-dismissed");
      }

      return { ok: true, blockEl: result.blockEl };
    }

    async function removeIssueFromPreview(label, example, statusDiv, removeBtn) {
      if (markedPreviewCard.style.display === "none" || !markedPreview || !markedPreview.innerText.trim()) {
        statusDiv.textContent = "Click \"Mark my essay\" to load the preview first.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      const ok = await brandedConfirm({
        title: "Remove from preview?",
        body: "Remove this issue label + highlight from the preview?"
      });
      if (!ok) {
        return;
      }
      removeIssueLabelAndHighlight(label, example, {
        statusDiv,
        actionBtn: removeBtn,
        scroll: true,
        allowParagraphFallback: false,
        silent: false
      });
    }

    function applyDismissalsToPreviewDOM() {
      if (!selectedFile || !markedPreview || !markedPreview.innerText.trim()) return;
      const records = dismissedIssues.filter((record) => record?.file_name === selectedFile.name);
      if (!records.length) return;
      records.forEach((record) => {
        removeIssueLabelAndHighlight(record?.label || "", {
          label: record?.label || "",
          sentence: record?.sentence || "",
          paragraph_index: record?.paragraph_index ?? null
        }, {
          scroll: false,
          allowParagraphFallback: true,
          silent: true
        });
      });
    }

    async function openDismissIssueModal() {
      if (!dismissIssueOverlay || !dismissConfirmBtn || !dismissCancelBtn) {
        return { confirmed: false, reason: null, other_text: null };
      }

      const reasonInputs = Array.from(
        dismissIssueOverlay.querySelectorAll('input[name="dismissReason"]')
      );

      return new Promise((resolve) => {
        let resolved = false;

        const cleanup = () => {
          dismissIssueOverlay.classList.add("hidden");
          document.removeEventListener("keydown", onKeyDown);
          dismissIssueOverlay.removeEventListener("click", onOverlayClick);
          dismissCancelBtn.removeEventListener("click", onCancel);
          dismissConfirmBtn.removeEventListener("click", onConfirm);
          reasonInputs.forEach((input) => input.removeEventListener("change", onReasonChange));
          if (dismissOtherText) {
            dismissOtherText.removeEventListener("input", onOtherInput);
          }
        };

        const finish = (confirmed, reason = null, otherText = null) => {
          if (resolved) return;
          resolved = true;
          cleanup();
          resolve({ confirmed, reason, other_text: otherText });
        };

        const getSelectedReason = () => {
          const checked = reasonInputs.find((input) => input.checked);
          return checked ? checked.value : "";
        };

        const setError = (message) => {
          if (!dismissError) return;
          if (!message) {
            dismissError.textContent = "";
            dismissError.classList.add("hidden");
            return;
          }
          dismissError.textContent = message;
          dismissError.classList.remove("hidden");
        };

        const updateOtherUI = (reason) => {
          const isOther = reason === "other";
          if (dismissOtherText) {
            dismissOtherText.classList.toggle("hidden", !isOther);
            if (isOther) dismissOtherText.focus();
          }
          if (dismissCharCount) {
            dismissCharCount.classList.toggle("hidden", !isOther);
          }
        };

        const updateCharCount = () => {
          if (!dismissOtherText || !dismissCharCount) return;
          const len = (dismissOtherText.value || "").length;
          dismissCharCount.textContent = `${len}/280`;
        };

        const updateConfirmState = () => {
          const reason = getSelectedReason();
          const isOther = reason === "other";
          const otherText = dismissOtherText ? dismissOtherText.value.trim() : "";
          const valid = reason && (!isOther || otherText.length > 0);
          dismissConfirmBtn.disabled = !valid;
        };

        const onReasonChange = () => {
          const reason = getSelectedReason();
          updateOtherUI(reason);
          updateCharCount();
          setError("");
          updateConfirmState();
        };

        const onOtherInput = () => {
          updateCharCount();
          updateConfirmState();
        };

        const onCancel = () => finish(false, null, null);

        const onConfirm = () => {
          const reason = getSelectedReason();
          if (!reason) {
            setError("Please select a reason to continue.");
            return;
          }
          const isOther = reason === "other";
          const otherText = dismissOtherText ? dismissOtherText.value.trim() : "";
          if (isOther && !otherText) {
            setError("Please add a brief explanation for “Other.”");
            return;
          }
          setError("");
          finish(true, reason, isOther ? otherText : null);
        };

        const onOverlayClick = (event) => {
          if (event.target === dismissIssueOverlay) {
            finish(false, null, null);
          }
        };

        const onKeyDown = (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            finish(false, null, null);
          }
        };

        // Reset state
        reasonInputs.forEach((input) => (input.checked = false));
        if (dismissOtherText) dismissOtherText.value = "";
        updateOtherUI("");
        updateCharCount();
        setError("");
        dismissConfirmBtn.disabled = true;

        dismissIssueOverlay.classList.remove("hidden");
        dismissCancelBtn.focus();

        document.addEventListener("keydown", onKeyDown);
        dismissIssueOverlay.addEventListener("click", onOverlayClick);
        dismissCancelBtn.addEventListener("click", onCancel);
        dismissConfirmBtn.addEventListener("click", onConfirm);
        reasonInputs.forEach((input) => input.addEventListener("change", onReasonChange));
        if (dismissOtherText) {
          dismissOtherText.addEventListener("input", onOtherInput);
        }
      });
    }

    async function dismissIssue(label, example, statusDiv, btn) {
      const modalResult = await openDismissIssueModal();
      if (!modalResult.confirmed) return;

      const fileName = selectedFile?.name || "nofile";
      const record = {
        label: label || "",
        sentence: example?.sentence || "",
        paragraph_index: example?.paragraph_index ?? null,
        file_name: fileName,
        created_at: new Date().toISOString(),
        reason: modalResult.reason,
        other_text: modalResult.other_text || null
      };

      dismissedIssues.push(record);
      saveDismissedIssuesToStorage();

      try {
        const { data: sessionData } = await supa.auth.getSession();
        const userId = sessionData?.session?.user?.id;
        if (userId) {
          const currentMode = modeSelect ? modeSelect.value : "textual_analysis";
          const { error } = await supa
            .from("dismissed_issue_feedback")
            .insert({
              user_id: userId,
              file_name: fileName,
              mark_event_id: currentMarkEvent?.id || null,
              mode: currentMode,
              issue_label: label || "",
              paragraph_index: record.paragraph_index,
              sentence: record.sentence,
              reason: modalResult.reason,
              other_text: modalResult.other_text || null
            });
          if (error) {
            console.warn("Dismissed issue feedback insert failed:", error);
          }
        }
      } catch (error) {
        console.warn("Dismissed issue feedback insert failed:", error);
      }

      removeIssueLabelAndHighlight(label, example, {
        statusDiv,
        actionBtn: btn,
        scroll: true,
        allowParagraphFallback: true,
        silent: false
      });

      const rawCounts = currentMarkEvent?.label_counts || liveLabelCounts || {};
      liveLabelCounts = { ...applyDismissalsToLabelCounts(rawCounts) };
      refreshIssueCountUI();
      renderMostCommonIssues(liveLabelCounts);

      currentExamplesAll = filterDismissedExamples(currentLabel || label, currentExamplesAll);
      if (!currentExamplesAll.length) {
        showExamplesEmptyState(
          "All examples for this issue have been dismissed. Click another bar to revise a different issue."
        );
        updateAllApprovedBanner([]);
        if (exampleNavRow) exampleNavRow.style.display = "none";
        downloadRevisionNotesBtn.style.display = "none";
        updateApplyAllUI();
        return;
      }

      renderCurrentExample();
    }

    function normalizeWhitespaceAndQuotes(value) {
      if (!value) return "";
      const straightened = value
        .replace(/[\u2018\u2019]/g, "'")
        .replace(/[\u201C\u201D]/g, "\"");
      return straightened.replace(/\s+/g, " ").trim();
    }

    function normalizeLabelForPayload(value) {
      if (!value) return "";
      return value.replace(/\s+/g, " ").trim();
    }

    async function checkRewrite(label, example, textarea, statusDiv, checkBtn) {
      const rewrite = textarea.value.trim();
      if (!rewrite) {
        statusDiv.textContent = "Please enter a rewrite first.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      const contextText = extractPreviewText();
      if (!contextText || !contextText.trim()) {
        statusDiv.textContent = "Load the Preview first (click 'Mark my essay') before checking rewrites.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      const originalSentence = example?.sentence || "";
      if (originalSentence) {
        const normalizedRewrite = normalizeWhitespaceAndQuotes(rewrite);
        const normalizedOriginal = normalizeWhitespaceAndQuotes(originalSentence);
        if (normalizedRewrite && normalizedRewrite === normalizedOriginal) {
          statusDiv.textContent = "No changes detected — edit the example before checking.";
          statusDiv.className = "rewrite-status visible bad";
          return;
        }
      }

      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        statusDiv.textContent = "You must be logged in.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      statusDiv.textContent = "Checking";
      statusDiv.className = "rewrite-status visible checking";
      statusDiv.classList.remove("ok", "bad");
      if (checkBtn) {
        checkBtn.disabled = true;
      }

      try {
        const API_BASE = "https://vysti-rules.onrender.com";
        const currentMode = modeSelect ? modeSelect.value : "textual_analysis";
        const response = await fetch(`${API_BASE}/revision/check`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${sessionData.session.access_token}`,
          },
          body: JSON.stringify({
            label: label,
          label_trimmed: normalizeLabelForPayload(label),
            rewrite: rewrite,
            mode: currentMode,
            context_text: contextText,
            original_sentence: originalSentence || null,
            paragraph_index: example?.paragraph_index ?? null,
          }),
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(`HTTP ${response.status}: ${text.substring(0, 100)}`);
        }

        const result = await response.json();
        const ok = !!result.approved;
        const exampleRow = statusDiv.closest(".example-item");
        const exampleKey = getExampleKey(example);

        if (ok) {
          if (exampleRow && exampleRow.dataset.movingApproved === "1") return;
          if (exampleRow) exampleRow.dataset.movingApproved = "1";
          statusDiv.className = "rewrite-status visible ok";
          statusDiv.textContent = "Approved!";

          setTimeout(() => {
            if (exampleKey) {
              approvedRewriteByKey.set(exampleKey, rewrite);
              approvedExampleKeys.add(exampleKey);
              setExampleApprovalState(exampleKey, true);
              draftRewriteByKey.set(exampleKey, rewrite);
              if (!exampleDataByKey.has(exampleKey)) {
                exampleDataByKey.set(exampleKey, example);
              }
              upsertApprovedRewrite({
                label: label || example?.label || "",
                exampleKey,
                originalSentence: example?.sentence || "",
                rewriteText: rewrite,
                examplePayload: example
              });
            }
            if (exampleRow) {
              exampleRow.classList.add("example-approved");
              exampleRow.dataset.approvedRewrite = rewrite;
              if (exampleKey) exampleRow.dataset.exampleKey = exampleKey;
              const applyBtn = exampleRow.querySelector(".apply-to-preview-btn");
              if (applyBtn) {
                applyBtn.disabled = false;
                setApplyAttention(applyBtn);
              }
            }
            renderApprovedRewritesList();
            renderCurrentExample();
            if (exampleRow) delete exampleRow.dataset.movingApproved;
          }, 600);
          return;
        }

        statusDiv.textContent = result.message || "Looks like we still have an issue.";
        statusDiv.className = "rewrite-status visible bad";

        if (exampleKey && exampleRow && approvedExampleKeys.has(exampleKey)) {
          const applyBtn = exampleRow.querySelector(".apply-to-preview-btn");
          revokeApprovedRewrite({
            exampleKey,
            exampleRow,
            applyBtn,
            statusDiv
          });
        }
      } catch (error) {
        console.error("Error checking rewrite:", error);
        statusDiv.textContent = `Error: ${error.message}`;
        statusDiv.className = "rewrite-status visible bad";
      } finally {
        statusDiv.classList.remove("checking");
        if (checkBtn) {
          checkBtn.disabled = false;
        }
      }
    }

    function applyRewriteToPreviewByKey({
      exampleKey,
      rewriteText,
      exampleData,
      statusDiv,
      applyBtn,
      exampleRow,
      scroll = true
    }) {
      if (applyBtn) clearApplyAttention(applyBtn);
      // Ensure preview exists
      if (markedPreviewCard.style.display === "none" || !markedPreview || !markedPreview.innerText.trim()) {
        if (statusDiv) {
          statusDiv.textContent = "Click \"Mark my essay\" to load the preview first.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return false;
      }
      hasStartedRevising = true;

      const resolvedExampleData = exampleData || exampleRow?._exampleData || exampleDataByKey.get(exampleKey);
      const resolvedKey = exampleKey || getExampleKey(resolvedExampleData);
      const resolvedRewrite = rewriteText || approvedRewriteByKey.get(resolvedKey);

      if (!resolvedRewrite) {
        if (statusDiv) {
          statusDiv.textContent = "Please check and approve your rewrite first.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return false;
      }

      if (!resolvedExampleData) {
        if (statusDiv) {
          statusDiv.textContent = "Unable to locate the original example for preview replacement.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return false;
      }

      const label = exampleRow?.dataset?.label || resolvedExampleData?.label || currentLabel || "";

      // Find the sentence in preview
      clearPreviewHighlights();
      const result = highlightAndScrollToExample(resolvedExampleData, null, { scroll });
      
      if (!result.ok || result.hits.length === 0) {
        if (statusDiv) {
          statusDiv.textContent = "Couldn't isolate the exact sentence in preview — please paste manually.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return false;
      }

      // Replace the matched range with the approved rewrite
      try {
        const first = result.hits[0];
        const last = result.hits[result.hits.length - 1];
        const range = document.createRange();
        range.setStartBefore(first);
        range.setEndAfter(last);
        range.deleteContents();

        // Insert rewrite as a styled span so it doesn't inherit UI fonts
        const rewriteSpan = document.createElement("span");
        rewriteSpan.className = "vysti-applied-rewrite";
        rewriteSpan.textContent = resolvedRewrite;

        range.insertNode(rewriteSpan);
        rewriteSpan.classList.add("vysti-flash-highlight");
        setTimeout(() => rewriteSpan.classList.remove("vysti-flash-highlight"), 1200);

        // Move caret after inserted rewrite (nice UX, avoids weird selection states)
        range.setStartAfter(rewriteSpan);
        range.collapse(true);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);

        // Normalize to merge any split text nodes after DOM surgery
        if (markedPreview) markedPreview.normalize();
        
        // Clear any leftover highlight styling
        clearPreviewHighlights();
        
        // Update UI
        if (statusDiv) {
          statusDiv.textContent = "Applied";
          statusDiv.className = "rewrite-status visible ok";
        }
        if (applyBtn) applyBtn.disabled = true;
        
        // Mark example as applied
        if (exampleRow) {
          exampleRow.classList.add("example-applied");
          exampleRow.dataset.applied = "true";
        }

        if (resolvedKey) {
          appliedExampleKeys.add(resolvedKey);
          setExampleAppliedState(resolvedKey, true, label);
        }
        if (resolvedKey) {
          removeApprovedRewriteByKey(resolvedKey);
          renderApprovedRewritesList();
        }
        if (label) {
          liveLabelCounts[label] = Math.max(0, (liveLabelCounts[label] || 0) - 1);
          if (!liveLabelCounts[label]) {
            delete liveLabelCounts[label];
          }
        }
        renderMostCommonIssues(liveLabelCounts);
        refreshIssueCountUI();
        updateApplyAllUI();
        updateAllApprovedBanner(currentExamplesAll);
        
        // Show recheck button if hidden
        hideMarkButtonShowRecheck();
        return true;
      } catch (error) {
        console.error("Error applying rewrite:", error);
        if (statusDiv) {
          statusDiv.textContent = "Error applying rewrite. Please paste manually.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return false;
      }
    }

    function downloadRevisionNotes(label, examples) {
      let content = `Revision Notes: ${label}\n\n`;
      
      examples.forEach((ex, idx) => {
        content += `Example ${idx + 1}:\n`;
        content += `Original: ${ex.sentence || ""}\n`;
        const key = getExampleKey(ex);
        const rewrite = approvedRewriteByKey.get(key) || draftRewriteByKey.get(key) || "";
        if (rewrite) {
          content += `Your rewrite: ${rewrite}\n`;
        }
        content += `\n`;
      });
      
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `revision_notes_${label.replace(/\s+/g, "_")}.txt`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Recheck document button handler
    if (recheckDocumentBtn) {
      recheckDocumentBtn.addEventListener("click", async () => {
        resetRevisionPracticeUI();
        if (!selectedFile || !markedPreview) {
          return;
        }
        hasStartedRevising = true;

        // Extract current preview text in a paragraph-preserving way
        const previewText = extractPreviewText();
        if (!previewText) {
          statusArea.textContent = "Could not extract text from preview.";
          statusArea.className = "status-area error";
          if (resultsCard) resultsCard.style.display = "block";
          return;
        }

        // Get session
        const { data: sessionData } = await supa.auth.getSession();
        if (!sessionData || !sessionData.session) {
          statusArea.textContent = "You must be logged in.";
          statusArea.className = "status-area error";
          if (resultsCard) resultsCard.style.display = "block";
          return;
        }

        // Update UI
        statusArea.textContent = "Rechecking document...";
        statusArea.className = "status-area";
        startButtonLoading(recheckDocumentBtn, "Recheck my essay");

        try {
          const API_BASE = "https://vysti-rules.onrender.com";
          const currentMode = modeSelect ? modeSelect.value : "textual_analysis";
          const markTextPayload = {
            file_name: selectedFile.name,
            text: previewText,
            mode: currentMode,
            highlight_thesis_devices: false,
            student_mode: true,
          };
          if (detectedWork && detectedWork.confidence === "high") {
            markTextPayload.titles = [{
              author: detectedWork.author,
              title: detectedWork.title,
              is_minor: detectedWork.isMinor
            }];
          }
          const response = await fetch(`${API_BASE}/mark_text`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${sessionData.session.access_token}`,
            },
            body: JSON.stringify(markTextPayload),
          });

          if (!response.ok) {
            const text = await response.text();
            throw new Error(`HTTP ${response.status}: ${text.substring(0, 100)}`);
          }

          const techHeader = response.headers.get("X-Vysti-Techniques");
          if (techHeader) {
            try {
              const parsed = JSON.parse(techHeader);
              currentTechniques = Array.isArray(parsed) ? parsed : [];
            } catch (err) {
              console.warn("Failed to parse techniques header:", err);
              currentTechniques = [];
            }
          } else {
            currentTechniques = [];
          }

          const blob = await response.blob();
          markedBlob = blob;
          downloadUrl = URL.createObjectURL(blob);

          // Replace the preview with the returned docx blob
          markedPreview.innerHTML = "";
          const buf = await blob.arrayBuffer();
          if (typeof docx !== "undefined" && docx.renderAsync) {
            await docx.renderAsync(buf, markedPreview, null, { inWrapper: true });
            removeRewritePracticeTagsFromPreview(markedPreview);
            markedPreview.contentEditable = "true";
            markedPreview.spellcheck = true;
            markedPreview.classList.add("preview-editable");
            applyPreviewZoom();
            updateStatsPanel(liveLabelCounts);
            await refreshStudentMetrics();
            applyDismissalsToPreviewDOM();
            makePreviewLabelsClickable();
          } else {
            markedPreview.innerHTML = "<p>Preview not available. Please download the file to view.</p>";
            updateStatsPanel(liveLabelCounts);
            await refreshStudentMetrics();
          }

          // Reload revision practice to refresh issues + examples
          await loadRevisionPractice();

          const totalIssues = totalIssuesFromLabelCounts(liveLabelCounts);
          if (totalIssues === 0) {
            statusArea.textContent = "Document appears to pass all of Vysti's rules. Ready to download.";
            if (mostCommonIssuesWrap) {
              mostCommonIssuesWrap.style.display = "none";
              mostCommonIssuesWrap.dataset.hasData = "false";
            }
            if (revisionPracticeCard) revisionPracticeCard.style.display = "none";
          } else {
            statusArea.textContent = "Document rechecked. Preview updated.";
          }
          statusArea.className = "status-area success";
          ensurePostPreviewTourVisibility();
          startPostPreviewTour();
        } catch (error) {
          console.error("Error rechecking document:", error);
          statusArea.textContent = `Error: ${error.message}`;
          statusArea.className = "status-area error";
        } finally {
          stopButtonLoading(
            recheckDocumentBtn,
            () => !!selectedFile
          );
        }
      });
    }

    function extractPreviewText() {
      if (!markedPreview) return null;
      
      // Collect all <p> and <li> in preview container and join with \n\n
      const paragraphs = [];
      const elements = markedPreview.querySelectorAll("p, li");
      
      for (const el of elements) {
        if (el.closest("table") || el.closest(".docx-table")) continue;
        // Use clean extraction that excludes Vysti artifacts
        const text = extractCleanTextFromElement(el);
        if (!text) continue;
        const trimmed = text.trim();
        if (
          trimmed === "Issue" ||
          trimmed === "Explanation" ||
          trimmed === "Issue Explanation"
        ) {
          continue;
        }
        paragraphs.push(text);
      }
      
      // If no paragraphs found, try getting all text (also clean)
      if (paragraphs.length === 0) {
        const allText = extractCleanTextFromElement(markedPreview);
        if (allText) {
          return allText;
        }
        return null;
      }
      
      return paragraphs.join("\n\n");
    }

    // =========================
    // Student tour controller
    // =========================

    const preUploadTourSteps = [
      {
        anchor: "#mode",
        title: "Assignment type",
        body: "Choose the assignment type so Vysti applies the right rules.",
      },
      {
        anchor: "#assignmentName",
        title: "Assignment Tracker",
        body: "Name and number your draft to track progress.",
      },
      {
        anchor: "#dropZone",
        title: "Upload",
        body: "Upload your .docx file here.",
      },
    ];

    const postUploadTourSteps = [
      {
        anchor: "#checkBtn",
        title: "Mark my essay",
        body: "Click here to generate a preview and revise your work.",
      },
    ];

    const postPreviewTourSteps = [
      {
        anchor: "#downloadBtn",
        title: "Download",
        body: "You can download your marked essay now or revise it first.",
      },
      {
        anchor: "#mostCommonIssuesWrap",
        title: "Most Common Issues",
        body: "Hover to see an explanation. Click a bar to jump to an example.",
      },
      {
        anchor: "#markedPreviewCard",
        title: "Preview",
        body: "Edit your document directly in this Preview. Use Zoom if you need it. Changes here aren’t finalized until you recheck.",
      },
      {
        anchor: "#recheckDocumentBtn",
        title: "Recheck",
        body: "After editing the Preview, click here to regenerate your feedback. Edits can fix issues — but can also create new ones.",
      },
      {
        anchor: "#examplesList",
        title: "Practice a revision",
        body: "Follow Vysti's guidance to repair your work, then click 'Check rewrite'. If it's approved , click ‘Apply to Preview’ to update your document.",
      },
    ];

    let activeTourSteps = preUploadTourSteps;

    const tourState = {
      currentStepIndex: 0,
      active: false,
    };

    let tourOverlay = null;
    let tourPopover = null;
    let tourTitle = null;
    let tourBody = null;
    let tourStep = null;
    let tourNextBtn = null;
    let tourCloseBtn = null;
    let tourHideCheckbox = null;
    let tourArrow = null;
    let tourPositionHandler = null;

    function createTourElements() {
      if (tourPopover) return;

      tourOverlay = document.createElement("div");
      tourOverlay.className = "tour-overlay";

      tourPopover = document.createElement("div");
      tourPopover.className = "tour-popover";
      tourPopover.setAttribute("role", "dialog");
      tourPopover.setAttribute("aria-live", "polite");

      tourCloseBtn = document.createElement("button");
      tourCloseBtn.className = "tour-close";
      tourCloseBtn.type = "button";
      tourCloseBtn.setAttribute("aria-label", "Close tour");
      tourCloseBtn.textContent = "×";

      tourArrow = document.createElement("div");
      tourArrow.className = "tour-arrow";

      tourTitle = document.createElement("div");
      tourTitle.className = "tour-title";

      tourBody = document.createElement("div");
      tourBody.className = "tour-body";

      const footer = document.createElement("div");
      footer.className = "tour-footer";

      tourStep = document.createElement("div");
      tourStep.className = "tour-step";

      const checkboxLabel = document.createElement("label");
      checkboxLabel.className = "tour-checkbox-row";
      tourHideCheckbox = document.createElement("input");
      tourHideCheckbox.type = "checkbox";
      tourHideCheckbox.id = "tourHideCheckbox";
      checkboxLabel.appendChild(tourHideCheckbox);
      checkboxLabel.appendChild(document.createTextNode(" Do not show again"));

      tourNextBtn = document.createElement("button");
      tourNextBtn.className = "tour-primary-btn";
      tourNextBtn.type = "button";
      tourNextBtn.textContent = "Got it";

      footer.appendChild(tourStep);
      footer.appendChild(checkboxLabel);
      footer.appendChild(tourNextBtn);

      tourPopover.appendChild(tourCloseBtn);
      tourPopover.appendChild(tourArrow);
      tourPopover.appendChild(tourTitle);
      tourPopover.appendChild(tourBody);
      tourPopover.appendChild(footer);

      document.body.appendChild(tourOverlay);
      document.body.appendChild(tourPopover);

      tourNextBtn.addEventListener("click", nextStep);
      tourCloseBtn.addEventListener("click", () => closeTour("dismissed"));
      tourHideCheckbox.addEventListener("change", () => {
        if (tourHideCheckbox.checked) {
          closeTour("hide");
        }
      });
    }

    function getCurrentAnchor() {
      const step = activeTourSteps[tourState.currentStepIndex];
      if (!step) return null;
      return document.querySelector(step.anchor);
    }

    function clearTourHighlight() {
      const highlighted = document.querySelector(".tour-highlight");
      if (highlighted) highlighted.classList.remove("tour-highlight");
    }

    function positionTourPopover(anchorEl) {
      if (!tourPopover || !anchorEl) return;

      const gap = 12;
      const padding = 12;
      const rect = anchorEl.getBoundingClientRect();

      tourPopover.style.display = "block";
      tourPopover.style.visibility = "hidden";

      const popRect = tourPopover.getBoundingClientRect();
      const fitsBelow = rect.bottom + gap + popRect.height <= window.innerHeight;

      let top = fitsBelow ? rect.bottom + gap : rect.top - popRect.height - gap;
      top = Math.max(padding, Math.min(top, window.innerHeight - popRect.height - padding));

      let left = rect.left + rect.width / 2 - popRect.width / 2;
      left = Math.max(padding, Math.min(left, window.innerWidth - popRect.width - padding));

      tourPopover.style.top = `${Math.round(top)}px`;
      tourPopover.style.left = `${Math.round(left)}px`;

      tourArrow.classList.toggle("tour-arrow-down", fitsBelow);
      tourArrow.classList.toggle("tour-arrow-up", !fitsBelow);

      const anchorCenter = rect.left + rect.width / 2;
      const arrowLeft = Math.max(16, Math.min(anchorCenter - left, popRect.width - 16));
      tourArrow.style.left = `${Math.round(arrowLeft)}px`;
      tourArrow.style.top = fitsBelow ? "-6px" : "";
      tourArrow.style.bottom = fitsBelow ? "" : "-6px";

      tourPopover.style.visibility = "visible";
    }

    function attachTourPositioning() {
      if (tourPositionHandler) return;
      tourPositionHandler = () => {
        if (!tourState.active) return;
        const anchorEl = getCurrentAnchor();
        if (anchorEl) positionTourPopover(anchorEl);
      };
      window.addEventListener("resize", tourPositionHandler);
      window.addEventListener("scroll", tourPositionHandler, true);
    }

    function detachTourPositioning() {
      if (!tourPositionHandler) return;
      window.removeEventListener("resize", tourPositionHandler);
      window.removeEventListener("scroll", tourPositionHandler, true);
      tourPositionHandler = null;
    }

    function showStep(index) {
      if (index < 0 || index >= activeTourSteps.length) {
        closeTour("completed");
        return;
      }

      let anchorEl = null;
      let step = null;
      let resolvedIndex = index;

      for (let i = index; i < activeTourSteps.length; i += 1) {
        const candidate = activeTourSteps[i];
        const candidateAnchor = document.querySelector(candidate.anchor);
        if (candidateAnchor) {
          resolvedIndex = i;
          step = candidate;
          anchorEl = candidateAnchor;
          break;
        }
      }

      if (!anchorEl || !step) {
        closeTour("dismissed");
        return;
      }

      tourState.currentStepIndex = resolvedIndex;

      clearTourHighlight();
      anchorEl.classList.add("tour-highlight");
      anchorEl.scrollIntoView({ block: "center", behavior: "smooth" });

      tourTitle.textContent = step.title;
      tourBody.textContent = step.body;
      tourStep.textContent = `${resolvedIndex + 1} of ${activeTourSteps.length}`;

      tourOverlay.style.display = "block";
      tourPopover.style.display = "block";

      attachTourPositioning();

      requestAnimationFrame(() => {
        positionTourPopover(anchorEl);
        setTimeout(() => positionTourPopover(anchorEl), 350);
      });
    }

    function startTourAt(index, { force = false, steps = preUploadTourSteps } = {}) {
      if (!force && !shouldShowStudentHelpers()) return;
      activeTourSteps = steps;
      createTourElements();
      tourState.active = true;
      tourState.currentStepIndex = index;
      if (force && tourHideCheckbox) {
        tourHideCheckbox.checked = false;
      }
      showStep(index);
    }

    function startTour({ force = false } = {}) {
      startTourAt(0, { force, steps: preUploadTourSteps });
    }

    function clearStudentHelperSuppression() {
      localStorage.removeItem(STUDENT_HELPERS_DISABLED_KEY);
      localStorage.removeItem(TOUR_DONE_KEY);
      localStorage.removeItem(TOUR_HIDE_KEY);
    }

    function getTourStepsForCurrentState() {
      const hasPreviewCard = markedPreviewCard && markedPreviewCard.style.display !== "none";
      const hasPreviewText = markedPreview && markedPreview.innerText.trim().length > 0;
      const hasIssuesData = mostCommonIssuesWrap && mostCommonIssuesWrap.dataset.hasData === "true";
      const hasExamples = examplesList && examplesList.children.length > 0;
      if (hasPreviewCard || hasPreviewText || hasIssuesData || hasExamples) {
        return postPreviewTourSteps;
      }
      if (selectedFile) {
        return postUploadTourSteps;
      }
      return preUploadTourSteps;
    }

    function startTourForCurrentState({ force = false } = {}) {
      const steps = getTourStepsForCurrentState();
      if (steps === postPreviewTourSteps) {
        ensurePostPreviewTourVisibility();
      }
      startTourAt(0, { force, steps });
    }

    async function nextStep() {
      if (tourHideCheckbox && tourHideCheckbox.checked) {
        closeTour("hide");
        return;
      }
      const currentStep = activeTourSteps[tourState.currentStepIndex];
      const isPostPreviewRecheck =
        activeTourSteps === postPreviewTourSteps &&
        currentStep?.anchor === "#recheckDocumentBtn";
      if (isPostPreviewRecheck) {
        if (tourNextBtn) tourNextBtn.disabled = true;
        try {
          const label = await loadRandomIssueForTraining();
          if (!label) {
            closeTour("completed");
            return;
          }
          showStep(tourState.currentStepIndex + 1);
        } finally {
          if (tourNextBtn) tourNextBtn.disabled = false;
        }
        return;
      }
      const nextIndex = tourState.currentStepIndex + 1;
      if (nextIndex >= activeTourSteps.length) {
        closeTour("completed");
        return;
      }
      showStep(nextIndex);
    }

    function closeTour(reason) {
      tourState.active = false;
      detachTourPositioning();
      clearTourHighlight();

      if (tourOverlay) tourOverlay.style.display = "none";
      if (tourPopover) tourPopover.style.display = "none";
      if (reason === "hide") {
        localStorage.setItem(STUDENT_HELPERS_DISABLED_KEY, "1");
        localStorage.setItem(TOUR_DONE_KEY, "1");
      } else if (reason === "completed") {
        localStorage.setItem(TOUR_DONE_KEY, "1");
      }
    }

    function startPostUploadTour() {
      startTourAt(0, { force: FORCE_STUDENT_HELPERS, steps: postUploadTourSteps });
    }

    function ensurePostPreviewTourVisibility() {
      if (resultsCard) resultsCard.style.display = "block";
      if (downloadBtn) downloadBtn.style.display = "block";
      if (markedPreviewCard) markedPreviewCard.style.display = "block";
      hideMarkButtonShowRecheck();
      if (mostCommonIssuesWrap && mostCommonIssuesWrap.dataset.hasData === "true") {
        mostCommonIssuesWrap.style.display = "block";
      }
    }

    function formatOrdinal(n) {
      const num = parseInt(n, 10);
      if (Number.isNaN(num)) return `${n}`;
      const mod100 = num % 100;
      if (mod100 >= 11 && mod100 <= 13) return `${num}th`;
      const mod10 = num % 10;
      if (mod10 === 1) return `${num}st`;
      if (mod10 === 2) return `${num}nd`;
      if (mod10 === 3) return `${num}rd`;
      return `${num}th`;
    }

    function formatBodySectionName(bodyNum) {
      return `${formatOrdinal(bodyNum)} Body Paragraph`;
    }

    function startPostPreviewTour() {
      startTourAt(0, { force: FORCE_STUDENT_HELPERS, steps: postPreviewTourSteps });
    }

    // Initial state
    showMarkButtonHideRecheck();
    updateFileUI();
  </script>
</body>
</html>
