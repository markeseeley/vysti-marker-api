<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vysti Marker — Student Check</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/marker.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docx-preview/dist/docx-preview.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <style>
    .text-details-toggle {
      margin-top: 12px;
      padding: 8px 0;
      font-size: var(--fs-sm);
      font-weight: 600;
      color: var(--maroon);
      cursor: pointer;
      user-select: none;
    }
    .text-details-toggle:hover {
      text-decoration: underline;
    }
    .text-details-section {
      margin-top: 8px;
      padding: 0;
      background: transparent;
      border: 0;
      border-radius: 0;
      display: none;
    }
    .text-details-section.visible {
      display: block;
    }
    .title-type-block {
      margin-top: 12px;
    }
    .title-type-label {
      font-size: var(--fs-sm);
      font-weight: 600;
      margin-bottom: 8px;
    }
    .title-type-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    .type-option {
      cursor: pointer;
    }
    .type-head {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .type-name {
      font-weight: 600;
      font-size: var(--fs-sm);
    }
    .title-type-block input[type="radio"] {
      width: 16px;
      height: 16px;
      accent-color: var(--maroon);
    }
    .assignment-tracker-block {
      margin-bottom: 18px;
      padding: 16px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    .assignment-tracker-title {
      font-size: var(--fs-sm);
      font-weight: 700;
      color: var(--text);
      margin-bottom: 4px;
    }
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .assignment-tracker-help {
      font-size: var(--fs-sm);
      color: var(--muted);
      margin-bottom: 12px;
    }
    .work-section {
      margin-top: 12px;
      padding: 16px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    /* Don’t double-space the first work box under the toggle */
    #work1Section {
      margin-top: 0;
    }
    .work-section.hidden {
      display: none;
    }
    .work-title {
      font-size: var(--fs-sm);
      font-weight: 600;
      color: var(--text);
      margin-bottom: 12px;
    }
    .add-work-btn {
      margin-top: 12px;
      padding: 8px 16px;
      background: transparent;
      border: 1px solid var(--maroon);
      border-radius: 6px;
      color: var(--maroon);
      font-size: var(--fs-sm);
      font-weight: 600;
      cursor: pointer;
    }
    .add-work-btn:hover {
      background: var(--maroon);
      color: #fff;
    }
    .primary-btn.is-loading {
      cursor: progress;
      opacity: 0.95; /* keep readable even while disabled */
    }

    /* Loading indicator: blinking cursor (optional; controlled in JS) */
    @keyframes vysti-caret-blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }
    button.loading-cursor::after {
      content: " \258c"; /* U+258C (left half block) */
      animation: vysti-caret-blink 900ms step-end infinite;
    }

    /* Preview action area (centered button below preview) */
    .preview-actions {
      margin-top: 16px;
      display: flex;
      justify-content: center;
    }
    .preview-actions .primary-btn {
      width: min(360px, 100%);
      margin-top: 0; /* override default .primary-btn margin-top */
    }
    .detected-meta {
      margin-top: 12px;
      padding: 8px 12px;
      background: #e7f3ff;
      border-radius: 6px;
      font-size: var(--fs-xs);
      color: #000;
      display: none;
    }
    .detected-meta.visible {
      display: block;
    }
    .marked-preview-card {
      margin-top: 24px;
      grid-column: 1 / -1;
    }
    .marked-preview-container {
      max-height: 600px;
      overflow-y: auto;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 16px;
      background: #fff;
    }
    .revision-practice-card {
      margin-top: 24px;
      grid-column: 1 / -1;
    }
    .issue-select-wrapper {
      margin-bottom: 16px;
    }
    .issue-buttons-title {
      font-weight: 700;
      margin-bottom: 8px;
    }
    .issue-buttons-wrap {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .issue-section-block {
      padding-top: 4px;
    }
    .issue-section-heading {
      text-align: center;
      font-size: var(--fs-xs);
      font-weight: 700;
      color: var(--muted);
      margin: 6px 0 8px;
      letter-spacing: 0.02em;
    }
    .issue-button-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    .issue-btn {
      appearance: none;
      border: 1px solid var(--issue-border, #e0e0e0);
      background: var(--issue-bg, #fff);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: var(--fs-xs);
      cursor: pointer;
      transition: border-color 120ms ease, box-shadow 120ms ease, transform 80ms ease, background-color 120ms ease;
    }
    .issue-btn:hover {
      border-color: var(--issue-border, #e0e0e0);
      background: var(--issue-bg-hover, #fff);
    }
    .issue-btn:active {
      transform: translateY(1px);
    }
    .issue-btn.active {
      border-color: var(--issue-border, #e0e0e0);
      box-shadow: 0 0 0 2px var(--issue-ring, rgba(128, 0, 32, 0.15));
    }
    .issue-explanation-header {
      font-weight: 700;
      font-size: var(--fs-xs);
      margin-bottom: 6px;
      color: rgba(0, 0, 0, .75);
      text-transform: none;
    }
    .issue-explanation {
      margin-bottom: 16px;
      padding: 12px;
      background: #f8f9fa;
      border-radius: 6px;
      font-size: var(--fs-sm);
      color: var(--text);
    }
    .examples-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .example-item {
      margin-bottom: 20px;
      padding: 16px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    .example-guidance {
      font-size: var(--fs-xs);
      color: rgba(0, 0, 0, .75);
      margin-bottom: 8px;
      padding: 10px 12px;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
    }
    .example-student {
      font-size: var(--fs-xs);
      color: var(--muted);
      margin-bottom: 12px;
    }
    .example-rewrite {
      width: 100%;
      min-height: 80px;
      padding: 8px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-size: var(--fs-body);
      font-family: inherit;
      margin-bottom: 8px;
    }
    .example-actions {
      display: flex;
      gap: 8px;
    }
    .example-btn {
      padding: 7px 12px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      background: #fff;
      font-size: var(--fs-xs);
      cursor: pointer;
    }
    .example-btn:hover {
      background: #f0f0f0;
    }
    .example-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .example-btn.remove-issue-btn {
      border-color: rgba(128, 0, 32, 0.35);
      color: #7a1c1c;
      background: #fff;
    }
    .example-btn.remove-issue-btn:hover {
      background: #fbeaea;
    }
    .apply-to-preview-btn {
      background: #f8f9fa;
      border-color: rgba(0,0,0,.14);
      color: rgba(0,0,0,.75);
    }
    .apply-to-preview-btn:not(:disabled):hover {
      background: #e9ecef;
    }
    .example-applied {
      opacity: 0.7;
      background: #f0f0f0;
    }
    .example-dismissed {
      background: #f9f2f2;
      border-color: #e7cfcf;
    }
    .hidden-select {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      width: 0;
      height: 0;
    }
    .rewrite-status {
      margin-top: 8px;
      padding: 8px;
      border-radius: 6px;
      font-size: var(--fs-xs);
      display: none;
    }
    .rewrite-status.visible {
      display: block;
    }
    .rewrite-status.ok {
      background: #e7f5e7;
      color: #2d5a2d;
      border: 1px solid #a8d5a8;
    }
    .rewrite-status.bad {
      background: #ffe7e7;
      color: #5a2d2d;
      border: 1px solid #d5a8a8;
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <img src="/assets/logo.svg" alt="Vysti" />
    </div>
  
    <nav>
      <a href="/student.html" class="active">Student Check</a>
    </nav>
  
    <div class="actions">
      <button class="topbar-btn" id="switchModeBtn" type="button">Switch to Teacher Mode</button>
      <button class="topbar-btn" id="logoutBtn" type="button">Sign Out</button>
    </div>
  </header>

  <main class="page">
    <form id="studentForm" class="marker-grid" style="display:none;">
      <section class="card form-card">
        <label>
          <span class="label-row">
            What is the assignment?
            <span class="type-info tt"
                  tabindex="0"
                  aria-label="What is the assignment?"
                  data-tip="Pick what you’re writing so Vysti can use the right rules. Different assignments = different checks. If you’re doing an analytic essay, you’re in the right place — that mode is the most complete. Choose it, upload your .docx, and we’ll start fixing things.">
              i
            </span>
          </span>
          <select id="mode">
            <option value="textual_analysis">Analytic essay</option>
            <option value="peel_paragraph">Mini-essay paragraph</option>
            <option value="reader_response">Reader response</option>
            <option value="argumentation">Argumentation</option>
          </select>
        </label>

        <!-- Mode explainer card (single, dynamic) -->
        <div class="mode-card" id="modeCard">
          <div class="mode-card-header">
            <span class="mode-badge" id="modeBadge">Analytic essay</span>
            <span class="mode-tag" id="modeTag"></span>
          </div>

          <div class="mode-desc" id="modeDesc">
            A formal and academic essay of analysis with all Vysti Rules running.
          </div>

          <button type="button" class="mode-more" id="modeMoreBtn" aria-expanded="false">
            Want more details?
          </button>

          <div class="mode-details" id="modeDetails" hidden>
            <ul id="modeDetailsList"></ul>
          </div>
        </div>

        <label>
          Your name (optional)
          <input type="text" id="studentName" placeholder="e.g., John Smith" />
        </label>

        <div class="assignment-tracker-block">
          <div class="assignment-tracker-title">
            <span class="label-row">
              Assignment Tracker
              <span class="type-info tt"
                    tabindex="0"
                    aria-label="Assignment Tracker"
                    data-tip="Want to track progress? Name drafts like Homework 01, 02, 03… so your dashboard makes sense later. Don’t care? Leave it blank. We won’t be offended.">
                i
              </span>
            </span>
          </div>
          <label class="visually-hidden" for="assignmentName">Assignment name (optional)</label>
          <input type="text" id="assignmentName" placeholder="Assignment name (optional) — e.g., Homework 01" aria-label="Assignment name (optional)" />
          <label style="margin-top: 12px;">
            Word count (optional)
            <input type="number" id="targetWordCount" min="0" step="1" placeholder="e.g., 800" />
          </label>
          <div id="wordCountReadout" style="margin-top: 8px; font-size: var(--fs-sm); color: var(--text);"></div>
        </div>

        <div class="text-details-toggle" id="textDetailsToggle">
          Enter author and text titles ▼
        </div>

        <div class="text-details-section visible" id="textDetailsSection">
          <div class="work-section" id="work1Section">
            <div id="metaConfirm" class="detected-meta"></div>
            <label>
              Who is the author?
              <input type="text" id="author" placeholder="Author's full name" />
            </label>

            <label>
              What is the title?
              <input type="text" id="title" placeholder="Title of the text" />
            </label>

            <div class="title-type-block">
              <div class="title-type-label">Title type</div>
              <div class="title-type-grid">
                <label class="type-option">
                  <span class="type-head">
                    <input type="radio" name="title_type" value="true" checked />
                    <span class="type-name">Minor work</span>
                    <span
                      class="type-info tt"
                      tabindex="0"
                      data-tip="Minor work = shorter pieces in quotation marks (poems, short stories, articles, songs, chapters, speeches, episodes)."
                    >i</span>
                  </span>
                </label>
                <label class="type-option">
                  <span class="type-head">
                    <input type="radio" name="title_type" value="false" />
                    <span class="type-name">Major work</span>
                    <span
                      class="type-info tt"
                      tabindex="0"
                      data-tip="Major work = longer works in italics (novels, plays, films, TV series, newspapers, journals, musical albums)."
                    >i</span>
                  </span>
                </label>
              </div>
              <select id="title_is_minor" class="hidden-select" aria-hidden="true" tabindex="-1">
                <option value="true" selected>Minor work</option>
                <option value="false">Major work</option>
              </select>
            </div>
          </div>

          <button type="button" class="add-work-btn" id="addWork2Btn">Add another</button>

          <div class="work-section hidden" id="work2Section">
            <div class="work-title">Work 2</div>
            <label>
              Who is the author?
              <input type="text" id="author2" placeholder="Author's full name" />
            </label>

            <label>
              What is the title?
              <input type="text" id="title2" placeholder="Title of the text" />
            </label>

            <div class="title-type-block">
              <div class="title-type-label">Title type</div>
              <div class="title-type-grid">
                <label class="type-option">
                  <span class="type-head">
                    <input type="radio" name="title2_type" value="true" checked />
                    <span class="type-name">Minor work</span>
                    <span
                      class="type-info tt"
                      tabindex="0"
                      data-tip="Minor work = shorter pieces in quotation marks (poems, short stories, articles, songs, chapters, speeches, episodes)."
                    >i</span>
                  </span>
                </label>
                <label class="type-option">
                  <span class="type-head">
                    <input type="radio" name="title2_type" value="false" />
                    <span class="type-name">Major work</span>
                    <span
                      class="type-info tt"
                      tabindex="0"
                      data-tip="Major work = longer works in italics (novels, plays, films, TV series, newspapers, journals, musical albums)."
                    >i</span>
                  </span>
                </label>
              </div>
              <select id="title2_is_minor" class="hidden-select" aria-hidden="true" tabindex="-1">
                <option value="true" selected>Minor work</option>
                <option value="false">Major work</option>
              </select>
            </div>
          </div>

          <button type="button" class="add-work-btn hidden" id="addWork3Btn">Add another</button>

          <div class="work-section hidden" id="work3Section">
            <div class="work-title">Work 3</div>
            <label>
              Who is the author?
              <input type="text" id="author3" placeholder="Author's full name" />
            </label>

            <label>
              What is the title?
              <input type="text" id="title3" placeholder="Title of the text" />
            </label>

            <div class="title-type-block">
              <div class="title-type-label">Title type</div>
              <div class="title-type-grid">
                <label class="type-option">
                  <span class="type-head">
                    <input type="radio" name="title3_type" value="true" checked />
                    <span class="type-name">Minor work</span>
                    <span
                      class="type-info tt"
                      tabindex="0"
                      data-tip="Minor work = shorter pieces in quotation marks (poems, short stories, articles, songs, chapters, speeches, episodes)."
                    >i</span>
                  </span>
                </label>
                <label class="type-option">
                  <span class="type-head">
                    <input type="radio" name="title3_type" value="false" />
                    <span class="type-name">Major work</span>
                    <span
                      class="type-info tt"
                      tabindex="0"
                      data-tip="Major work = longer works in italics (novels, plays, films, TV series, newspapers, journals, musical albums)."
                    >i</span>
                  </span>
                </label>
              </div>
              <select id="title3_is_minor" class="hidden-select" aria-hidden="true" tabindex="-1">
                <option value="true" selected>Minor work</option>
                <option value="false">Major work</option>
              </select>
            </div>
          </div>
        </div>

        <button class="primary-btn" id="checkBtn" type="submit" disabled>Mark my essay</button>
      </section>

      <section class="card upload-card">
        <label>Essay (.docx)</label>
        
        <div id="dropZone" class="drop-zone" tabindex="0" role="button" aria-label="Upload .docx file">
          <img class="dz-icon" src="/assets/cloud-upload.svg" alt="" aria-hidden="true" />
          <div class="dz-title">Drag & drop .docx file here</div>
          <div class="dz-sub">or click to browse</div>
          
          <input
            type="file"
            id="fileInput"
            name="file"
            accept=".docx"
            hidden
          />
        </div>

        <ul id="fileList" class="file-list"></ul>
        <button type="button" id="clearFileBtn" class="secondary-btn" style="display:none;">Clear file</button>
      </section>

      <section class="card rules-card" id="resultsCard" style="display:none;">
        <div id="statusArea" class="status-area" role="status" aria-live="polite"></div>

        <button id="downloadBtn" class="secondary-btn" type="button" style="display:none; margin-top:12px;">
          Download marked essay
        </button>

        <div id="mostCommonIssuesWrap" style="margin-top: 20px; display:none;">
          <div class="rules-title">Most Common Issues</div>
          <div style="position: relative; height: 280px;">
            <canvas id="mostCommonIssuesChart"></canvas>
          </div>
        </div>
      </section>
    </form>

    <section class="card marked-preview-card" id="markedPreviewCard" style="display:none;">
      <h2 style="margin-bottom: 12px; font-size: var(--fs-h3); font-weight: 700;">Preview</h2>
      <div style="font-size: var(--fs-xs); color: var(--muted); margin-bottom: 8px;">Tip: Click into the preview to edit. Changes here are not saved yet.</div>
      <div id="markedPreview" class="marked-preview-container"></div>

      <!-- Recheck moved here: centered under Preview + styled like primary button -->
      <div class="preview-actions">
        <button type="button" class="primary-btn" id="recheckDocumentBtn" style="display:none;" disabled>Recheck my essay</button>
      </div>
    </section>

    <section class="card revision-practice-card" id="revisionPracticeCard" style="display:none;">
      <h2 style="margin-bottom: 12px; font-size: var(--fs-h3); font-weight: 700;">Fix Your Most Common Issues</h2>
      <div class="issue-select-wrapper">
        <div class="issue-buttons-title">Select an issue</div>

        <!-- New UI -->
        <div id="issueButtonsWrap" class="issue-buttons-wrap"></div>

        <!-- Keep old selects for existing JS, but hide them -->
        <div class="issue-selects-hidden" style="display:none;">
          <label>
            Select a section
            <select id="sectionSelect"></select>
          </label>
          <label>
            Select an issue to practice
            <select id="issueSelect"></select>
          </label>
        </div>
      </div>
      <div id="issueExplanationBlock" style="display:none;">
        <div class="issue-explanation-header">Explanation of the Issue</div>
        <div id="issueExplanation" class="issue-explanation"></div>
      </div>
      <ul id="examplesList" class="examples-list"></ul>
      <button type="button" class="secondary-btn" id="downloadRevisionNotesBtn" style="margin-top: 16px; display:none;">Download revision notes</button>
    </section>

    <footer class="marker-footer" aria-label="Site footer">
      <div class="footer-copy">© 2025 Vysti Research. All rights reserved.</div>
      <img class="footer-logo" src="/assets/logo_black.png" alt="Vysti" />
    </footer>
  </main>

  <script>
    // ===== Bucket definitions =====
    const LABEL_BUCKETS = [
      {
        id: "thesis_org",
        name: "Thesis & Organization",
        matchers: [
          /thesis/i,
          /topic sentence/i,
          /organization/i,
          /transition/i,
          /boundary statement/i,
          /introduction/i,
          /conclusion/i,
          /paragraph/i,
          /structure/i
        ]
      },
      {
        id: "evidence_integration",
        name: "Evidence & Integration",
        matchers: [
          /quote/i,
          /quotation/i,
          /evidence/i,
          /citation/i,
          /\bcite\b/i,
          /works cited/i,
          /power verbs/i,
          /support/i
        ]
      },
      {
        id: "voice_audience",
        name: "Voice & Audience",
        matchers: [
          /personal pronoun/i,
          /\bI\b/i,
          /\bwe\b/i,
          /\byou\b/i,
          /reader/i,
          /audience/i
        ]
      },
      {
        id: "style_clarity",
        name: "Style & Clarity",
        matchers: [
          /contraction/i,
          /\bwhich\b/i,
          /\bfact\b/i,
          /\bprove\b/i,
          /weak verb/i,
          /vague/i,
          /people/i,
          /human/i,
          /word choice/i,
          /avoid using the word/i,
          /more than once in a sentence/i
        ]
      },
      {
        id: "grammar_mechanics",
        name: "Grammar & Mechanics",
        matchers: [
          /subject[- ]verb/i,
          /agreement/i,
          /tense/i,
          /comma/i,
          /punctuation/i,
          /spelling/i,
          /apostrophe/i
        ]
      },
      {
        id: "formatting",
        name: "Formatting & Conventions",
        matchers: [
          /MLA/i,
          /header/i,
          /format/i,
          /title/i,
          /author/i
        ]
      },
      { id: "other", name: "Other", matchers: [] }
    ];

    const BUCKET_OVERRIDES = {
      "Avoid quotations in the conclusion": "evidence_integration",
      "Avoid quotations in the introduction": "evidence_integration",
      "Clarify pronouns and antecedents": "grammar_mechanics",
      "Avoid weak verbs": "evidence_integration"
    };

    // Shared bucket color palette (same order as LABEL_BUCKETS)
    // Thesis maroon, Evidence blue, Voice green, Style yellow, Grammar purple, Formatting red, Other teal
    const BUCKET_COLORS = [
      "rgba(169, 13, 34, 1)",    // maroon - Thesis & Organization
      "rgba(52, 152, 219, 1)",   // blue - Evidence & Integration
      "rgba(46, 204, 113, 1)",   // green - Voice & Audience
      "rgba(241, 196, 15, 1)",   // yellow - Style & Clarity
      "rgba(155, 89, 182, 1)",   // purple - Grammar & Mechanics
      "rgba(231, 76, 60, 1)",    // red - Formatting & Conventions
      "rgba(26, 188, 156, 1)",   // teal - Other
    ];

    // Helper function to get bucket color by bucketId
    // Returns color with specified alpha (default 1.0 for full opacity)
    function getBucketColor(bucketId, alpha = 1.0) {
      const bucketIndex = LABEL_BUCKETS.findIndex(b => b.id === bucketId);
      if (bucketIndex === -1) {
        // Fallback to "other" color if bucket not found
        const otherIndex = LABEL_BUCKETS.findIndex(b => b.id === "other");
        const baseColor = BUCKET_COLORS[otherIndex >= 0 ? otherIndex : BUCKET_COLORS.length - 1];
        return baseColor.replace("1)", `${alpha})`);
      }
      const baseColor = BUCKET_COLORS[bucketIndex];
      return baseColor.replace("1)", `${alpha})`);
    }

    function getBucketIdForLabel(label) {
      if (!label) return "other";
      if (BUCKET_OVERRIDES[label]) return BUCKET_OVERRIDES[label];
      for (const b of LABEL_BUCKETS) {
        if (b.id === "other") continue;
        if (b.matchers.some(rx => rx.test(label))) return b.id;
      }
      return "other";
    }

    // ===== Supabase auth setup =====
    const SUPABASE_URL = "https://divdfodsdtfbdwoqvsfy.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRpdmRmb2RzZHRmYmR3b3F2c2Z5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU0MjU1OTksImV4cCI6MjA4MTAwMTU5OX0.fnm_9qX5DqdR0j6y-2mRRkwr8Icm1uRNPbUo6lqzock";

    const { createClient } = supabase;
    const supa = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const form = document.getElementById("studentForm");
    const fileInput = document.getElementById("fileInput");
    const checkBtn = document.getElementById("checkBtn");
    const clearFileBtn = document.getElementById("clearFileBtn");
    const statusArea = document.getElementById("statusArea");
    const resultsCard = document.getElementById("resultsCard");
    const downloadBtn = document.getElementById("downloadBtn");
    const fileList = document.getElementById("fileList");
    const dropZone = document.getElementById("dropZone");
    const textDetailsToggle = document.getElementById("textDetailsToggle");
    const textDetailsSection = document.getElementById("textDetailsSection");
    const titleTypeRadios = Array.from(document.querySelectorAll('input[name="title_type"]'));
    const titleIsMinorSelect = document.getElementById("title_is_minor");
    const addWork2Btn = document.getElementById("addWork2Btn");
    const addWork3Btn = document.getElementById("addWork3Btn");
    const work2Section = document.getElementById("work2Section");
    const work3Section = document.getElementById("work3Section");
    const metaConfirm = document.getElementById("metaConfirm");
    const markedPreviewCard = document.getElementById("markedPreviewCard");
    const markedPreview = document.getElementById("markedPreview");
    const revisionPracticeCard = document.getElementById("revisionPracticeCard");
    const sectionSelect = document.getElementById("sectionSelect");
    const issueSelect = document.getElementById("issueSelect");
    const issueButtonsWrap = document.getElementById("issueButtonsWrap");
    const issueExplanationBlock = document.getElementById("issueExplanationBlock");
    const issueExplanation = document.getElementById("issueExplanation");
    const examplesList = document.getElementById("examplesList");
    const recheckDocumentBtn = document.getElementById("recheckDocumentBtn");
    const downloadRevisionNotesBtn = document.getElementById("downloadRevisionNotesBtn");
    const mostCommonIssuesWrap = document.getElementById("mostCommonIssuesWrap");
    const mostCommonIssuesChartEl = document.getElementById("mostCommonIssuesChart");

    let mostCommonIssuesChart = null;
    const modeSelect = document.getElementById("mode");
    const wordCountReadout = document.getElementById("wordCountReadout");
    const targetWordCountInput = document.getElementById("targetWordCount");

    let selectedFile = null;
    const buttonLoadingTimers = new Map();
    let downloadUrl = null;
    let markedBlob = null;
    let currentMarkEvent = null;
    let pendingDetectedMeta = null;
    let currentWordCount = null;

    // Loading indicator style for the main "Mark my essay" button.
    // - true: "Processing |" (blinking cursor)
    // - false: "Processing..." (animated dots)
    const USE_CURSOR_PROMPT_LOADING = true;

    function startButtonLoading(btn, fallbackLabel) {
      if (!btn) return;
      if (!btn.dataset.baseLabel) {
        const label = (btn.textContent || fallbackLabel || "").trim();
        if (label) btn.dataset.baseLabel = label;
      }

      // visually + accessibility
      btn.classList.add("is-loading");
      btn.classList.remove("loading-cursor");
      btn.setAttribute("aria-busy", "true");
      btn.disabled = true;

      // Cursor prompt mode (preferred)
      if (USE_CURSOR_PROMPT_LOADING) {
        // No interval needed; CSS handles the blink.
        btn.classList.add("loading-cursor");
        btn.textContent = "Processing";
        return;
      }

      let dots = 0;
      const tick = () => {
        dots = (dots + 1) % 4; // 0..3
        const suffix = ".".repeat(dots);
        btn.textContent = `Processing${suffix}`;
      };

      tick();
      const timer = window.setInterval(tick, 450);
      buttonLoadingTimers.set(btn, timer);
    }

    function stopButtonLoading(btn, enableWhenDone) {
      if (!btn) return;

      const timer = buttonLoadingTimers.get(btn);
      if (timer) {
        window.clearInterval(timer);
        buttonLoadingTimers.delete(btn);
      }

      btn.classList.remove("is-loading");
      btn.classList.remove("loading-cursor");
      btn.removeAttribute("aria-busy");

      if (btn.dataset.baseLabel) btn.textContent = btn.dataset.baseLabel;

      const shouldEnable = typeof enableWhenDone === "function"
        ? enableWhenDone()
        : !!enableWhenDone;
      btn.disabled = !shouldEnable;
    }

    // ===== Mode explainer card =====
    const MODE_RULE_DEFAULTS = {
      textual_analysis: {
        description: "A formal and academic essay of analysis with all Vysti Rules running.",
        details: [
          "No first-person allowed or personal pronouns",
          "First sentence should state the author & title of the work.",
          "Requires a closed thesis statement.",
          "Requires quoted evidence in body paragraphs.",
          "Strict requirements on organization, evidence, and language.",
          "Aqua-blue highlights repetitive 'and', weak verbs, and unclarified antecedents",
          "Red strikethroughs forbidden terms."
        ]
      },
      peel_paragraph: {
        description: "One focused analytical paragraph following the Vysti Rules.",
        details: [
          "The first sentence should state the author & title of the work.",
          "The first sentence should include devices and/or strategies like a closed thesis",
          "No first-person allowed or personal pronouns",
          "Requires quoted evidence in the body of the paragraph.",
          "Strict requirements on organization, evidence, and language.",
          "Aqua-blue highlights repetitive 'and', weak verbs, and unclarified antecedents",
          "Red strikethroughs forbidden terms."
        ]
      },
      reader_response: {
        description: "More personal voice allowed, but still needs argument + evidence.",
        details: [
          "Allows first-person and personal pronouns",
          "Allows contractions and 'which'",
          "First sentence should state the author & title of the work.",
          "Requires a closed thesis statement.",
          "Requires quoted evidence in body paragraphs.",
          "Strict requirements on organization, evidence, and language.",
          "Aqua-blue highlights repetitive 'and', weak verbs, and unclarified antecedents",
          "Red strikethroughs forbidden terms."
        ]
      },
      argumentation: {
        description: "Argumentation is more open mode beyond textual analysis.",
        details: [
          "Allows for past tense.",
          "Allows first-person and personal pronouns",
          "Aqua-blue highlights repetitive 'and', weak verbs, and unclarified antecedents",
          "Red strikethroughs forbidden terms.",
        ]
      }
    };

    // Mode explainer elements
    const modeBadge = document.getElementById("modeBadge");
    const modeTagEl = document.getElementById("modeTag");
    const modeDesc = document.getElementById("modeDesc");
    const modeMoreBtn = document.getElementById("modeMoreBtn");
    const modeDetails = document.getElementById("modeDetails");
    const modeDetailsList = document.getElementById("modeDetailsList");

    function setModeExplainer(mode) {
      const cfg = MODE_RULE_DEFAULTS[mode] || MODE_RULE_DEFAULTS.textual_analysis;
      const label = modeSelect.options[modeSelect.selectedIndex]?.textContent || mode;

      if (modeBadge) modeBadge.textContent = label;
      if (modeTagEl) modeTagEl.textContent = cfg.tag || "";
      if (modeDesc) modeDesc.textContent = cfg.description || "";

      if (modeDetailsList) {
        modeDetailsList.innerHTML = "";
        (cfg.details || []).forEach((item) => {
          const li = document.createElement("li");
          li.textContent = item;
          modeDetailsList.appendChild(li);
        });
      }

      const hasDetails = Array.isArray(cfg.details) && cfg.details.length > 0;
      if (modeMoreBtn) modeMoreBtn.hidden = !hasDetails;

      if (modeMoreBtn && modeDetails) {
        modeMoreBtn.setAttribute("aria-expanded", "false");
        modeDetails.hidden = true;
        modeMoreBtn.textContent = "Want more details?";
      }
    }

    // Expand / collapse once
    if (modeMoreBtn && modeDetails) {
      modeMoreBtn.addEventListener("click", () => {
        const expanded = modeMoreBtn.getAttribute("aria-expanded") === "true";
        modeMoreBtn.setAttribute("aria-expanded", String(!expanded));
        modeDetails.hidden = expanded;
        modeMoreBtn.textContent = expanded ? "Want more details?" : "Hide details";
      });
    }

    // Initialize mode explainer
    if (modeSelect) {
      setModeExplainer(modeSelect.value);
      modeSelect.addEventListener("change", () => {
        setModeExplainer(modeSelect.value);
      });
    }

    // ===== Auth + role guard =====
    async function refreshAuthUI() {
      const { data } = await supa.auth.getSession();
      const session = data.session;

      if (!session) {
        window.location.replace("/signin.html");
        return;
      }

      // Set role to student on successful auth guard
      localStorage.setItem("vysti_role", "student");

      // Logged in as student
      form.style.display = "grid";
    }

    // Initial auth check
    refreshAuthUI();
    supa.auth.onAuthStateChange((_event, _session) => {
      refreshAuthUI();
    });

    // ===== Switch mode handler =====
    const switchModeBtn = document.getElementById("switchModeBtn");
    if (switchModeBtn) {
      switchModeBtn.addEventListener("click", () => {
        localStorage.setItem("vysti_role", "teacher");
        window.location.href = "/index.html";
      });
    }

    // ===== Logout handler =====
    const logoutBtn = document.getElementById("logoutBtn");
    logoutBtn.addEventListener("click", async () => {
      await supa.auth.signOut();
      localStorage.removeItem("vysti_role");
      window.location.replace("/signin.html");
    });

    // ===== Title type radio sync =====
    titleTypeRadios.forEach(radio => {
      radio.addEventListener("change", (e) => {
        if (e.target.checked) {
          titleIsMinorSelect.value = e.target.value;
        }
      });
    });

    // Sync Work 2 radio
    const title2TypeRadios = Array.from(document.querySelectorAll('input[name="title2_type"]'));
    const title2IsMinorSelect = document.getElementById("title2_is_minor");
    title2TypeRadios.forEach(radio => {
      radio.addEventListener("change", (e) => {
        if (e.target.checked) {
          title2IsMinorSelect.value = e.target.value;
        }
      });
    });

    // Sync Work 3 radio
    const title3TypeRadios = Array.from(document.querySelectorAll('input[name="title3_type"]'));
    const title3IsMinorSelect = document.getElementById("title3_is_minor");
    title3TypeRadios.forEach(radio => {
      radio.addEventListener("change", (e) => {
        if (e.target.checked) {
          title3IsMinorSelect.value = e.target.value;
        }
      });
    });

    // ===== Progressive disclosure for Work 2/3 =====
    addWork2Btn.addEventListener("click", () => {
      work2Section.classList.remove("hidden");
      addWork2Btn.classList.add("hidden");
      addWork3Btn.classList.remove("hidden");
    });

    addWork3Btn.addEventListener("click", () => {
      work3Section.classList.remove("hidden");
      addWork3Btn.classList.add("hidden");
    });

    // ===== Text details toggle =====
    textDetailsToggle.addEventListener("click", () => {
      const isVisible = textDetailsSection.classList.contains("visible");
      if (isVisible) {
        textDetailsSection.classList.remove("visible");
        textDetailsToggle.textContent = "Enter author and text titles ▼";
      } else {
        textDetailsSection.classList.add("visible");
        textDetailsToggle.textContent = "Enter author and text titles ▲";
      }
    });

    // ===== File handling (single file only) =====
    function updateFileUI() {
      fileList.innerHTML = "";
      clearFileBtn.style.display = "none";
      
      if (selectedFile) {
        const li = document.createElement("li");
        li.textContent = selectedFile.name;
        fileList.appendChild(li);
        clearFileBtn.style.display = "block";
        checkBtn.disabled = false;
      } else {
        checkBtn.disabled = true;
      }
    }

    function updateWordCountUI() {
      if (!wordCountReadout) return;
      
      if (currentWordCount === null || currentWordCount === undefined) {
        wordCountReadout.textContent = "";
        return;
      }
      
      const target = targetWordCountInput ? parseInt(targetWordCountInput.value, 10) : null;
      
      if (!isNaN(target) && target > 0) {
        const diff = currentWordCount - target;
        if (diff === 0) {
          wordCountReadout.textContent = `Word count: ${currentWordCount} (on target)`;
        } else if (diff > 0) {
          wordCountReadout.textContent = `Word count: ${currentWordCount} (target ${target}: ${diff} words over)`;
        } else {
          wordCountReadout.textContent = `Word count: ${currentWordCount} (target ${target}: ${Math.abs(diff)} words under)`;
        }
      } else {
        wordCountReadout.textContent = `Word count: ${currentWordCount}`;
      }
    }

    function clearFile() {
      // Safety: stop any in-progress button loader
      stopButtonLoading(checkBtn, () => !!selectedFile);
      if (resultsCard) resultsCard.style.display = "none";
      selectedFile = null;
      fileInput.value = "";
      downloadUrl = null;
      markedBlob = null;
      downloadBtn.style.display = "none";
      statusArea.textContent = "";
      statusArea.className = "status-area";
      pendingDetectedMeta = null;
      metaConfirm.classList.remove("visible");
      metaConfirm.textContent = "";
      markedPreviewCard.style.display = "none";
      markedPreview.innerHTML = "";
      revisionPracticeCard.style.display = "none";
      issueSelect.innerHTML = '<option value="">Select an issue...</option>';
      if (issueButtonsWrap) issueButtonsWrap.innerHTML = "";
      if (issueExplanationBlock) issueExplanationBlock.style.display = "none";
      examplesList.innerHTML = "";
      downloadRevisionNotesBtn.style.display = "none";
      if (recheckDocumentBtn) {
        recheckDocumentBtn.style.display = "none";
        recheckDocumentBtn.disabled = true;
      }
      currentMarkEvent = null;
      currentWordCount = null;
      if (wordCountReadout) wordCountReadout.textContent = "";
      
      // Clear Work 1 inputs
      const authorInput = document.getElementById("author");
      const titleInput = document.getElementById("title");
      if (authorInput) authorInput.value = "";
      if (titleInput) titleInput.value = "";
      
      // Reset Work 1 title type to Minor
      const minorRadio1 = document.querySelector('input[name="title_type"][value="true"]');
      if (minorRadio1) minorRadio1.checked = true;
      if (titleIsMinorSelect) titleIsMinorSelect.value = "true";
      
      // Clear Work 2 inputs
      const author2Input = document.getElementById("author2");
      const title2Input = document.getElementById("title2");
      if (author2Input) author2Input.value = "";
      if (title2Input) title2Input.value = "";
      
      // Reset Work 2 title type to Minor
      const minorRadio2 = document.querySelector('input[name="title2_type"][value="true"]');
      if (minorRadio2) minorRadio2.checked = true;
      const title2IsMinorSelect = document.getElementById("title2_is_minor");
      if (title2IsMinorSelect) title2IsMinorSelect.value = "true";
      
      // Clear Work 3 inputs
      const author3Input = document.getElementById("author3");
      const title3Input = document.getElementById("title3");
      if (author3Input) author3Input.value = "";
      if (title3Input) title3Input.value = "";
      
      // Reset Work 3 title type to Minor
      const minorRadio3 = document.querySelector('input[name="title3_type"][value="true"]');
      if (minorRadio3) minorRadio3.checked = true;
      const title3IsMinorSelect = document.getElementById("title3_is_minor");
      if (title3IsMinorSelect) title3IsMinorSelect.value = "true";
      
      // Hide + reset Most Common Issues chart
      if (mostCommonIssuesWrap) mostCommonIssuesWrap.style.display = "none";
      if (mostCommonIssuesChart) {
        mostCommonIssuesChart.destroy();
        mostCommonIssuesChart = null;
      }

      updateFileUI();
    }

    clearFileBtn.addEventListener("click", clearFile);

    // Click drop zone to open file picker
    dropZone.addEventListener("click", () => fileInput.click());

    dropZone.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        fileInput.click();
      }
    });

    // ===== Extract metadata from docx =====
    
    // Helper: Strip HTML tags and get plain text
    function stripTags(html) {
      const tmp = document.createElement("div");
      tmp.innerHTML = html;
      return tmp.textContent || tmp.innerText || "";
    }
    
    // Helper: Normalize typography (curly quotes to straight quotes, non-breaking spaces, whitespace)
    function normalizeTypography(s) {
      return (s || "")
        .replace(/\u00A0/g, " ")
        // smart double quotes + guillemets → "
        .replace(/[\u201C\u201D\u201E\u201F\u00AB\u00BB]/g, '"')
        // smart single quotes/apostrophes → '
        .replace(/[\u2018\u2019\u201A\u201B]/g, "'")
        // primes sometimes appear as quotes
        .replace(/[\u2032\u2035]/g, "'")
        .replace(/[\u2033\u2036]/g, '"')
        // normalize dashes
        .replace(/[\u2013\u2014]/g, "-")
        .replace(/\s+/g, " ")
        .trim();
    }
    
    // Helper: Normalize punctuation (curly quotes/apostrophes to straight ones, non-breaking spaces)
    function normalizePunct(s) {
      // keep legacy callsites; normalizeTypography already handles quotes/apostrophes
      return normalizeTypography(s);
    }
    
    // Helper: Check if a period is part of an initial or abbreviation
    function isInitialOrAbbrevDot(t, i) {
      if (t[i] !== ".") return false;
      const before = t.slice(0, i + 1);
      const after = t.slice(i + 1);

      // single-letter initial: "F." "M." etc, followed by space + capital
      if (/\b[A-Z]\.$/.test(before) && /^\s+[A-Z]/.test(after)) return true;

      // common abbrevs
      if (/\b(?:Mr|Ms|Mrs|Dr|Prof|Sr|Jr|St)\.$/.test(before) && /^\s+[A-Z]/.test(after)) return true;

      // U.S. / U.K. style
      if (/\b[A-Z]\.[A-Z]\.$/.test(before) && /^\s+[A-Z]/.test(after)) return true;

      return false;
    }

    // Helper: Find the index of the sentence end, accounting for quotes and initials
    function findSentenceEndIndex(text) {
      const t = normalizeTypography(text);
      let inQuotes = false;

      for (let i = 0; i < t.length; i++) {
        const ch = t[i];

        // IMPORTANT: only treat double quotes as quotes. Never treat apostrophe as a quote delimiter.
        if (ch === '"') inQuotes = !inQuotes;
        if (inQuotes) continue;

        if (ch === "." || ch === "!" || ch === "?") {
          if (ch === "." && isInitialOrAbbrevDot(t, i)) continue;
          return i;
        }
      }
      return -1;
    }

    // Helper: Check if text has sentence-ending punctuation
    function hasSentenceEnd(text) {
      return findSentenceEndIndex(text) !== -1;
    }
    
    // Helper: Check if text looks like a student essay-title header format
    function isEssayTitleHeaderLine(text) {
      const s = normalizeTypography(text);
      // "Quotation": Topic in Essay Title
      return /^"[^"]+"\s*:\s*.+/.test(s) && !hasSentenceEnd(s);
    }
    
    // Helper: Check if text looks like a header or title line (not an intro sentence)
    function isLikelyHeaderOrTitle(text) {
      const plainText = normalizeTypography(text);
      
      // First check: Skip student essay-title header format
      if (isEssayTitleHeaderLine(plainText)) {
        return true;
      }
      
      // 1) ANY paragraph without sentence-ending punctuation is likely a header/title
      // (unless it's extremely long, which suggests it's actual content)
      if (!hasSentenceEnd(plainText) && plainText.length <= 220) {
        return true;
      }
      
      // Keep the old check for backward compatibility with very short lines
      if (plainText.length <= 80 && !hasSentenceEnd(plainText)) {
        return true;
      }
      
      // 2) Looks like a date line
      if (/\b\d{1,2}\/\d{1,2}(\/\d{2,4})?\b/.test(plainText)) {
        return true;
      }
      const monthMatch = /\b(january|february|march|april|may|june|july|august|september|october|november|december)\b/i.test(plainText);
      if (monthMatch && /\d/.test(plainText)) {
        return true;
      }
      
      // 3) Looks like a teacher/class line
      if (/\b(Mr\.|Ms\.|Mrs\.|Dr\.|Professor|Prof\.)\b/i.test(plainText)) {
        return true;
      }
      
      // 4) Looks like a student name line (1-4 tokens, all Title Case, no punctuation, no digits)
      const tokens = plainText.split(/\s+/).filter(t => t.length > 0);
      if (tokens.length >= 1 && tokens.length <= 4) {
        const allTitleCase = tokens.every(t => /^[A-Z][a-z]*$/.test(t));
        const noDigits = !/\d/.test(plainText);
        const noSentencePunct = !/[.!?]/.test(plainText);
        if (allTitleCase && noDigits && noSentencePunct) {
          return true;
        }
      }
      
      // 5) Looks like "Homework / Essay / Paper / Assignment" heading
      if (/^(homework|essay|paper|assignment)\b/i.test(plainText)) {
        return true;
      }
      
      return false;
    }
    
    // Helper: Count words in text
    function countWords(text) {
      const words = (text || "").match(/\b[A-Za-z]+\b/g) || [];
      return words.length;
    }
    
    // Helper: Clean title by removing surrounding quotes and trailing punctuation
    function cleanTitle(t) {
      t = normalizeTypography(t);
      t = t.replace(/^[\"']+/, "").replace(/[\"']+$/, "");
      // strip common trailing punctuation that's inside quotes in prose
      t = t.replace(/[,\.;:]+$/g, "");
      return t.trim();
    }
    
    // Helper: Extract first sentence from plain text
    function getFirstSentence(text) {
      const t = normalizeTypography(text);
      const idx = findSentenceEndIndex(t);
      return idx === -1 ? t : t.slice(0, idx + 1).trim();
    }
    
    async function extractMetaFromDocx(file) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        const result = await mammoth.convertToHtml({ arrayBuffer });
        const html = result.value;
        
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        
        // Parse HTML into a list of paragraphs with metadata
        const paras = Array.from(doc.querySelectorAll("p"))
          .map(p => {
            const html = p.innerHTML.trim();
            const plain = stripTags(html).trim();
            return {
              html,
              plain,
              wordCount: countWords(plain)
            };
          })
          .filter(p => p.plain.length > 0);
        
        if (paras.length === 0) return null;
        
        // Find the intro paragraph using priority selection:
        // A) First paragraph that: NOT header/title AND has sentence end AND >= 8 words
        // B) First paragraph that: NOT header/title AND has sentence end AND >= 5 words
        // C) First paragraph that: NOT header/title (but still requires sentence end)
        let introParagraphHtml = null;
        let introParagraphPlain = null;
        
        // Priority A: >= 8 words with sentence end
        for (const para of paras) {
          if (isLikelyHeaderOrTitle(para.plain)) continue;
          if (hasSentenceEnd(para.plain) && para.wordCount >= 8) {
            introParagraphHtml = para.html;
            introParagraphPlain = para.plain;
            break;
          }
        }
        
        // Priority B: >= 5 words with sentence end
        if (!introParagraphHtml) {
          for (const para of paras) {
            if (isLikelyHeaderOrTitle(para.plain)) continue;
            if (hasSentenceEnd(para.plain) && para.wordCount >= 5) {
              introParagraphHtml = para.html;
              introParagraphPlain = para.plain;
              break;
            }
          }
        }
        
        // Priority C: Any non-header paragraph with sentence end
        if (!introParagraphHtml) {
          for (const para of paras) {
            if (isLikelyHeaderOrTitle(para.plain)) continue;
            if (hasSentenceEnd(para.plain)) {
              introParagraphHtml = para.html;
              introParagraphPlain = para.plain;
              break;
            }
          }
        }
        
        if (!introParagraphHtml || !introParagraphPlain) {
          return null;
        }
        
        // IMPORTANT: Split intro paragraph on <br> if present to isolate intro sentence
        // Mammoth sometimes outputs student title + intro sentence in the same <p>
        let introSentenceHtml = introParagraphHtml;
        let selectedSegmentPlain = introParagraphPlain;
        
        // Split into segments by <br>
        const frag = document.createElement("div");
        frag.innerHTML = introParagraphHtml;
        
        const segments = [];
        let buf = [];
        
        // Walk through child nodes and split on <br>
        frag.childNodes.forEach(node => {
          if (node.nodeName === "BR") {
            if (buf.length > 0) {
              segments.push(buf);
              buf = [];
            }
          } else {
            buf.push(node);
          }
        });
        if (buf.length > 0) {
          segments.push(buf);
        }
        
        // If we found segments (meaning there were <br> tags), try to pick the first real sentence
        if (segments.length > 1) {
          let selectedSegment = null;
          
          // Priority 1: First segment with sentence end AND >= 8 words
          for (const buf of segments) {
            const segDiv = document.createElement("div");
            buf.forEach(n => {
              try {
                segDiv.appendChild(n.cloneNode(true));
              } catch (e) {
                // Skip nodes that can't be cloned (e.g., some text nodes)
              }
            });
            const segHtml = segDiv.innerHTML.trim();
            const segPlain = stripTags(segHtml).trim();
            
            // Skip essay title header segments
            if (isEssayTitleHeaderLine(segPlain)) continue;
            if (isLikelyHeaderOrTitle(segPlain)) continue;
            
            const wc = countWords(segPlain);
            
            if (hasSentenceEnd(segPlain) && wc >= 8) {
              selectedSegment = { html: segHtml, plain: segPlain };
              break;
            }
          }
          
          // Priority 2: First segment with sentence end AND >= 5 words
          if (!selectedSegment) {
            for (const buf of segments) {
              const segDiv = document.createElement("div");
              buf.forEach(n => {
                try {
                  segDiv.appendChild(n.cloneNode(true));
                } catch (e) {
                  // Skip nodes that can't be cloned
                }
              });
              const segHtml = segDiv.innerHTML.trim();
              const segPlain = stripTags(segHtml).trim();
              
              // Skip essay title header segments
              if (isEssayTitleHeaderLine(segPlain)) continue;
              if (isLikelyHeaderOrTitle(segPlain)) continue;
              
              const wc = countWords(segPlain);
              
              if (hasSentenceEnd(segPlain) && wc >= 5) {
                selectedSegment = { html: segHtml, plain: segPlain };
                break;
              }
            }
          }
          
          // If we found a selected segment, use it
          if (selectedSegment) {
            introSentenceHtml = selectedSegment.html;
            selectedSegmentPlain = selectedSegment.plain;
          }
          // Otherwise, fallback to whole paragraph (already set above)
        }
        
        // Extract first sentence from the selected segment
        const firstSentencePlain = getFirstSentence(selectedSegmentPlain);
        const firstSentenceNorm = normalizeTypography(firstSentencePlain);
        
        let detectedTitle = null;
        let detectedAuthor = null;
        let isMinor = true;
        
        // Extract title from intro sentence segment ONLY (not from essay title line)
        const frag2 = document.createElement("div");
        frag2.innerHTML = introSentenceHtml;
        
        // Helper: Check if element or any ancestor is italic
        function isItalicAncestor(el) {
          let current = el;
          while (current && current !== frag2) {
            if (current.nodeType === Node.ELEMENT_NODE) {
              const tagName = current.tagName?.toLowerCase();
              if (tagName === "em" || tagName === "i") return true;
              const style = current.style?.fontStyle || window.getComputedStyle(current).fontStyle;
              if (style && style.includes("italic")) return true;
            }
            current = current.parentNode;
          }
          return false;
        }
        
        // Collect italic phrases using TreeWalker
        const italicPhrases = [];
        const walker = document.createTreeWalker(
          frag2,
          NodeFilter.SHOW_TEXT,
          null
        );
        
        let currentPhrase = "";
        let node = walker.nextNode();
        
        while (node) {
          const isItalic = isItalicAncestor(node);
          const text = node.textContent || "";
          
          if (isItalic) {
            // Add text to current phrase
            currentPhrase += text;
          } else {
            // Non-italic node
            if (currentPhrase) {
              // If we have a phrase building, check if this is whitespace between italic nodes
              if (text.trim() === "" && text.length > 0) {
                // Single whitespace-only node between italic nodes - add space and continue
                currentPhrase += " ";
              } else {
                // Non-whitespace or empty - finalize the phrase
                if (currentPhrase.trim()) {
                  italicPhrases.push(currentPhrase);
                }
                currentPhrase = "";
              }
            }
          }
          
          node = walker.nextNode();
        }
        
        // Don't forget the last phrase if we ended in italic text
        if (currentPhrase.trim()) {
          italicPhrases.push(currentPhrase);
        }
        
        // Filter and normalize phrases
        const validPhrases = italicPhrases
          .map(p => normalizeTypography(p).trim())
          .filter(p => {
            if (p.length < 2 || p.length > 160) return false;
            // Not just punctuation/quotes
            if (/^[^\w]+$/.test(p)) return false;
            return true;
          });
        
        // Pick best phrase (prefer longest; tie-breaker: more Title-Cased words)
        if (validPhrases.length > 0) {
          function countTitleCaseWords(s) {
            const words = s.match(/\b[A-Z][a-z]+\b/g) || [];
            return words.length;
          }
          
          validPhrases.sort((a, b) => {
            if (b.length !== a.length) return b.length - a.length;
            return countTitleCaseWords(b) - countTitleCaseWords(a);
          });
          
          detectedTitle = cleanTitle(validPhrases[0]);
          isMinor = false;
        }
        
        // If no italics, check for quoted text (Minor work)
        if (!detectedTitle) {
          const quoted = Array.from(firstSentenceNorm.matchAll(/"([^"]+)"/g))
            .map(m => ({
              text: (m[1] || "").trim(),
              idx: m.index ?? 0
            }))
            .filter(x => x.text && x.text.length >= 2 && x.text.length <= 120);

          if (quoted.length) {
            // Prefer a quote that looks like a work title in context:
            // e.g., "essay "Title"", "article "Title"", "novel "Title"", etc.
            const workWords = /(essay|article|novel|poem|short story|story|play|film|movie|book|chapter|speech|song|album)\b/i;

            const hasNonQuestion = quoted.some(q => !q.text.includes("?"));

            function scoreCandidate(q) {
              const left = firstSentenceNorm.slice(Math.max(0, q.idx - 45), q.idx);
              let score = 0;

              if (workWords.test(left)) score += 10;         // strongest signal
              if (q.idx < firstSentenceNorm.length / 2) score += 2; // earlier is better

              // Questions are often quoted prompts, not titles (but allow if it's the only option)
              if (q.text.includes("?") && hasNonQuestion) score -= 6;

              return score;
            }

            quoted.sort((a, b) => scoreCandidate(b) - scoreCandidate(a) || a.idx - b.idx);

            detectedTitle = cleanTitle(quoted[0].text);
            isMinor = true;
          }
        }
        
        // Extract author from first sentence
        const NAME_STOPWORDS = new Set([
          "In","On","At","From","With","Without","By","For","To","As",
          "When","While","After","Before","During","Since","Because","Although","Though",
          "The","A","An","This","That","These","Those"
        ]);

        function cleanPossessive(tok) {
          return tok.replace(/['']s$/, "");
        }
        
        function isNameToken(tok) {
          if (!tok) return false;
          if (NAME_STOPWORDS.has(tok)) return false;

          // Initial: "F."
          if (/^[A-Z]\.$/.test(tok)) return true;

          // Single capital (rare but allow)
          if (/^[A-Z]$/.test(tok)) return true;

          // Name word: "Richard", "Selzer", "O'Connor", "Mary-Jane"
          if (/^[A-Z][a-z]+(?:[''][A-Z][a-z]+)?(?:-[A-Z][a-z]+(?:[''][A-Z][a-z]+)?)*$/.test(tok)) return true;

          return false;
        }

        function cleanAuthorName(s) {
          s = normalizeTypography(s);
          const parts = s.split(/\s+/).filter(Boolean);
          while (parts.length > 1 && NAME_STOPWORDS.has(parts[0])) parts.shift();
          return parts.join(" ");
        }
        
        function extractProperNounName(sentence, detectedTitle) {
          const toks = (sentence.match(/[A-Za-z'.-]+/g) || []).filter(Boolean);
          const titleKey = (detectedTitle || "").toLowerCase().replace(/[^a-z]+/g, " ").trim();
          const titleWords = new Set(titleKey.split(/\s+/).filter(Boolean));
          
          const candidates = [];
          let run = [];
          
          for (const raw of toks) {
            const tok = cleanPossessive(raw);
            // Skip stopwords at the start of a run
            if (run.length === 0 && NAME_STOPWORDS.has(tok)) continue;
            if (isNameToken(raw)) {
              run.push(tok);
              if (run.length > 6) run.shift();
            } else {
              if (run.length >= 2) candidates.push(run.slice());
              run = [];
            }
          }
          if (run.length >= 2) candidates.push(run.slice());
          
          // Filter out candidates that overlap heavily with title words
          const filtered = candidates
            .map(arr => arr.join(" "))
            .filter(name => {
              const words = name.toLowerCase().split(/\s+/);
              const overlap = words.filter(w => titleWords.has(w)).length;
              return overlap === 0;
            });
          
          if (filtered.length > 0) {
            const result = filtered[0];
            // Remove leading stopword if present
            const parts = result.split(/\s+/);
            if (parts.length > 1 && NAME_STOPWORDS.has(parts[0])) {
              return parts.slice(1).join(" ");
            }
            return result;
          }
          return null;
        }

        // Priority: possessive anywhere (best for "In Richard Selzer's …")
        const NAME_TOKEN = "(?:[A-Z]\\.|[A-Z][a-z]+(?:[''][A-Z][a-z]+)?(?:-[A-Z][a-z]+(?:[''][A-Z][a-z]+)?)*)";
        const NAME_RUN = `${NAME_TOKEN}(?:\\s+${NAME_TOKEN}){0,6}`;

        let possMatches = Array.from(firstSentenceNorm.matchAll(new RegExp(`\\b(${NAME_RUN})['']s\\b`, "g")));
        if (possMatches.length) {
          // choose longest then earliest
          possMatches.sort((a,b) => b[1].split(/\s+/).length - a[1].split(/\s+/).length || (a.index ?? 0) - (b.index ?? 0));
          detectedAuthor = cleanAuthorName(possMatches[0][1]);
        }

        // Next: "by Author"
        if (!detectedAuthor) {
          const by = firstSentenceNorm.match(new RegExp(`\\b[Bb]y\\s+(${NAME_RUN})\\b`));
          if (by) detectedAuthor = cleanAuthorName(by[1]);
        }

        // Fallback: improved proper-noun run extraction
        if (!detectedAuthor) {
          detectedAuthor = extractProperNounName(firstSentenceNorm, detectedTitle);
        }
        
        // Sanity tests (non-breaking)
        try {
          // Test: getFirstSentence should not stop at initials
          const test1 = getFirstSentence("In F. Scott Fitzgerald's novel \"The Great Gatsby,\" ...");
          console.assert(test1.includes("Fitzgerald"), "getFirstSentence should include Fitzgerald and not stop at F.");
          
          // Test: possessive author extraction works for curly apostrophe
          const test2Norm = normalizeTypography("In Richard Selzer's story \"The Knife,\" ...");
          const test2Matches = Array.from(test2Norm.matchAll(new RegExp(`\\b(${NAME_RUN})['']s\\b`, "g")));
          console.assert(test2Matches.length > 0 && test2Matches[0][1].includes("Selzer"), "Possessive author extraction should work for curly apostrophe");
          
          // Test: quoted title extraction works for curly quotes
          const test3Norm = normalizeTypography("In \"The Knife,\" Richard Selzer...");
          const test3Quoted = Array.from(test3Norm.matchAll(/"([^"]+)"/g));
          console.assert(test3Quoted.length > 0, "Quoted title extraction should work for curly quotes after normalization");
        } catch (testError) {
          // Silently ignore test errors to not break production
        }
        
        // Calculate word count: sum wordCount for paragraphs that are NOT header/title
        let wordCount = 0;
        for (const para of paras) {
          if (!isLikelyHeaderOrTitle(para.plain)) {
            wordCount += para.wordCount;
          }
        }
        
        return { title: detectedTitle, author: detectedAuthor, isMinor, wordCount };
      } catch (error) {
        console.error("Error extracting metadata:", error);
        return null;
      }
    }

    // File selection
    fileInput.addEventListener("change", async (e) => {
      const files = e.target.files;
      if (files && files.length > 0) {
        selectedFile = files[0];
        updateFileUI();
        
        // Extract metadata and store for later (after marking)
        const meta = await extractMetaFromDocx(selectedFile);
        if (meta) {
          pendingDetectedMeta = meta;
          if (meta.wordCount !== undefined) {
            currentWordCount = meta.wordCount;
            updateWordCountUI();
          }
          applyDetectedMetaAfterCheck();
        }
      }
    });

    // Global file drag/drop guard:
    // - Prevent browser from opening/navigating to dropped files anywhere on the page.
    // - Only allow our custom handling when the drop target is inside #dropZone.
    // - Use capture phase so we intercept before the browser/default handlers.
    function isFileDragEvent(e) {
      const dt = e.dataTransfer;
      if (!dt) return false;

      // "Files" appears in types during file drag in most browsers
      const types = dt.types ? Array.from(dt.types) : [];
      if (types.includes("Files")) return true;

      // Fallback (some browsers/devtools quirks)
      return !!(dt.files && dt.files.length);
    }

    function isInsideDropZone(target) {
      return dropZone && target instanceof Node && dropZone.contains(target);
    }

    function guardFileDnD(e) {
      // Only interfere with file drags/drops (do not break text dragging inside inputs)
      if (!isFileDragEvent(e)) return;

      // Always cancel default so the browser never opens/navigates to the file
      e.preventDefault();

      // If NOT inside the dropZone, block any other handlers too
      if (!isInsideDropZone(e.target)) {
        e.stopPropagation();

        // Optional UX hint: show "not allowed" cursor on dragover
        if (e.type === "dragover") {
          try { e.dataTransfer.dropEffect = "none"; } catch (_) {}
        }
      }
    }

    // Capture phase + passive:false so preventDefault always works.
    ["dragenter", "dragover", "drop"].forEach((evt) => {
      window.addEventListener(evt, guardFileDnD, { capture: true, passive: false });
    });

    // Drag & drop
    ["dragenter", "dragover"].forEach(evt => {
      dropZone.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.add("dragover");
      });
    });

    ["dragleave", "dragend"].forEach(evt => {
      dropZone.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove("dragover");
      });
    });

    dropZone.addEventListener("drop", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove("dragover");

      if (e.dataTransfer && e.dataTransfer.files) {
        const files = Array.from(e.dataTransfer.files);
        const docxFile = files.find(f => /\.docx$/i.test(f.name));
        if (docxFile) {
          selectedFile = docxFile;
          // Update file input programmatically
          const dt = new DataTransfer();
          dt.items.add(docxFile);
          fileInput.files = dt.files;
          updateFileUI();
          
          // Extract metadata and store for later (after marking)
          const meta = await extractMetaFromDocx(selectedFile);
          if (meta) {
            pendingDetectedMeta = meta;
            if (meta.wordCount !== undefined) {
              currentWordCount = meta.wordCount;
              updateWordCountUI();
            }
            applyDetectedMetaAfterCheck();
          }
        } else {
          statusArea.textContent = "Please upload a .docx file.";
          statusArea.className = "status-area error";
        }
      }
    });

    // ===== Form submission =====
    form.addEventListener("submit", async (e) => {
      e.preventDefault();

      if (!selectedFile) {
        statusArea.textContent = "Please select a .docx file.";
        statusArea.className = "status-area error";
        if (resultsCard) resultsCard.style.display = "block";
        return;
      }

      // Get session
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        statusArea.textContent = "You must be logged in.";
        statusArea.className = "status-area error";
        if (resultsCard) resultsCard.style.display = "block";
        return;
      }

      const mode = document.getElementById("mode").value;
      const studentName = document.getElementById("studentName").value.trim();
      const assignmentName = document.getElementById("assignmentName").value.trim();
      const author = document.getElementById("author").value.trim();
      const title = document.getElementById("title").value.trim();
      const textIsMinorWork = titleIsMinorSelect.value;
      
      // Work 2
      const author2 = document.getElementById("author2").value.trim();
      const title2 = document.getElementById("title2").value.trim();
      const title2IsMinor = document.getElementById("title2_is_minor").value;
      
      // Work 3
      const author3 = document.getElementById("author3").value.trim();
      const title3 = document.getElementById("title3").value.trim();
      const title3IsMinor = document.getElementById("title3_is_minor").value;

      // Build FormData
      const formData = new FormData();
      formData.append("file", selectedFile);
      formData.append("mode", mode);
      formData.append("include_summary_table", "false");
      // Student mode: no green device/strategy highlighting in the returned docx
      formData.append("highlight_thesis_devices", "false");

      if (studentName) {
        formData.append("student_name", studentName);
      }
      if (assignmentName) {
        formData.append("assignment_name", assignmentName);
      }
      if (author) {
        formData.append("author", author);
      }
      if (title) {
        formData.append("title", title);
        formData.append("text_is_minor_work", textIsMinorWork);
      }
      
      // Work 2
      if (author2) {
        formData.append("author2", author2);
      }
      if (title2) {
        formData.append("title2", title2);
        formData.append("text_is_minor_work_2", title2IsMinor);
      }
      
      // Work 3
      if (author3) {
        formData.append("author3", author3);
      }
      if (title3) {
        formData.append("title3", title3);
        formData.append("text_is_minor_work_3", title3IsMinor);
      }

      // Update UI (don’t show Uploading... in Results; show it on the button instead)
      if (resultsCard) resultsCard.style.display = "none";
      statusArea.textContent = "";
      statusArea.className = "status-area";
      downloadBtn.style.display = "none";
      if (mostCommonIssuesWrap) mostCommonIssuesWrap.style.display = "none";
      if (mostCommonIssuesChart) {
        mostCommonIssuesChart.destroy();
        mostCommonIssuesChart = null;
      }
      startButtonLoading(checkBtn, "Mark my essay");

      try {
        // Call API
        const API_URL = "https://vysti-rules.onrender.com/mark";
        const response = await fetch(API_URL, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${sessionData.session.access_token}`,
          },
          body: formData,
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(`HTTP ${response.status}: ${text.substring(0, 100)}`);
        }

        const blob = await response.blob();
        markedBlob = blob;
        downloadUrl = URL.createObjectURL(blob);
        
        const baseName = selectedFile.name.replace(/\.docx$/i, "");
        downloadBtn.onclick = () => {
          const a = document.createElement("a");
          a.href = downloadUrl;
          a.download = `${baseName}_marked.docx`;
          document.body.appendChild(a);
          a.click();
          a.remove();
        };

        // Render marked essay preview
        try {
          markedPreview.innerHTML = "";
          const buf = await blob.arrayBuffer();
          if (typeof docx !== "undefined" && docx.renderAsync) {
            await docx.renderAsync(buf, markedPreview, null, { inWrapper: true });
            // Make preview editable
            markedPreview.contentEditable = "true";
            markedPreview.spellcheck = true;
            markedPreview.classList.add("preview-editable");
            markedPreviewCard.style.display = "block";
          } else {
            // Fallback: show message if docx-preview not loaded
            markedPreview.innerHTML = "<p>Preview not available. Please download the file to view.</p>";
            markedPreviewCard.style.display = "block";
          }
        } catch (previewError) {
          console.error("Error rendering preview:", previewError);
          markedPreview.innerHTML = "<p>Error rendering preview. Please download the file to view.</p>";
          markedPreviewCard.style.display = "block";
        }

        if (recheckDocumentBtn) {
          recheckDocumentBtn.style.display = "block";
          recheckDocumentBtn.disabled = false;
        }

        statusArea.textContent = "Done — preview below. Download is ready.";
        statusArea.className = "status-area success";
        downloadBtn.style.display = "block";
        if (resultsCard) resultsCard.style.display = "block";
        
        // Apply detected meta after successful marking
        applyDetectedMetaAfterCheck();
        
        // Load revision practice data
        await loadRevisionPractice();

      } catch (error) {
        console.error("Error:", error);
        statusArea.textContent = `Error: ${error.message}`;
        statusArea.className = "status-area error";
        if (resultsCard) resultsCard.style.display = "block";
      } finally {
        stopButtonLoading(checkBtn, () => !!selectedFile);
      }
    });

    // ===== Apply detected meta after marking =====
    function applyDetectedMetaAfterCheck() {
      if (!pendingDetectedMeta) return;

      const meta = pendingDetectedMeta;
      const titleInput = document.getElementById("title");
      const authorInput = document.getElementById("author");

      // Apply only if empty (don't overwrite student edits)
      const titleWasEmpty = titleInput && !titleInput.value.trim();
      if (meta.author && authorInput && !authorInput.value.trim()) {
        authorInput.value = meta.author;
      }
      if (meta.title && titleInput && titleWasEmpty) {
        titleInput.value = meta.title;
      }

      // Apply type toggle only if we filled the title field (it was empty before)
      if (meta.title && titleWasEmpty) {
        if (meta.isMinor) {
          const minorRadio = document.querySelector('input[name="title_type"][value="true"]');
          if (minorRadio) minorRadio.checked = true;
          titleIsMinorSelect.value = "true";
        } else {
          const majorRadio = document.querySelector('input[name="title_type"][value="false"]');
          if (majorRadio) majorRadio.checked = true;
          titleIsMinorSelect.value = "false";
        }
      }

      // Show confirmation banner above the inputs
      metaConfirm.textContent = "Did we get the author and title right?";
      metaConfirm.classList.add("visible");

      // Ensure the section is open so the student sees it
      textDetailsSection.classList.add("visible");
      textDetailsToggle.textContent = "Enter author and text titles ▲";
    }

    // ===== Revision Practice =====
    // Handle section selection (set up once)
    sectionSelect.addEventListener("change", (e) => {
      const selectedSection = e.target.value;
      const sectionData = window.revisionSectionData;
      
      if (!sectionData) {
        return;
      }
      
      // Clear issue selection when section changes
      issueSelect.value = "";
      if (issueExplanationBlock) issueExplanationBlock.style.display = "none";
      examplesList.innerHTML = "";
      downloadRevisionNotesBtn.style.display = "none";
      
      // Repopulate issueSelect with labels in selected section
      issueSelect.innerHTML = '<option value="">Select an issue...</option>';
      
      let labelsToShow = [];
      if (!selectedSection || selectedSection === "") {
        // Show all labels
        labelsToShow = Object.keys(sectionData.labelCounts);
      } else {
        // Show labels in selected section
        labelsToShow = sectionData.sectionLabels[selectedSection] || [];
      }
      
      // Sort by count desc
      const sortedLabels = labelsToShow
        .map(label => ({
          label,
          count: sectionData.labelCounts[label] || 0
        }))
        .sort((a, b) => b.count - a.count)
        .map(item => item.label);
      
      sortedLabels.forEach(label => {
        const option = document.createElement("option");
        option.value = label;
        const count = sectionData.labelCounts[label] || 0;
        option.textContent = `${label} (${count})`;
        issueSelect.appendChild(option);
      });
    });
    
    // Handle issue selection (set up once)
    issueSelect.addEventListener("change", async (e) => {
      const selectedLabel = e.target.value;
      if (!selectedLabel) {
        if (issueExplanationBlock) issueExplanationBlock.style.display = "none";
        examplesList.innerHTML = "";
        downloadRevisionNotesBtn.style.display = "none";
        return;
      }

      await loadIssueExamples(selectedLabel);
    });

    let activeIssueBtn = null;

    function renderIssueButtonsFromSectionData(sectionData, sectionOrder) {
      if (!issueButtonsWrap) return;
      issueButtonsWrap.innerHTML = "";
      activeIssueBtn = null;

      if (!sectionData || !sectionData.sectionLabels || !sectionData.labelCounts) {
        return;
      }

      const labelCounts = sectionData.labelCounts || {};
      const sectionLabels = sectionData.sectionLabels || {};

      const order = Array.isArray(sectionOrder) && sectionOrder.length
        ? sectionOrder
        : Object.keys(sectionLabels);

      order.forEach((sectionName) => {
        const labels = (sectionLabels[sectionName] || []).slice();
        if (!labels.length) return;

        // Sort issues within the section by count desc
        labels.sort((a, b) => (labelCounts[b] || 0) - (labelCounts[a] || 0));

        const block = document.createElement("div");
        block.className = "issue-section-block";

        const heading = document.createElement("div");
        heading.className = "issue-section-heading";
        heading.textContent = sectionName;

        const row = document.createElement("div");
        row.className = "issue-button-row";

        labels.forEach((label) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "issue-btn";
          btn.dataset.issueLabel = label;

          const count = labelCounts[label] || 0;
          btn.textContent = `${label} (${count})`;
          const bucketId = getBucketIdForLabel(label);
          btn.dataset.bucketId = bucketId;
          btn.style.setProperty("--issue-border", getBucketColor(bucketId, 1.0));
          btn.style.setProperty("--issue-bg", getBucketColor(bucketId, 0.12));
          btn.style.setProperty("--issue-bg-hover", getBucketColor(bucketId, 0.18));
          btn.style.setProperty("--issue-ring", getBucketColor(bucketId, 0.22));

          btn.addEventListener("click", () => {
            // Active style
            if (activeIssueBtn) activeIssueBtn.classList.remove("active");
            activeIssueBtn = btn;
            activeIssueBtn.classList.add("active");

            // Ensure issueSelect contains ALL labels so any button can work
            if (sectionSelect) {
              sectionSelect.value = "";
              sectionSelect.dispatchEvent(new Event("change"));
            }

            // Trigger existing issueSelect flow (loads explanation + examples)
            if (issueSelect) {
              issueSelect.value = label;
              issueSelect.dispatchEvent(new Event("change"));
            }
          });

          row.appendChild(btn);
        });

        block.appendChild(heading);
        block.appendChild(row);
        issueButtonsWrap.appendChild(block);
      });
    }

    // Wrap text for tooltip display
    function wrapTooltipText(text, maxLineLen = 70) {
      const words = text.split(/\s+/).filter(Boolean);
      const lines = [];
      let line = "";
      for (const w of words) {
        const test = line ? line + " " + w : w;
        if (test.length > maxLineLen) {
          if (line) lines.push(line);
          line = w;
        } else {
          line = test;
        }
      }
      if (line) lines.push(line);
      return lines;
    }

    function renderMostCommonIssues(labelCounts) {
      if (!mostCommonIssuesWrap || !mostCommonIssuesChartEl) return;

      const entries = Object.entries(labelCounts || {})
        .filter(([label, count]) => label && (count || 0) > 0)
        .sort((a, b) => (b[1] || 0) - (a[1] || 0))
        .slice(0, 8);

      if (entries.length === 0) {
        mostCommonIssuesWrap.style.display = "none";
        if (mostCommonIssuesChart) {
          mostCommonIssuesChart.destroy();
          mostCommonIssuesChart = null;
        }
        return;
      }

      const labels = entries.map(([label]) => label);
      const values = entries.map(([, count]) => count || 0);
      const bucketIds = labels.map((lbl) => getBucketIdForLabel(lbl));
      const barBg = bucketIds.map((id) => getBucketColor(id, 0.60));
      const barBorder = bucketIds.map((id) => getBucketColor(id, 1.0));
      const issues = currentMarkEvent?.issues || [];
      const explanationByLabel = {};
      issues.forEach((iss) => {
        const lbl = String(iss?.label || "").trim();
        if (!lbl) return;
        if (iss?.explanation && !explanationByLabel[lbl]) {
          explanationByLabel[lbl] = String(iss.explanation);
        }
      });
      const explanations = labels.map((lbl) => explanationByLabel[lbl] || "");

      mostCommonIssuesWrap.style.display = "block";

      if (mostCommonIssuesChart) {
        mostCommonIssuesChart.destroy();
        mostCommonIssuesChart = null;
      }

      const ctx = mostCommonIssuesChartEl.getContext("2d");
      mostCommonIssuesChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [{
            data: values,
            backgroundColor: barBg,
            borderColor: barBorder,
            borderWidth: 1,
            explanations: explanations
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              displayColors: false,
              titleFont: { size: 16, weight: "700" },
              bodyFont: { size: 14, lineHeight: 1.35 },
              footerFont: { size: 13, weight: "700" },
              padding: 12,
              bodySpacing: 6,
              titleSpacing: 6,
              footerSpacing: 6,
              callbacks: {
                title: (items) => {
                  const item = items?.[0];
                  return item?.label || "";
                },
                label: (item) => {
                  return `Count: ${item.formattedValue}`;
                },
                afterBody: (items) => {
                  const item = items?.[0];
                  if (!item) return [];
                  const idx = item.dataIndex;
                  const expl = item.dataset?.explanations?.[idx];
                  if (!expl) return [];

                  const lines = wrapTooltipText(String(expl).trim(), 70);
                  const maxLines = 10;
                  const clipped = lines.slice(0, maxLines);

                  // If we clipped, add ellipsis to last line
                  if (lines.length > maxLines && clipped.length) {
                    clipped[clipped.length - 1] = clipped[clipped.length - 1].replace(/[.…]?$/, "…");
                  }
                  return clipped;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: { precision: 0 }
            },
            x: {
              ticks: { autoSkip: false }
            }
          }
        }
      });
    }

    async function loadRevisionPractice() {
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session || !selectedFile) {
        return;
      }

      try {
        // Get latest mark event for this user and file
        const { data: markEvents, error: markError } = await supa
          .from("mark_events")
          .select("id, label_counts, issues, created_at, file_name")
          .eq("user_id", sessionData.session.user.id)
          .eq("file_name", selectedFile.name)
          .order("created_at", { ascending: false })
          .limit(1);

        if (markError) {
          console.error("Error loading mark events:", markError);
          revisionPracticeCard.style.display = "block";
          sectionSelect.innerHTML = '<option value="">All sections</option>';
          issueSelect.innerHTML = '<option value="">Examples will appear here after marking.</option>';
          renderIssueButtonsFromSectionData(null);
          return;
        }

        if (!markEvents || markEvents.length === 0) {
          revisionPracticeCard.style.display = "block";
          sectionSelect.innerHTML = '<option value="">All sections</option>';
          issueSelect.innerHTML = '<option value="">Examples will appear here after marking.</option>';
          renderIssueButtonsFromSectionData(null);
          return;
        }

        currentMarkEvent = markEvents[0];
        const labelCounts = currentMarkEvent.label_counts || {};
        
        if (resultsCard) resultsCard.style.display = "block";
        try {
          renderMostCommonIssues(labelCounts);
        } catch (chartError) {
          console.warn("Most common issues chart failed to render:", chartError);
        }
        
        // Build section index by querying issue_examples
        let examplesQuery = supa
          .from("issue_examples")
          .select("label, paragraph_index")
          .eq("user_id", sessionData.session.user.id)
          .eq("file_name", selectedFile.name);
        
        // Filter by mark_event_id if available
        if (currentMarkEvent.id) {
          examplesQuery = examplesQuery.eq("mark_event_id", currentMarkEvent.id);
        }
        
        const { data: examplesData, error: examplesError } = await examplesQuery;
        
        if (examplesError) {
          console.warn("Error loading examples for section index:", examplesError);
        }
        
        // Determine intro_idx_est and conclusion_idx_est from paragraph_index values
        const paraIndices = (examplesData || [])
          .map(ex => ex.paragraph_index)
          .filter(idx => idx != null && typeof idx === 'number');
        
        const intro_idx_est = paraIndices.length > 0 ? Math.min(...paraIndices) : 0;
        const conclusion_idx_est = paraIndices.length > 0 ? Math.max(...paraIndices) : 0;
        
        // Build label-to-section mapping
        // For each label, find its dominant paragraph_index (most frequent)
        const labelParaCounts = {};
        (examplesData || []).forEach(ex => {
          const label = String(ex.label || "").trim();
          const paraIdx = ex.paragraph_index;
          if (!label || paraIdx == null) return;
          
          if (!labelParaCounts[label]) {
            labelParaCounts[label] = {};
          }
          labelParaCounts[label][paraIdx] = (labelParaCounts[label][paraIdx] || 0) + 1;
        });
        
        // Determine section for each label
        const labelToSection = {};
        const sectionLabels = {
          "Title & Intro": [],
          "Conclusion": [],
        };
        const bodySections = {}; // "Body paragraph N" -> [labels]
        
        Object.keys(labelCounts).forEach(label => {
          const labelLower = label.toLowerCase();
          const paraCounts = labelParaCounts[label] || {};
          
          // Find dominant paragraph_index
          let dominantParaIdx = null;
          let maxCount = 0;
          Object.entries(paraCounts).forEach(([paraIdx, count]) => {
            if (count > maxCount) {
              maxCount = count;
              dominantParaIdx = parseInt(paraIdx, 10);
            }
          });
          
          // Bucket into section
          let section = null;
          if (dominantParaIdx === intro_idx_est || 
              labelLower.includes("title") || 
              labelLower.includes("thesis") || 
              labelLower.includes("first sentence") || 
              labelLower.includes("introduction")) {
            section = "Title & Intro";
            sectionLabels["Title & Intro"].push(label);
          } else if (dominantParaIdx === conclusion_idx_est || 
                     labelLower.includes("conclusion")) {
            section = "Conclusion";
            sectionLabels["Conclusion"].push(label);
          } else if (dominantParaIdx != null) {
            const bodyNum = dominantParaIdx - intro_idx_est;
            const sectionName = `Body paragraph ${bodyNum}`;
            section = sectionName;
            if (!bodySections[sectionName]) {
              bodySections[sectionName] = [];
            }
            bodySections[sectionName].push(label);
          } else {
            // Fallback: put in Title & Intro if we can't determine
            section = "Title & Intro";
            sectionLabels["Title & Intro"].push(label);
          }
          
          labelToSection[label] = section;
        });
        
        // Merge body sections into sectionLabels
        Object.keys(bodySections).forEach(sectionName => {
          sectionLabels[sectionName] = bodySections[sectionName];
        });
        
        // Store section data for filtering
        window.revisionSectionData = {
          labelToSection,
          sectionLabels,
          labelCounts
        };
        
        // Populate sectionSelect (only include sections with at least one label)
        sectionSelect.innerHTML = '<option value="">All sections</option>';
        // Sort body sections numerically (Body paragraph 1, 2, 10, not 1, 10, 2)
        const bodySectionNames = Object.keys(bodySections).sort((a, b) => {
          const numA = parseInt(a.match(/\d+/)?.[0] || "0", 10);
          const numB = parseInt(b.match(/\d+/)?.[0] || "0", 10);
          return numA - numB;
        });
        const sectionOrder = ["Title & Intro", ...bodySectionNames, "Conclusion"];
        window.revisionSectionData.sectionOrder = sectionOrder;
        renderIssueButtonsFromSectionData(window.revisionSectionData, sectionOrder);
        sectionOrder.forEach(sectionName => {
          if (sectionLabels[sectionName] && sectionLabels[sectionName].length > 0) {
            const option = document.createElement("option");
            option.value = sectionName;
            option.textContent = sectionName;
            sectionSelect.appendChild(option);
          }
        });
        
        // Populate issueSelect with all labels (sorted by count desc)
        const sortedLabels = Object.entries(labelCounts)
          .sort((a, b) => (b[1] || 0) - (a[1] || 0))
          .map(([label]) => String(label || "").trim())
          .filter(Boolean);
        
        issueSelect.innerHTML = '<option value="">Select an issue...</option>';
        sortedLabels.forEach(label => {
          const option = document.createElement("option");
          option.value = label;
          const count = labelCounts[label] || 0;
          option.textContent = `${label} (${count})`;
          issueSelect.appendChild(option);
        });

        revisionPracticeCard.style.display = "block";

      } catch (error) {
        console.error("Error loading revision practice:", error);
        revisionPracticeCard.style.display = "block";
        sectionSelect.innerHTML = '<option value="">All sections</option>';
        issueSelect.innerHTML = '<option value="">Examples will appear here after marking.</option>';
        renderIssueButtonsFromSectionData(null);
      }
    }

    async function loadIssueExamples(label) {
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session || !selectedFile) {
        return;
      }

      try {
        // Get explanation from issues array
        const issues = currentMarkEvent?.issues || [];
        const issueData = issues.find(iss => iss.label === label);
        if (issueData && issueData.explanation) {
          issueExplanation.textContent = issueData.explanation;
          if (issueExplanationBlock) issueExplanationBlock.style.display = "block";
        } else if (issueExplanationBlock) {
          issueExplanationBlock.style.display = "none";
        }
        const guidance = issueData?.student_guidance || "";
        const labelText = (issueData?.label || label || "").trim();

        function escapeRegExp(str) {
          return String(str).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        function extractQuotedTerms(text) {
          const t = String(text || "");
          const out = [];
          const patterns = [
            /'([^']+)'/g,
            /"([^"]+)"/g,
            /[‘']([^’']+)[’']/g,
            /[“"]([^”"]+)[”"]/g
          ];

          for (const re of patterns) {
            let m;
            while ((m = re.exec(t)) !== null) {
              const term = (m[1] || "").trim();
              if (term) out.push(term);
            }
          }
          return Array.from(new Set(out));
        }

        function findFoundTerms(sentence, labelText) {
          const s = String(sentence || "");
          const candidates = extractQuotedTerms(labelText);

          const found = [];
          const seen = new Set();

          for (const term of candidates) {
            if (!term) continue;

            let matchText = null;

            // If it's a simple word, prefer word-boundary match
            if (/^[A-Za-z0-9_]+$/.test(term)) {
              const re = new RegExp(`\\b${escapeRegExp(term)}\\b`, "i");
              const m = re.exec(s);
              if (m) matchText = m[0];
            } else {
              // Otherwise do a case-insensitive substring match
              const idx = s.toLowerCase().indexOf(term.toLowerCase());
              if (idx !== -1) matchText = s.slice(idx, idx + term.length);
            }

            if (matchText) {
              const key = matchText.toLowerCase();
              if (!seen.has(key)) {
                seen.add(key);
                found.push(matchText);
              }
            }
          }

          return found;
        }

        function formatFound(foundTerms) {
          if (!foundTerms || foundTerms.length === 0) return "that word/phrase";
          const quoted = foundTerms.map(w => `'${w}'`);
          if (quoted.length === 1) return quoted[0];
          if (quoted.length === 2) return `${quoted[0]} or ${quoted[1]}`;
          return `${quoted.slice(0, -1).join(", ")}, or ${quoted[quoted.length - 1]}`;
        }

        function resolveStudentGuidance(template, sentence, labelText) {
          const tmpl = String(template || "");
          if (!tmpl.includes("{FOUND}")) return tmpl;
          const foundTerms = findFoundTerms(sentence, labelText);
          const replacement = formatFound(foundTerms);
          return tmpl.split("{FOUND}").join(replacement);
        }

        // Get examples from issue_examples
        // Fetch 50 rows to allow deduplication while still getting 10 unique examples
        // Filter by mark_event_id if available (prevents stale examples after recheck)
        let examples = null;
        let error = null;
        
        if (currentMarkEvent && currentMarkEvent.id) {
          // Try filtered query with mark_event_id
          const { data, error: err } = await supa
            .from("issue_examples")
            .select("label, sentence, student_name, paragraph_index, created_at")
            .eq("user_id", sessionData.session.user.id)
            .eq("file_name", selectedFile.name)
            .eq("label", label)
            .eq("mark_event_id", currentMarkEvent.id)
            .order("created_at", { ascending: false })
            .limit(50);
          
          if (err) {
            // If mark_event_id column doesn't exist (older DB), fallback to old query
            console.warn("mark_event_id filter failed, falling back to old query:", err);
            const { data: fallbackData, error: fallbackError } = await supa
              .from("issue_examples")
              .select("label, sentence, student_name, paragraph_index, created_at")
              .eq("user_id", sessionData.session.user.id)
              .eq("file_name", selectedFile.name)
              .eq("label", label)
              .order("created_at", { ascending: false })
              .limit(50);
            examples = fallbackData;
            error = fallbackError;
          } else {
            examples = data;
          }
        } else {
          // No mark_event_id available, use old query
          const { data: fallbackData, error: fallbackError } = await supa
            .from("issue_examples")
            .select("label, sentence, student_name, paragraph_index, created_at")
            .eq("user_id", sessionData.session.user.id)
            .eq("file_name", selectedFile.name)
            .eq("label", label)
            .order("created_at", { ascending: false })
            .limit(50);
          examples = fallbackData;
          error = fallbackError;
        }

        if (error) {
          console.error("Error loading examples:", error);
          examplesList.innerHTML = "<li>Error loading examples.</li>";
          return;
        }

        // Sort: first by created_at desc (latest run first), then by paragraph_index asc (doc order)
        const sortedExamples = (examples || []).sort((a, b) => {
          // First, sort by created_at descending (latest first)
          const timeA = new Date(a.created_at || 0).getTime();
          const timeB = new Date(b.created_at || 0).getTime();
          if (timeA !== timeB) {
            return timeB - timeA; // Descending
          }
          // If created_at is the same (same mark event), sort by paragraph_index ascending
          const paraA = a.paragraph_index ?? 999999;
          const paraB = b.paragraph_index ?? 999999;
          return paraA - paraB;
        });

        // Deduplicate examples by sentence text (trimmed)
        const uniq = [];
        const seenSent = new Set();
        for (const ex of sortedExamples) {
          const s = String(ex?.sentence || "").trim();
          if (!s) continue;
          if (seenSent.has(s)) continue;
          seenSent.add(s);
          uniq.push(ex);
          if (uniq.length >= 10) break; // Cap at 10 examples
        }

        examplesList.innerHTML = "";
        
        if (!uniq || uniq.length === 0) {
          examplesList.innerHTML = "<li>No examples available for this issue. Try fixing similar issues from other assignments.</li>";
          downloadRevisionNotesBtn.style.display = "none";
          return;
        }

        uniq.forEach((ex, idx) => {
          const li = document.createElement("li");
          li.className = "example-item";
          
          const guidanceDiv = document.createElement("div");
          guidanceDiv.className = "example-guidance";
          if (guidance) {
            guidanceDiv.textContent = resolveStudentGuidance(guidance, ex.sentence || "", labelText);
          } else {
            guidanceDiv.style.display = "none";
          }

          const rewriteTextarea = document.createElement("textarea");
          rewriteTextarea.className = "example-rewrite";
          rewriteTextarea.placeholder = "Edit directly here...";
          rewriteTextarea.setAttribute("data-example-idx", idx);
          // Prefill with the example sentence
          rewriteTextarea.value = ex.sentence || "";
          const originalSentence = ex.sentence || "";
          
          const rewriteStatusDiv = document.createElement("div");
          rewriteStatusDiv.className = "rewrite-status";
          
          const actionsDiv = document.createElement("div");
          actionsDiv.className = "example-actions";
          
          const resetExampleBtn = document.createElement("button");
          resetExampleBtn.className = "example-btn";
          resetExampleBtn.textContent = "Reset example";
          resetExampleBtn.onclick = () => {
            rewriteTextarea.value = originalSentence;
          };
          
          const copyRewriteBtn = document.createElement("button");
          copyRewriteBtn.className = "example-btn";
          copyRewriteBtn.textContent = "Copy your rewrite";
          copyRewriteBtn.onclick = () => {
            navigator.clipboard.writeText(rewriteTextarea.value).then(() => {
              copyRewriteBtn.textContent = "Copied!";
              setTimeout(() => copyRewriteBtn.textContent = "Copy your rewrite", 2000);
            });
          };
          
          const findInPreviewBtn = document.createElement("button");
          findInPreviewBtn.className = "example-btn";
          findInPreviewBtn.textContent = "Find in preview";
          findInPreviewBtn.onclick = () => {
            if (markedPreviewCard.style.display === "none" || !markedPreview || !markedPreview.innerText.trim()) {
              rewriteStatusDiv.textContent = "Click \"Mark my essay\" to load the preview first.";
              rewriteStatusDiv.className = "rewrite-status visible";
              rewriteStatusDiv.classList.remove("ok", "bad");
              return;
            }
            highlightAndScrollToExample(ex, rewriteStatusDiv);
          };
          
          const checkRewriteBtn = document.createElement("button");
          checkRewriteBtn.className = "example-btn";
          checkRewriteBtn.textContent = "Check rewrite";
          checkRewriteBtn.onclick = async () => {
            await checkRewrite(label, ex, rewriteTextarea, rewriteStatusDiv);
          };
          
          const applyToPreviewBtn = document.createElement("button");
          applyToPreviewBtn.className = "example-btn apply-to-preview-btn";
          applyToPreviewBtn.textContent = "Apply to Preview";
          applyToPreviewBtn.disabled = true;
          applyToPreviewBtn.onclick = () => {
            applyRewriteToPreview(ex, li, rewriteStatusDiv, applyToPreviewBtn);
          };

          const removeIssueBtn = document.createElement("button");
          removeIssueBtn.className = "example-btn example-action remove-issue-btn";
          removeIssueBtn.textContent = "Remove issue";
          removeIssueBtn.onclick = () => {
            removeIssueFromPreview(label, ex, rewriteStatusDiv, removeIssueBtn);
          };
          
          actionsDiv.appendChild(resetExampleBtn);
          actionsDiv.appendChild(copyRewriteBtn);
          actionsDiv.appendChild(findInPreviewBtn);
          actionsDiv.appendChild(checkRewriteBtn);
          actionsDiv.appendChild(applyToPreviewBtn);
          actionsDiv.appendChild(removeIssueBtn);
          
          // Keyboard shortcut: Ctrl+Enter (Windows) / Cmd+Enter (Mac)
          rewriteTextarea.addEventListener("keydown", async (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
              e.preventDefault();
              await checkRewrite(label, ex, rewriteTextarea, rewriteStatusDiv);
            }
          });
          
          li.appendChild(guidanceDiv);
          li.appendChild(rewriteTextarea);
          li.appendChild(rewriteStatusDiv);
          li.appendChild(actionsDiv);
          
          examplesList.appendChild(li);
        });

        downloadRevisionNotesBtn.style.display = "block";
        downloadRevisionNotesBtn.onclick = () => {
          downloadRevisionNotes(label, uniq);
        };

      } catch (error) {
        console.error("Error loading issue examples:", error);
        examplesList.innerHTML = "<li>Error loading examples.</li>";
      }
    }

    // ===== Preview highlighting helpers =====
    function getPreviewBlocks() {
      if (!markedPreview) return [];
      
      // Prefer: markedPreview.querySelectorAll(".docx p, .docx li, p, li")
      let blocks = Array.from(markedPreview.querySelectorAll(".docx p, .docx li, p, li"));
      
      // Filter out empty innerText
      blocks = blocks.filter(block => (block.innerText || "").trim().length > 0);
      
      // If none found, fallback to markedPreview.querySelectorAll("p, li, div") filtered
      if (blocks.length === 0) {
        blocks = Array.from(markedPreview.querySelectorAll("p, li, div"));
        blocks = blocks.filter(block => (block.innerText || "").trim().length > 0);
      }
      
      return blocks;
    }

    function normalizeForMatch(text) {
      return (text || "")
        .replace(/[\u201C\u201D\u201E\u201F]/g, '"')  // curly quotes to straight
        .replace(/[\u2018\u2019\u201A\u201B]/g, "'")  // curly quotes to straight
        .replace(/[\u2013\u2014]/g, "-")  // en dash and em dash to hyphen
        .replace(/\u00AD/g, "")  // remove soft hyphens
        .replace(/\u00A0/g, " ")  // non-breaking spaces to normal spaces
        .replace(/[\u200B-\u200D\uFEFF]/g, "")  // remove zero-width chars
        .replace(/\s+/g, " ")  // collapse whitespace
        .trim();
    }

    function unwrapNode(el) {
      const parent = el.parentNode;
      if (!parent) return;
      while (el.firstChild) {
        parent.insertBefore(el.firstChild, el);
      }
      parent.removeChild(el);
      parent.normalize();
    }

    function clearPreviewHighlights() {
      // Unwrap any highlight spans
      const highlightedSpans = markedPreview.querySelectorAll("span.vysti-preview-hit[data-vysti-hit='1']");
      highlightedSpans.forEach(unwrapNode);
      
      // Remove classes from any elements
      const highlighted = markedPreview.querySelectorAll(".vysti-preview-hit, .vysti-preview-hit-block");
      highlighted.forEach(el => {
        el.classList.remove("vysti-preview-hit", "vysti-preview-hit-block");
      });
    }

    function normalizeCharForMatch(ch) {
      // Convert curly quotes to straight
      if (ch === '\u201C' || ch === '\u201D' || ch === '\u201E' || ch === '\u201F') return '"';
      if (ch === '\u2018' || ch === '\u2019' || ch === '\u201A' || ch === '\u201B') return "'";
      // Convert en dash and em dash to hyphen
      if (ch === '\u2013' || ch === '\u2014') return '-';
      // Convert NBSP to space
      if (ch === '\u00A0') return ' ';
      // Strip soft hyphen and zero-width chars
      if (ch === '\u00AD' || (ch >= '\u200B' && ch <= '\u200D') || ch === '\uFEFF') return '';
      // Treat any whitespace as space
      if (/\s/.test(ch)) return ' ';
      return ch;
    }

    // Helper: Check if a text node is a Vysti label run (starts with "→")
    function isVystiLabelTextNode(node) {
      if (node.nodeType !== Node.TEXT_NODE) return false;
      
      // Check if the node's textContent (trimmed) starts with "→"
      const text = (node.textContent || "").trim();
      if (text.startsWith("→")) return true;
      
      // Also check the closest SPAN's textContent (handles cases where docx-preview splits arrow + label across nodes)
      let current = node.parentElement;
      while (current && current.tagName !== "SPAN") {
        current = current.parentElement;
      }
      if (current && current.tagName === "SPAN") {
        const spanText = (current.textContent || "").trim();
        if (spanText.startsWith("→")) return true;
      }
      
      return false;
    }

    // Helper: Check if a text node is any Vysti artifact (arrow labels or rewrite-practice tags)
    function isVystiArtifactTextNode(node) {
      if (node.nodeType !== Node.TEXT_NODE) return false;
      
      // Check for arrow labels using existing helper
      if (isVystiLabelTextNode(node)) return true;
      
      // Check for rewrite-practice tag
      const text = (node.textContent || "").trim();
      // Match the exact phrase from marker.py: " * Rewrite this paragraph for practice  *"
      // Also handle case-insensitive and variations in whitespace
      const rewritePattern = /^\s*\*\s*Rewrite this paragraph for practice\s*\*\s*$/i;
      if (rewritePattern.test(text)) return true;
      
      // Also check the closest SPAN's textContent (handles cases where docx-preview splits text across nodes)
      let current = node.parentElement;
      while (current && current.tagName !== "SPAN") {
        current = current.parentElement;
      }
      if (current && current.tagName === "SPAN") {
        const spanText = (current.textContent || "").trim();
        if (rewritePattern.test(spanText)) return true;
      }
      
      return false;
    }

    // Helper: Extract clean text from an element, excluding Vysti artifacts
    function extractCleanTextFromElement(el) {
      if (!el) return "";
      
      const walker = document.createTreeWalker(
        el,
        NodeFilter.SHOW_TEXT,
        null
      );
      
      const textParts = [];
      let node;
      
      while ((node = walker.nextNode())) {
        // Skip Vysti artifacts (arrow labels and rewrite-practice tags)
        if (isVystiArtifactTextNode(node)) continue;
        
        const text = node.textContent || "";
        if (text.trim()) {
          textParts.push(text);
        }
      }
      
      // Concatenate all text parts
      let combined = textParts.join("");
      
      // Normalize whitespace:
      // - Convert NBSP to space
      combined = combined.replace(/\u00A0/g, " ");
      // - Collapse multiple whitespace to single spaces
      combined = combined.replace(/\s+/g, " ");
      // - Trim
      combined = combined.trim();
      
      return combined;
    }

    function buildNormalizedTextMap(rootEl) {
      const walker = document.createTreeWalker(rootEl, NodeFilter.SHOW_TEXT, null);
      const posMap = [];
      let normText = "";
      let lastWasSpace = false;

      let node;
      while ((node = walker.nextNode())) {
        // Skip Vysti label runs (text starting with "→")
        if (isVystiLabelTextNode(node)) continue;
        
        const t = node.textContent || "";
        for (let i = 0; i < t.length; i++) {
          let ch = normalizeCharForMatch(t[i]);
          if (ch === "") continue;

          if (ch === " ") {
            if (normText.length === 0 || lastWasSpace) continue;
            lastWasSpace = true;
          } else {
            lastWasSpace = false;
          }

          normText += ch;
          posMap.push({ node, offset: i });
        }
      }

      return { normText, posMap };
    }

    // Helper: Wrap a substring of a single Text node by splitting it
    function wrapTextNodeSubstring(node, startOffset, endOffsetInclusive) {
      if (node.nodeType !== Node.TEXT_NODE) return null;
      
      const text = node.textContent || "";
      const endOffsetExclusive = endOffsetInclusive + 1;
      
      // Split at endOffsetExclusive if needed
      if (endOffsetExclusive < text.length) {
        const afterNode = node.splitText(endOffsetExclusive);
        // afterNode is now the node after the split
      }
      
      // Split at startOffset if needed (now node might have been shortened)
      let targetNode = node;
      if (startOffset > 0) {
        targetNode = node.splitText(startOffset);
      }
      
      // Now targetNode contains the substring we want to wrap
      const span = document.createElement("span");
      span.className = "vysti-preview-hit";
      span.setAttribute("data-vysti-hit", "1");
      
      // Wrap the targetNode
      const parent = targetNode.parentNode;
      if (parent) {
        parent.insertBefore(span, targetNode);
        span.appendChild(targetNode);
      }
      
      return span;
    }

    // Multi-span wrapper that handles ranges across multiple text nodes
    function wrapMappedRangeMulti(posMap, startIdx, endIdx) {
      if (startIdx < 0 || endIdx < startIdx || endIdx >= posMap.length) {
        return null;
      }
      
      // Build segments by grouping consecutive entries with the same node
      const segments = [];
      let currentSegment = null;
      
      for (let i = startIdx; i <= endIdx; i++) {
        const pos = posMap[i];
        if (!pos || !pos.node) continue;
        
        if (!currentSegment || currentSegment.node !== pos.node) {
          // Start new segment
          if (currentSegment) {
            segments.push(currentSegment);
          }
          currentSegment = {
            node: pos.node,
            startOffset: pos.offset,
            endOffset: pos.offset
          };
        } else {
          // Extend current segment
          currentSegment.endOffset = pos.offset;
        }
      }
      
      if (currentSegment) {
        segments.push(currentSegment);
      }
      
      if (segments.length === 0) return null;
      
      // Group segments by node, then process each node's segments in reverse offset order
      // This ensures that when we split a node, earlier offsets in the same node are still valid
      const nodeToSegments = new Map();
      for (const seg of segments) {
        if (!nodeToSegments.has(seg.node)) {
          nodeToSegments.set(seg.node, []);
        }
        nodeToSegments.get(seg.node).push(seg);
      }
      
      const createdSpans = [];
      
      // Process each node's segments separately, in reverse offset order
      for (const [originalNode, nodeSegments] of nodeToSegments) {
        // Sort by endOffset descending (process highest offsets first)
        nodeSegments.sort((a, b) => b.endOffset - a.endOffset);
        
        for (const seg of nodeSegments) {
          // Use the original node reference - wrapTextNodeSubstring handles splitting
          const span = wrapTextNodeSubstring(seg.node, seg.startOffset, seg.endOffset);
          if (span) {
            createdSpans.push(span);
          }
        }
      }
      
      // Sort spans by DOM order
      createdSpans.sort((a, b) => {
        const pos = a.compareDocumentPosition(b);
        if (pos & Node.DOCUMENT_POSITION_FOLLOWING) return -1;
        if (pos & Node.DOCUMENT_POSITION_PRECEDING) return 1;
        return 0;
      });
      
      return createdSpans.length > 0 ? createdSpans : null;
    }

    function highlightExactTextInElement(rootEl, targetSentence) {
      const target = normalizeForMatch(targetSentence);
      if (!target) return null;

      const { normText, posMap } = buildNormalizedTextMap(rootEl);

      const start = normText.indexOf(target);
      if (start === -1) return null;

      const end = start + target.length - 1;
      return wrapMappedRangeMulti(posMap, start, end);
    }

    function buildAnchorCandidates(target) {
      const lens = [80, 60, 45, 35, 25, 18];
      const prefixes = [];
      const suffixes = [];

      for (const L of lens) {
        let p = target.substring(0, Math.min(L, target.length));
        const cut = p.lastIndexOf(" ");
        if (cut > 12) p = p.substring(0, cut);
        if (p.length >= 12 && !prefixes.includes(p)) prefixes.push(p);
      }

      for (const L of lens) {
        let s = target.substring(Math.max(0, target.length - L));
        const cut = s.indexOf(" ");
        if (cut !== -1 && (s.length - (cut + 1)) >= 12) s = s.substring(cut + 1);
        if (s.length >= 12 && !suffixes.includes(s)) suffixes.push(s);
      }

      return { prefixes, suffixes };
    }

    function highlightAnchoredSentenceInElement(rootEl, sentence) {
      const target = normalizeForMatch(sentence);
      if (!target) return null;

      const { normText, posMap } = buildNormalizedTextMap(rootEl);
      const { prefixes, suffixes } = buildAnchorCandidates(target);

      // Prevent "highlight half the paragraph" accidents
      const maxAllowed = Math.max(220, target.length * 3 + 120);

      for (const prefix of prefixes) {
        const start = normText.indexOf(prefix);
        if (start === -1) continue;

        for (const suffix of suffixes) {
          const endStart = normText.indexOf(suffix, start + prefix.length);
          if (endStart === -1) continue;

          const end = endStart + suffix.length - 1;
          const spanLen = end - start + 1;

          if (spanLen <= 0 || spanLen > maxAllowed) continue;

          const spans = wrapMappedRangeMulti(posMap, start, end);
          if (spans && spans.length > 0) return spans;
        }
      }

      return null;
    }

    function scoreBlockMatch(sentence, blockText) {
      const normSentence = normalizeForMatch(sentence);
      const normBlock = normalizeForMatch(blockText);

      if (!normSentence || !normBlock) return 0.0;

      // Perfect match if the normalized block contains the full normalized sentence.
      if (normBlock.includes(normSentence)) return 1.0;

      // Token scoring fallback:
      // - Prefer longer tokens to avoid false positives.
      // - But if the sentence is short (or gets split by injected "→ ..."), relax token length.
      const tokenize = (minLen) =>
        normSentence
          .replace(/[^\w\s]/g, " ")
          .split(/\s+/)
          .filter((t) => t.length >= minLen);

      let tokens = tokenize(4);
      if (tokens.length === 0) tokens = tokenize(3);
      if (tokens.length === 0) tokens = tokenize(2);

      if (tokens.length === 0) return 0.0;

      const blockLower = normBlock.toLowerCase();
      let hits = 0;
      for (const token of tokens) {
        if (blockLower.includes(token.toLowerCase())) hits++;
      }

      return hits / tokens.length;
    }

    function findBestPreviewBlockForExample(example) {
      const blocks = getPreviewBlocks();
      if (blocks.length === 0) return null;

      const sentence = (example?.sentence || "").trim();
      const paraIndex = example?.paragraph_index;

      // If there's no usable sentence text, fall back deterministically.
      if (!sentence) {
        if (typeof paraIndex === "number") {
          const idx = Math.max(0, Math.min(blocks.length - 1, paraIndex));
          return blocks[idx] || blocks[0] || null;
        }
        return blocks[0] || null;
      }

      // 1) Global best (search all blocks). This protects us when paragraph_index is offset
      // by title/name/spacing blocks at the top of docx-preview.
      let globalBest = blocks[0];
      let globalBestScore = -1;

      for (let i = 0; i < blocks.length; i++) {
        const score = scoreBlockMatch(sentence, blocks[i].innerText || "");
        if (score > globalBestScore) {
          globalBestScore = score;
          globalBest = blocks[i];
          if (score === 1.0) break; // can't beat perfect
        }
      }

      // If paragraph_index is missing, just use the global best.
      if (typeof paraIndex !== "number") {
        return globalBest;
      }

      // 2) Local window best (prefer local when it's confident, but widen near top of document)
      const candidates = [];
      const bases = [paraIndex, paraIndex - 1, paraIndex + 1];

      for (const base of bases) {
        if (typeof base !== "number") continue;

        const backward = 4;

        // Near the top, docx-preview often adds extra blocks (title/name/blank lines),
        // so we search farther forward to avoid missing the true first body paragraph.
        const forward = base <= 2 ? 12 : 4;

        const start = Math.max(0, base - backward);
        const end = Math.min(blocks.length - 1, base + forward);

        for (let i = start; i <= end; i++) {
          const score = scoreBlockMatch(sentence, blocks[i].innerText || "");
          candidates.push({ block: blocks[i], score, index: i });
          if (score === 1.0) return blocks[i];
        }
      }

      candidates.sort((a, b) => b.score - a.score);
      const bestLocal = candidates[0];

      // If local is good, use it.
      if (bestLocal && bestLocal.score >= 0.3) {
        return bestLocal.block;
      }

      // Otherwise, if global is decent, use it (THIS fixes first-sentence problems).
      if (globalBestScore >= 0.3) {
        return globalBest;
      }

      // Last resort: old deterministic fallback.
      const fallbackIdx = Math.max(0, Math.min(blocks.length - 1, paraIndex));
      const fallbackIdx2 = Math.max(0, Math.min(blocks.length - 1, paraIndex - 1));
      return blocks[fallbackIdx] || blocks[fallbackIdx2] || globalBest || null;
    }

    function highlightAndScrollToExample(example, statusDivOptional) {
      clearPreviewHighlights();
      
      const sentence = example?.sentence || "";
      const blockEl = findBestPreviewBlockForExample(example);
      
      if (!blockEl) {
        if (statusDivOptional) {
          statusDivOptional.textContent = "Couldn't locate it in the preview automatically. Use Copy + paste manually.";
        }
        return { ok: false, hits: [], blockEl: null, used: "none" };
      }
      
      let hits = highlightExactTextInElement(blockEl, sentence);
      let used = "exact";

      // NEW: if exact fails, try anchored match (handles injected "→ ..." text inside the sentence)
      if (!hits || hits.length === 0) {
        hits = highlightAnchoredSentenceInElement(blockEl, sentence);
        used = "anchor";
      }

      if (hits && hits.length > 0) {
        const first = hits[0];
        const last = hits[hits.length - 1];
        
        // Scroll to first span
        first.scrollIntoView({ behavior: "smooth", block: "center" });

        // Create selection range that selects the full sentence
        try {
          // Find first text node in first span
          let firstTextNode = first.firstChild;
          while (firstTextNode && firstTextNode.nodeType !== Node.TEXT_NODE) {
            firstTextNode = firstTextNode.firstChild;
          }
          
          // Find first text node in last span
          let lastTextNode = last.firstChild;
          while (lastTextNode && lastTextNode.nodeType !== Node.TEXT_NODE) {
            lastTextNode = lastTextNode.firstChild;
          }
          
          if (firstTextNode && lastTextNode) {
            const range = document.createRange();
            range.setStart(firstTextNode, 0);
            range.setEnd(lastTextNode, lastTextNode.textContent.length);
            
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          }
        } catch (e) {
          // Fallback: select all spans
          try {
            const range = document.createRange();
            range.setStartBefore(first);
            range.setEndAfter(last);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          } catch (e2) {}
        }

        if (markedPreview) markedPreview.focus();

        if (statusDivOptional) {
          statusDivOptional.textContent = "Highlighted the sentence in the preview. Paste your rewrite to replace it.";
        }
        return { ok: true, hits: hits, blockEl: blockEl, used: used };
      }

      // Only now do paragraph fallback
      console.debug("[FindPreview fallback]", {
        label: example?.label,
        paragraph_index: example?.paragraph_index,
        sentence: example?.sentence,
        normSentence: normalizeForMatch(example?.sentence || "").slice(0, 200),
        normBlock: normalizeForMatch(blockEl?.innerText || "").slice(0, 200),
      });
      blockEl.classList.add("vysti-preview-hit-block");
      blockEl.scrollIntoView({ behavior: "smooth", block: "center" });
      if (markedPreview) markedPreview.focus();
      if (statusDivOptional) {
        statusDivOptional.textContent = "Found the paragraph, but couldn't isolate the exact sentence. You can still paste manually.";
      }
      return { ok: true, hits: [], blockEl: blockEl, used: "paragraph" };
    }

    function removeIssueFromPreview(label, example, statusDiv, removeBtn) {
      if (markedPreviewCard.style.display === "none" || !markedPreview || !markedPreview.innerText.trim()) {
        statusDiv.textContent = "Click \"Mark my essay\" to load the preview first.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      if (!confirm("Remove this issue label + highlight from the preview?")) {
        return;
      }

      const result = highlightAndScrollToExample(example, null);
      if (!result.ok || !result.hits || result.hits.length === 0) {
        statusDiv.textContent = "Couldn't isolate the exact sentence in preview. Try Find in preview first.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      const blockEl = result.blockEl;
      const labelText = `→ ${label}`;
      const normalizeWhitespace = (text) => (text || "").replace(/\s+/g, " ").trim();
      const arrowCandidates = Array.from(blockEl.querySelectorAll("span, a"))
        .filter(el => {
          const text = normalizeWhitespace(el.textContent);
          return text.startsWith("→") && text.includes(label);
        });

      if (arrowCandidates.length === 0) {
        statusDiv.textContent = "Couldn't find the issue label in the preview.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      let selectedLabelEl = arrowCandidates[0];
      try {
        const range = document.createRange();
        range.setStartBefore(result.hits[0]);
        range.setEndAfter(result.hits[result.hits.length - 1]);
        const intersecting = arrowCandidates.find(el => range.intersectsNode(el));
        if (intersecting) {
          selectedLabelEl = intersecting;
        } else {
          const firstHitRect = result.hits[0].getBoundingClientRect();
          let closest = arrowCandidates[0];
          let closestDist = Number.POSITIVE_INFINITY;
          arrowCandidates.forEach(el => {
            const rect = el.getBoundingClientRect();
            const dist = Math.abs(rect.top - firstHitRect.top);
            if (dist < closestDist) {
              closest = el;
              closestDist = dist;
            }
          });
          selectedLabelEl = closest;
        }
      } catch (e) {
        selectedLabelEl = arrowCandidates[0];
      }

      let removalTarget = selectedLabelEl;
      if (selectedLabelEl.parentElement && selectedLabelEl.parentElement.tagName === "SPAN") {
        const parentText = normalizeWhitespace(selectedLabelEl.parentElement.textContent);
        const childText = normalizeWhitespace(selectedLabelEl.textContent);
        if (parentText === childText) {
          removalTarget = selectedLabelEl.parentElement;
        }
      }

      if (normalizeWhitespace(removalTarget.textContent) !== normalizeWhitespace(labelText)) {
        // Still remove the best label match to avoid leaving the arrow label behind.
      }

      const hasInlineHighlight = (el) => {
        if (!el || el.nodeType !== Node.ELEMENT_NODE) return false;
        if (el.style && (el.style.backgroundColor || el.style.background)) return true;
        return !!el.querySelector("*[style*='background']");
      };

      const clearInlineHighlight = (el) => {
        if (!el || el.nodeType !== Node.ELEMENT_NODE) return;
        if (el.style) {
          el.style.backgroundColor = "";
          el.style.background = "";
        }
        el.querySelectorAll("*").forEach(child => {
          if (child.style) {
            child.style.backgroundColor = "";
            child.style.background = "";
          }
        });
      };

      let sibling = removalTarget.previousSibling;
      while (sibling) {
        if (sibling.nodeType !== Node.ELEMENT_NODE) break;
        const el = sibling;
        if (!hasInlineHighlight(el)) break;
        clearInlineHighlight(el);
        sibling = sibling.previousSibling;
      }

      removalTarget.remove();

      clearPreviewHighlights();
      if (markedPreview) markedPreview.normalize();

      statusDiv.textContent = "Removed from preview. (This may come back after Recheck unless you change the text.)";
      statusDiv.className = "rewrite-status visible ok";
      removeBtn.disabled = true;

      const exampleRow = removeBtn.closest(".example-item");
      if (exampleRow) {
        exampleRow.classList.add("example-dismissed");
      }
    }

    async function checkRewrite(label, example, textarea, statusDiv) {
      const rewrite = textarea.value.trim();
      if (!rewrite) {
        statusDiv.textContent = "Please enter a rewrite first.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        statusDiv.textContent = "You must be logged in.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      statusDiv.textContent = "Checking...";
      statusDiv.className = "rewrite-status visible";
      statusDiv.classList.remove("ok", "bad");

      try {
        const API_BASE = "https://vysti-rules.onrender.com";
        const currentMode = modeSelect ? modeSelect.value : "textual_analysis";
        const response = await fetch(`${API_BASE}/revision/check`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${sessionData.session.access_token}`,
          },
          body: JSON.stringify({
            label: label,
            rewrite: rewrite,
            mode: currentMode,
          }),
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(`HTTP ${response.status}: ${text.substring(0, 100)}`);
        }

        const result = await response.json();
        const ok = !!result.approved;
        statusDiv.textContent = result.message || (ok ? "Revision approved." : "Looks like we still have an issue.");
        statusDiv.className = `rewrite-status visible ${ok ? "ok" : "bad"}`;
        
        // Store approved rewrite and enable Apply button
        if (ok) {
          const exampleRow = statusDiv.closest(".example-item");
          if (exampleRow) {
            exampleRow.dataset.approvedRewrite = rewrite;
            const applyBtn = exampleRow.querySelector(".apply-to-preview-btn");
            if (applyBtn) {
              applyBtn.disabled = false;
            }
          }
        }
      } catch (error) {
        console.error("Error checking rewrite:", error);
        statusDiv.textContent = `Error: ${error.message}`;
        statusDiv.className = "rewrite-status visible bad";
      }
    }

    function applyRewriteToPreview(example, exampleRow, statusDiv, applyBtn) {
      // Ensure preview exists
      if (markedPreviewCard.style.display === "none" || !markedPreview || !markedPreview.innerText.trim()) {
        statusDiv.textContent = "Click \"Mark my essay\" to load the preview first.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      // Get approved rewrite from dataset
      const rewriteText = exampleRow.dataset.approvedRewrite;
      if (!rewriteText) {
        statusDiv.textContent = "Please check and approve your rewrite first.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      // Find the sentence in preview
      const result = highlightAndScrollToExample(example, null);
      
      if (!result.ok || result.hits.length === 0) {
        statusDiv.textContent = "Couldn't isolate the exact sentence in preview — please paste manually.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      // Replace the matched range with the approved rewrite
      try {
        const first = result.hits[0];
        const last = result.hits[result.hits.length - 1];
        const range = document.createRange();
        range.setStartBefore(first);
        range.setEndAfter(last);
        range.deleteContents();

        // Insert rewrite as a styled span so it doesn't inherit UI fonts
        const rewriteSpan = document.createElement("span");
        rewriteSpan.className = "vysti-applied-rewrite";
        rewriteSpan.textContent = rewriteText;

        range.insertNode(rewriteSpan);

        // Move caret after inserted rewrite (nice UX, avoids weird selection states)
        range.setStartAfter(rewriteSpan);
        range.collapse(true);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);

        // Normalize to merge any split text nodes after DOM surgery
        if (markedPreview) markedPreview.normalize();
        
        // Clear any leftover highlight styling
        clearPreviewHighlights();
        
        // Update UI
        statusDiv.textContent = "✅ Applied to preview.";
        statusDiv.className = "rewrite-status visible ok";
        applyBtn.disabled = true;
        
        // Mark example as applied
        exampleRow.classList.add("example-applied");
        
        // Show recheck button if hidden
        const recheckBtn = document.getElementById("recheckDocumentBtn");
        if (recheckBtn) {
          recheckBtn.style.display = "block";
        }
      } catch (error) {
        console.error("Error applying rewrite:", error);
        statusDiv.textContent = "Error applying rewrite. Please paste manually.";
        statusDiv.className = "rewrite-status visible bad";
      }
    }

    function downloadRevisionNotes(label, examples) {
      const textareas = document.querySelectorAll(".example-rewrite");
      let content = `Revision Notes: ${label}\n\n`;
      
      examples.forEach((ex, idx) => {
        content += `Example ${idx + 1}:\n`;
        content += `Original: ${ex.sentence || ""}\n`;
        const rewrite = textareas[idx]?.value || "";
        if (rewrite) {
          content += `Your rewrite: ${rewrite}\n`;
        }
        content += `\n`;
      });
      
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `revision_notes_${label.replace(/\s+/g, "_")}.txt`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Word count target input listener
    if (targetWordCountInput) {
      targetWordCountInput.addEventListener("input", updateWordCountUI);
    }

    // Recheck document button handler
    if (recheckDocumentBtn) {
      recheckDocumentBtn.addEventListener("click", async () => {
        if (!selectedFile || !markedPreview) {
          return;
        }

        // Extract current preview text in a paragraph-preserving way
        const previewText = extractPreviewText();
        if (!previewText) {
          statusArea.textContent = "Could not extract text from preview.";
          statusArea.className = "status-area error";
          if (resultsCard) resultsCard.style.display = "block";
          return;
        }

        // Get session
        const { data: sessionData } = await supa.auth.getSession();
        if (!sessionData || !sessionData.session) {
          statusArea.textContent = "You must be logged in.";
          statusArea.className = "status-area error";
          if (resultsCard) resultsCard.style.display = "block";
          return;
        }

        // Update UI
        statusArea.textContent = "Rechecking document...";
        statusArea.className = "status-area";
        startButtonLoading(recheckDocumentBtn, "Recheck my essay");

        try {
          // Collect title metadata (same as initial /mark flow)
          const author = document.getElementById("author")?.value.trim() || "";
          const title = document.getElementById("title")?.value.trim() || "";
          const titleIsMinorSelect = document.getElementById("title_is_minor");
          const textIsMinorWork = titleIsMinorSelect ? titleIsMinorSelect.value : "true";
          
          // Work 2
          const author2 = document.getElementById("author2")?.value.trim() || "";
          const title2 = document.getElementById("title2")?.value.trim() || "";
          const title2IsMinorSelect = document.getElementById("title2_is_minor");
          const title2IsMinor = title2IsMinorSelect ? title2IsMinorSelect.value : "true";
          
          // Work 3
          const author3 = document.getElementById("author3")?.value.trim() || "";
          const title3 = document.getElementById("title3")?.value.trim() || "";
          const title3IsMinorSelect = document.getElementById("title3_is_minor");
          const title3IsMinor = title3IsMinorSelect ? title3IsMinorSelect.value : "true";
          
          // Build titles array
          const titles = [];
          if (title) {
            titles.push({
              author: author,
              title: title,
              is_minor: textIsMinorWork === "true"
            });
          }
          if (title2) {
            titles.push({
              author: author2,
              title: title2,
              is_minor: title2IsMinor === "true"
            });
          }
          if (title3) {
            titles.push({
              author: author3,
              title: title3,
              is_minor: title3IsMinor === "true"
            });
          }
          
          const API_BASE = "https://vysti-rules.onrender.com";
          const currentMode = modeSelect ? modeSelect.value : "textual_analysis";
          const response = await fetch(`${API_BASE}/mark_text`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${sessionData.session.access_token}`,
            },
            body: JSON.stringify({
              file_name: selectedFile.name,
              text: previewText,
              mode: currentMode,
              titles: titles.length > 0 ? titles : null,
            }),
          });

          if (!response.ok) {
            const text = await response.text();
            throw new Error(`HTTP ${response.status}: ${text.substring(0, 100)}`);
          }

          const blob = await response.blob();
          markedBlob = blob;
          downloadUrl = URL.createObjectURL(blob);

          // Replace the preview with the returned docx blob
          markedPreview.innerHTML = "";
          const buf = await blob.arrayBuffer();
          if (typeof docx !== "undefined" && docx.renderAsync) {
            await docx.renderAsync(buf, markedPreview, null, { inWrapper: true });
            markedPreview.contentEditable = "true";
            markedPreview.spellcheck = true;
            markedPreview.classList.add("preview-editable");
          } else {
            markedPreview.innerHTML = "<p>Preview not available. Please download the file to view.</p>";
          }

          // Reload revision practice to refresh issues + examples
          await loadRevisionPractice();

          statusArea.textContent = "Document rechecked. Preview updated.";
          statusArea.className = "status-area success";
        } catch (error) {
          console.error("Error rechecking document:", error);
          statusArea.textContent = `Error: ${error.message}`;
          statusArea.className = "status-area error";
        } finally {
          stopButtonLoading(
            recheckDocumentBtn,
            () => !!selectedFile && !!markedPreview && !!markedPreview.innerHTML.trim()
          );
        }
      });
    }

    function extractPreviewText() {
      if (!markedPreview) return null;
      
      // Collect all <p> and <li> in preview container and join with \n\n
      const paragraphs = [];
      const elements = markedPreview.querySelectorAll("p, li");
      
      for (const el of elements) {
        // Use clean extraction that excludes Vysti artifacts
        const text = extractCleanTextFromElement(el);
        if (text) {
          paragraphs.push(text);
        }
      }
      
      // If no paragraphs found, try getting all text (also clean)
      if (paragraphs.length === 0) {
        const allText = extractCleanTextFromElement(markedPreview);
        if (allText) {
          return allText;
        }
        return null;
      }
      
      return paragraphs.join("\n\n");
    }

    // Initial state
    updateFileUI();
  </script>
</body>
</html>
