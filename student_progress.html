<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vysti Marker – Analytics Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/marker.css">
  
  <!-- Supabase JS client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  
  <style>
    .progress-page {
      max-width: 1400px;
      margin: 0 auto;
      padding: 24px 18px 40px;
    }
    
    .filters-section {
      background: var(--card);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 24px;
      box-shadow: 0 2px 4px rgba(0,0,0,.08);
    }
    
    .filters-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    
    .filter-group {
      display: flex;
      flex-direction: column;
    }
    
    .filter-group label {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--text);
    }
    
    .range-selector {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    
    .range-btn {
      padding: 6px 12px;
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    .range-btn:hover {
      background: rgba(169,13,34,.05);
      border-color: var(--maroon);
    }
    
    .range-btn.active {
      background: var(--maroon);
      color: #fff;
      border-color: var(--maroon);
    }
    
    .range-custom {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 8px;
    }
    
    .range-custom input {
      width: 80px;
      height: 32px;
      padding: 0 8px;
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 8px;
      font-size: 13px;
    }
    
    .duplicates-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 12px;
    }
    
    .duplicates-toggle input[type="checkbox"] {
      width: 44px;
      height: 24px;
      appearance: none;
      border-radius: 12px;
      background: #BCC1CA;
      position: relative;
      cursor: pointer;
    }
    
    .duplicates-toggle input[type="checkbox"]::before {
      content: "";
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: #fff;
      transition: transform .15s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,.18);
    }
    
    .duplicates-toggle input[type="checkbox"]:checked {
      background: var(--maroon);
    }
    
    .duplicates-toggle input[type="checkbox"]:checked::before {
      transform: translateX(20px);
    }
    
    .bucket-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      max-width: 520px;
      margin-top: 8px;
    }
    
    .bucket-checkboxes label {
      display: flex;
      gap: 6px;
      align-items: center;
      font-size: 0.9rem;
      cursor: pointer;
      font-weight: normal;
    }
    
    .bucket-checkboxes input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    
    .bucket-actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }
    
    .bucket-actions button {
      padding: 6px 12px;
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    .bucket-actions button:hover {
      background: rgba(169,13,34,.05);
      border-color: var(--maroon);
    }
    
    .charts-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      margin-bottom: 24px;
    }
    
    @media (max-width: 980px) {
      .charts-section {
        grid-template-columns: 1fr;
      }
    }
    
    .chart-card {
      background: var(--card);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,.08);
    }
    
    .chart-card h3 {
      margin: 0 0 16px;
      font-size: 18px;
      font-weight: 600;
    }
    
    .chart-container {
      position: relative;
      height: 300px;
    }
    
    .table-section {
      background: var(--card);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,.08);
    }
    
    .table-section h3 {
      margin: 0 0 16px;
      font-size: 18px;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .export-btn {
      padding: 8px 16px;
      border: 1px solid var(--maroon);
      border-radius: 8px;
      background: var(--maroon);
      color: #fff;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .export-btn:hover {
      filter: brightness(.95);
    }
    
    .delete-btn {
      padding: 6px 12px;
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
      color: var(--text);
    }

    .delete-btn:hover {
      background: rgba(169,13,34,.05);
      border-color: var(--maroon);
    }

    .delete-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    
    thead {
      background: #f5f6f8;
    }
    
    th, td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid rgba(0,0,0,.08);
    }
    
    th {
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      color: var(--muted);
    }
    
    tbody tr:hover {
      background: rgba(169,13,34,.02);
    }
    
    .nowrap {
      white-space: nowrap;
    }
    
    .status-message {
      padding: 12px;
      background: rgba(169,13,34,.05);
      border-radius: 8px;
      margin-bottom: 16px;
      font-size: 13px;
      color: var(--text);
    }
    
    /* Print header styles */
    .print-header {
      display: none;
    }
    
    .print-title {
      margin-bottom: 16px;
    }
    
    .print-title h1 {
      margin: 0 0 8px;
      font-size: 24px;
      font-weight: 700;
      color: var(--text);
    }
    
    .print-generated {
      font-size: 12px;
      color: var(--muted);
    }
    
    .print-meta {
      font-size: 13px;
      color: var(--text);
      line-height: 1.6;
    }
    
    .print-meta > div {
      margin-bottom: 4px;
    }
    
    /* Print styles */
    @media print {
      .print-header {
        display: block;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 2px solid rgba(0,0,0,.1);
      }
      
      header.topbar {
        display: none !important;
      }
      
      .filters-section {
        display: none !important;
      }
      
      .export-btn {
        display: none !important;
      }
      
      body {
        background: white !important;
      }
      
      .progress-page {
        background: white !important;
      }
      
      .chart-card,
      .table-section {
        background: white !important;
        box-shadow: none !important;
        border: 1px solid rgba(0,0,0,.1) !important;
      }
      
      .charts-section,
      .chart-card,
      .table-section {
        break-inside: avoid;
        page-break-inside: avoid;
      }
      
      * {
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }
      
      @page {
        margin: 16mm;
      }
    }
    
    body.printing {
      background: white;
    }
    
    body.printing .progress-page {
      background: white;
    }
    
    /* Examples Modal Styles */
    .examples-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .examples-modal {
      background: var(--card);
      border-radius: 12px;
      max-width: 900px;
      width: 90%;
      max-height: 75vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }
    
    .examples-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 20px 24px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .examples-modal-bucket {
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .examples-modal-label {
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
    }
    
    .examples-modal-close {
      background: none;
      border: none;
      font-size: 28px;
      line-height: 1;
      color: var(--muted);
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .examples-modal-close:hover {
      background: rgba(0, 0, 0, 0.05);
      color: var(--text);
    }
    
    .examples-modal-actions {
      padding: 12px 24px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .examples-copy-all-btn {
      padding: 8px 16px;
      border: 1px solid var(--maroon);
      border-radius: 8px;
      background: var(--maroon);
      color: #fff;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .examples-copy-all-btn:hover {
      filter: brightness(.95);
    }
    
    .examples-modal-content {
      padding: 20px 24px;
      overflow-y: auto;
      flex: 1;
    }
    
    .example-item {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.08);
    }
    
    .example-item:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    
    .example-student-info {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .example-student-name {
      font-weight: 700;
      color: var(--text);
      font-size: 14px;
    }
    
    .example-assignment-name {
      font-size: 13px;
      color: var(--muted);
    }
    
    .example-sentence {
      background: #f5f6f8;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 8px;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 14px;
      line-height: 1.5;
      color: var(--text);
      border: 1px solid rgba(0, 0, 0, 0.08);
    }
    
    .example-copy-btn {
      padding: 6px 12px;
      border: 1px solid rgba(0, 0, 0, 0.14);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
      color: var(--text);
    }
    
    .example-copy-btn:hover {
      background: rgba(169,13,34,.05);
      border-color: var(--maroon);
    }
    
    .examples-loading {
      text-align: center;
      padding: 40px;
      color: var(--muted);
    }
    
    .examples-empty {
      text-align: center;
      padding: 40px;
      color: var(--muted);
    }
    
    .examples-issue-select {
      height: 34px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #fff;
      padding: 0 10px;
      font-size: 13px;
      font-weight: 600;
      max-width: 320px;
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <img src="/assets/logo.svg" alt="Vysti" />
    </div>
    
    <nav>
      <a href="/student.html">Student Check</a>
      <a href="/student_progress.html" class="active">Progress</a>
    </nav>
    
    <div class="actions">
      <button class="iconbtn" type="button" title="Notifications" aria-label="Notifications"></button>
      <img class="avatar" src="/assets/avatar.png" alt="Profile" />
      <button class="topbar-btn" id="logoutBtn" type="button">Sign Out</button>
    </div>
  </header>

  <main class="page">
    <div class="progress-page" id="progressPage" style="display:none;">
      <div id="printHeader" class="print-header" aria-hidden="true">
        <div class="print-title">
          <h1>Vysti Progress Report</h1>
          <div id="printGeneratedAt" class="print-generated"></div>
        </div>
        <div id="printMeta" class="print-meta"></div>
      </div>
      
      <div class="filters-section">
        <h2 style="margin: 0 0 16px; font-size: 20px; font-weight: 600;">Filters</h2>
        
        <div class="filters-grid">
          
          <div class="filter-group">
            <label for="seriesFilter">Assignment Series</label>
            <select id="seriesFilter">
              <option value="">All Series</option>
            </select>
          </div>
          
          <div class="filter-group">
            <label>Assignment Range</label>
            <div class="range-selector">
              <button class="range-btn" data-range="first">First</button>
              <button class="range-btn" data-range="latest">Latest</button>
              <button class="range-btn active" data-range="all">All</button>
            </div>
            <div class="range-custom">
              <input type="number" id="rangeStart" placeholder="Start" min="1" />
              <span>to</span>
              <input type="number" id="rangeEnd" placeholder="End" min="1" />
            </div>
          </div>
        </div>
        
        <div class="duplicates-toggle">
          <input type="checkbox" id="includeDuplicates" />
          <label for="includeDuplicates" style="margin: 0; font-size: 13px; font-weight: 600;">Include repeated submissions</label>
        </div>
        
        <div class="filter-group" style="margin-top: 20px;">
          <label>Buckets</label>
          <div class="bucket-checkboxes" id="bucketCheckboxes"></div>
          <div class="bucket-actions">
            <button type="button" id="bucketSelectAll">All</button>
            <button type="button" id="bucketClear">None</button>
          </div>
        </div>
      </div>
      
      <div id="statusMessage" class="status-message" style="display:none;"></div>
      
      <div class="charts-section">
        <div class="chart-card" id="examplesPanelCard">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px;">
            <h3 style="margin:0;">Examples of Issues</h3>
            <div style="display:flex; gap:10px; align-items:center;">
              <select id="examplesIssueSelect" class="examples-issue-select" style="display:none;"></select>
              <button class="examples-copy-all-btn" id="examplesPanelCopyBtn" style="display:none;">Create revision assignment</button>
            </div>
          </div>

          <div id="examplesPanelMeta" style="margin-bottom:10px;">
            <div class="examples-modal-bucket" id="examplesPanelBucket"></div>
            <div class="examples-modal-label" id="examplesPanelLabel"></div>
            <div style="margin-top:8px; color: var(--muted); font-size: 13px; font-weight:600;" id="examplesPanelBestWorst"></div>
          </div>

          <div class="chart-container" style="height:300px;">
            <div id="examplesPanelContent" style="height:100%; overflow:auto;">
              <div class="examples-empty">Select an issue from the dropdown above to view examples.</div>
            </div>
          </div>
        </div>
        
        <div class="chart-card">
          <h3>Most Common Issues</h3>
          <div class="chart-container">
            <canvas id="barChart"></canvas>
          </div>
        </div>
      </div>
      
      <div class="chart-card" style="margin-bottom: 24px;">
        <h3>Progress by Category</h3>
        <div class="chart-container">
          <canvas id="bucketChart"></canvas>
        </div>
      </div>
      
      <div class="table-section">
        <h3>
          <span>Data Table</span>
          <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
            <button class="export-btn" id="exportPdfBtn">Export PDF</button>
            <button class="export-btn" id="exportBtn">Export CSV</button>

            <div style="width:1px; height:24px; background: rgba(0,0,0,.12); margin:0 6px;"></div>

            <button class="delete-btn" id="deleteSelectedBtn" disabled>Delete selected</button>
            <button class="delete-btn" id="checkAllBtn" type="button">Check all</button>
            <button class="delete-btn" id="clearChecksBtn" type="button">Clear checks</button>
            <span id="selectedCountText" style="font-size:12px; color: var(--muted); font-weight:600;">0 selected</span>
          </div>
        </h3>
        <table>
          <thead>
            <tr>
              <th class="nowrap">
                <input type="checkbox" id="selectAllRows" aria-label="Check all rows" />
              </th>
              <th class="nowrap">Date</th>
              <th>Assignment</th>
              <th>Mode</th>
              <th class="nowrap">Total Labels</th>
              <th>Label Counts</th>
              <th class="nowrap">Actions</th>
            </tr>
          </thead>
          <tbody id="dataTableBody">
            <!-- rows injected by JS -->
          </tbody>
        </table>
      </div>
    </div>
  </main>

  <!-- Examples Modal -->
  <div id="examplesModal" class="examples-modal-overlay" style="display: none;">
    <div class="examples-modal">
      <div class="examples-modal-header">
        <div>
          <div class="examples-modal-bucket" id="modalBucketName"></div>
          <div class="examples-modal-label" id="modalLabel"></div>
        </div>
        <button class="examples-modal-close" id="modalCloseBtn" aria-label="Close">×</button>
      </div>
      <div class="examples-modal-actions">
        <button class="examples-copy-all-btn" id="copyAllBtn">Copy all</button>
      </div>
      <div class="examples-modal-content" id="modalContent">
        <!-- Examples will be rendered here -->
      </div>
    </div>
  </div>

  <script>
    // ===== Bucket definitions =====
    const LABEL_BUCKETS = [
      {
        id: "thesis_org",
        name: "Thesis & Organization",
        matchers: [
          /thesis/i,
          /topic sentence/i,
          /organization/i,
          /transition/i,
          /boundary statement/i,
          /introduction/i,
          /conclusion/i,
          /paragraph/i,
          /structure/i
        ]
      },
      {
        id: "evidence_integration",
        name: "Evidence & Integration",
        matchers: [
          /quote/i,
          /quotation/i,
          /evidence/i,
          /citation/i,
          /\bcite\b/i,
          /works cited/i,
          /power verbs/i,
          /support/i
        ]
      },
      {
        id: "voice_audience",
        name: "Voice & Audience",
        matchers: [
          /personal pronoun/i,
          /\bI\b/i,
          /\bwe\b/i,
          /\byou\b/i,
          /reader/i,
          /audience/i
        ]
      },
      {
        id: "style_clarity",
        name: "Style & Clarity",
        matchers: [
          /contraction/i,
          /\bwhich\b/i,
          /\bfact\b/i,
          /\bprove\b/i,
          /weak verb/i,
          /vague/i,
          /people/i,
          /human/i,
          /word choice/i,
          /avoid using the word/i,
          /more than once in a sentence/i
        ]
      },
      {
        id: "grammar_mechanics",
        name: "Grammar & Mechanics",
        matchers: [
          /subject[- ]verb/i,
          /agreement/i,
          /tense/i,
          /comma/i,
          /punctuation/i,
          /spelling/i,
          /apostrophe/i
        ]
      },
      {
        id: "formatting",
        name: "Formatting & Conventions",
        matchers: [
          /MLA/i,
          /header/i,
          /format/i,
          /title/i,
          /author/i
        ]
      },
      { id: "other", name: "Other", matchers: [] }
    ];

    const BUCKET_OVERRIDES = {
      "Avoid quotations in the conclusion": "evidence_integration",
      "Avoid quotations in the introduction": "evidence_integration",
      "Clarify pronouns and antecedents": "grammar_mechanics",
      "Avoid weak verbs": "evidence_integration"
    };
    
    // ===== Label Canonicalization =====
    // Canonical label groups: maps aliases to canonical display label
    const LABEL_CANONICAL_GROUPS = {
      "Avoid weak verbs": [
        "Refer to the Power Verbs list",
        "Refer to the Power Verbs List",
        "Avoid weak verbs"
      ]
    };
    
    // Helper: normalize label string (lowercase + trim)
    function normalizeLabel(s) {
      if (!s) return "";
      return String(s).toLowerCase().trim();
    }
    
    // Helper: get canonical label for a given label
    function canonicalLabel(label) {
      if (!label) return label;
      const normalized = normalizeLabel(label);
      
      // Check each canonical group
      for (const [canonical, aliases] of Object.entries(LABEL_CANONICAL_GROUPS)) {
        const normalizedAliases = aliases.map(normalizeLabel);
        if (normalizedAliases.includes(normalized)) {
          return canonical;
        }
      }
      
      return label; // Return original if no canonical found
    }
    
    // Helper: get all aliases (including canonical) for a canonical label
    function labelAliasesForQuery(canonical) {
      if (!canonical) return [canonical];
      const group = LABEL_CANONICAL_GROUPS[canonical];
      if (group) {
        return [...group]; // Return all aliases including canonical
      }
      return [canonical]; // Return just the label if no group
    }
    
    // Helper: get display label (canonicalized)
    function displayLabel(label) {
      return canonicalLabel(label);
    }

    function totalLabelsFromCounts(obj) {
      if (!obj || typeof obj !== "object") return 0;
      return Object.values(obj).reduce((s, v) => s + (Number(v) || 0), 0);
    }

    function assignmentDisplay(row) {
      return row.assignment_name || row.file_name || "—";
    }

    // Shared bucket color palette (same order as LABEL_BUCKETS)
    // Thesis maroon, Evidence blue, Voice green, Style yellow, Grammar purple, Formatting red, Other teal
    const BUCKET_COLORS = [
      "rgba(169, 13, 34, 1)",    // maroon - Thesis & Organization
      "rgba(52, 152, 219, 1)",   // blue - Evidence & Integration
      "rgba(46, 204, 113, 1)",   // green - Voice & Audience
      "rgba(241, 196, 15, 1)",   // yellow - Style & Clarity
      "rgba(155, 89, 182, 1)",   // purple - Grammar & Mechanics
      "rgba(231, 76, 60, 1)",    // red - Formatting & Conventions
      "rgba(26, 188, 156, 1)",   // teal - Other
    ];

    // Helper function to get bucket color by bucketId
    // Returns color with specified alpha (default 1.0 for full opacity)
    function getBucketColor(bucketId, alpha = 1.0) {
      const bucketIndex = LABEL_BUCKETS.findIndex(b => b.id === bucketId);
      if (bucketIndex === -1) {
        // Fallback to "other" color if bucket not found
        const otherIndex = LABEL_BUCKETS.findIndex(b => b.id === "other");
        const baseColor = BUCKET_COLORS[otherIndex >= 0 ? otherIndex : BUCKET_COLORS.length - 1];
        return baseColor.replace("1)", `${alpha})`);
      }
      const baseColor = BUCKET_COLORS[bucketIndex];
      return baseColor.replace("1)", `${alpha})`);
    }

    function getBucketIdForLabel(label) {
      if (!label) return "other";
      if (BUCKET_OVERRIDES[label]) return BUCKET_OVERRIDES[label];
      for (const b of LABEL_BUCKETS) {
        if (b.id === "other") continue;
        if (b.matchers.some(rx => rx.test(label))) return b.id;
      }
      return "other";
    }

    // ===== Supabase config =====
    const SUPABASE_URL = "https://divdfodsdtfbdwoqvsfy.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRpdmRmb2RzZHRmYmR3b3F2c2Z5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU0MjU1OTksImV4cCI6MjA4MTAwMTU5OX0.fnm_9qX5DqdR0j6y-2mRRkwr8Icm1uRNPbUo6lqzock";
    
    const { createClient } = supabase;
    const supa = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    
    const progressPage = document.getElementById("progressPage");
    const logoutBtn = document.getElementById("logoutBtn");
    const seriesFilter = document.getElementById("seriesFilter");
    const rangeBtns = document.querySelectorAll(".range-btn");
    const rangeStart = document.getElementById("rangeStart");
    const rangeEnd = document.getElementById("rangeEnd");
    const includeDuplicates = document.getElementById("includeDuplicates");
    const statusMessage = document.getElementById("statusMessage");
    const dataTableBody = document.getElementById("dataTableBody");
    const exportBtn = document.getElementById("exportBtn");
    const selectedFileNames = new Set();
    const selectAllRows = document.getElementById("selectAllRows");
    const deleteSelectedBtn = document.getElementById("deleteSelectedBtn");
    const checkAllBtn = document.getElementById("checkAllBtn");
    const clearChecksBtn = document.getElementById("clearChecksBtn");
    const selectedCountText = document.getElementById("selectedCountText");
    
    let allData = [];
    let filteredData = [];
    let lineChart = null;
    let barChart = null;
    let bucketChart = null;
    let currentRange = "all";
    // ===== Auth =====
    async function refreshAuthUI() {
      const { data } = await supa.auth.getSession();
      const session = data.session;
      
      if (!session) {
        window.location.replace("/signin.html");
        return;
      }
      
      progressPage.style.display = "block";
      loadData();
    }
    
    logoutBtn.addEventListener("click", async () => {
      await supa.auth.signOut();
      localStorage.removeItem("vysti_role");
      window.location.replace("/signin.html");
    });
    
    supa.auth.onAuthStateChange((_event, _session) => {
      refreshAuthUI();
    });
    
    // ===== Assignment name parsing =====
    
    // Normalize series string to a stable key for comparison
    // - Lowercase
    // - Remove spaces/underscores/hyphens and other non-alphanumerics
    // - Expand trailing "hw" -> "homework" (so "advancedhw" becomes "advancedhomework")
    function normalizeSeriesKey(seriesRaw) {
      if (!seriesRaw) return "";
      let normalized = seriesRaw.toLowerCase();
      // Remove all non-alphanumeric characters
      normalized = normalized.replace(/[^a-z0-9]/g, "");
      // Expand trailing "hw" -> "homework" (but only if it's at the end with no preceding whitespace)
      // This handles "advancedhw" -> "advancedhomework" but not "hw02" (which would be "hw" + number)
      if (normalized.endsWith("hw") && normalized.length > 2) {
        normalized = normalized.slice(0, -2) + "homework";
      }
      return normalized;
    }
    
    // Create human-readable display string for series
    // - Trim, collapse whitespace
    // - If the raw series ends with "HW" with no preceding whitespace, convert "...HW" -> "... Homework"
    function seriesDisplay(seriesRaw) {
      if (!seriesRaw) return "";
      // Trim and collapse whitespace
      let display = seriesRaw.trim().replace(/\s+/g, " ");
      // If it ends with "HW" (case-insensitive, no space before it), expand to " Homework"
      // Match pattern like "AdvancedHW" but not "Advanced HW" or just "HW"
      if (display.length > 2 && /[A-Za-z]HW$/i.test(display)) {
        // Replace trailing "HW" (case-insensitive) with " Homework"
        display = display.replace(/HW$/i, " Homework");
      }
      return display;
    }
    
    function parseAssignmentName(name) {
      if (!name) return { seriesRaw: "", seriesDisplay: "", seriesKey: "", number: null, original: name };
      
      // Extract trailing number for natural numeric sort
      // Handles: "Foundation HW06", "HW02", "Foundation 3", "High Level HW11", etc.
      const numMatch = name.match(/(\d+)$/);
      if (numMatch) {
        const number = parseInt(numMatch[1], 10);
        // Extract series (everything before the trailing number)
        const seriesMatch = name.match(/^(.+?)\s*\d+$/);
        const seriesRaw = seriesMatch ? seriesMatch[1].trim() : "";
        
        return {
          seriesRaw: seriesRaw,
          seriesDisplay: seriesDisplay(seriesRaw),
          seriesKey: normalizeSeriesKey(seriesRaw),
          number: number,
          original: name
        };
      }
      
      // Fallback: try to match pattern like "Foundation 3" at the start
      const match = name.match(/^([A-Za-z]+)\s*(\d+)/);
      if (match) {
        const seriesRaw = match[1];
        return {
          seriesRaw: seriesRaw,
          seriesDisplay: seriesDisplay(seriesRaw),
          seriesKey: normalizeSeriesKey(seriesRaw),
          number: parseInt(match[2], 10),
          original: name
        };
      }
      
      return { seriesRaw: "", seriesDisplay: "", seriesKey: "", number: null, original: name };
    }
    
    // ===== Data loading =====
    async function loadData() {
      statusMessage.style.display = "block";
      statusMessage.textContent = "Loading data...";

      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        window.location.replace("/signin.html");
        return;
      }

      let query = supa
        .from("mark_events")
        .select("created_at, assignment_name, file_name, mode, label_counts, issues")
        .eq("user_id", sessionData.session.user.id);

      const { data, error } = await query.order("created_at", { ascending: false });

      if (error) {
        statusMessage.textContent = `Error loading data: ${error.message}`;
        return;
      }

      if (!data || data.length === 0) {
        statusMessage.textContent = "No data found.";
        allData = [];
        filteredData = [];
        updateUI();
        return;
      }

      allData = data.map(row => ({
        ...row,
        assignment_display: assignmentDisplay(row),
        total_labels: totalLabelsFromCounts(row.label_counts)
      }));
      statusMessage.style.display = "none";

      updateFilters();
      buildBucketCheckboxes();
      applyFilters();
    }

    const deleteButtonsEnabled = true;

    function getVisibleUniqueFileNames() {
      const out = [];
      const seen = new Set();
      (filteredData || []).forEach((row) => {
        const f = (row.file_name || "").trim();
        if (!f) return;
        if (seen.has(f)) return;
        seen.add(f);
        out.push(f);
      });
      return out;
    }

    function syncBulkUI() {
      const visible = getVisibleUniqueFileNames();
      const selectedVisible = visible.filter(f => selectedFileNames.has(f));

      if (selectedCountText) selectedCountText.textContent = `${selectedFileNames.size} selected`;
      if (deleteSelectedBtn) deleteSelectedBtn.disabled = selectedFileNames.size === 0;

      if (!selectAllRows) return;
      if (visible.length === 0) {
        selectAllRows.checked = false;
        selectAllRows.indeterminate = false;
        selectAllRows.disabled = true;
        return;
      }
      selectAllRows.disabled = false;

      if (selectedVisible.length === 0) {
        selectAllRows.checked = false;
        selectAllRows.indeterminate = false;
      } else if (selectedVisible.length === visible.length) {
        selectAllRows.checked = true;
        selectAllRows.indeterminate = false;
      } else {
        selectAllRows.checked = false;
        selectAllRows.indeterminate = true;
      }
    }

    async function deleteDocumentsByFileNames(fileNames) {
      const list = (fileNames || []).map(s => String(s || "").trim()).filter(Boolean);
      const unique = Array.from(new Set(list));
      if (unique.length === 0) return;

      const ok = confirm(`Delete ${unique.length} document(s)? This removes all stored examples and progress for those file names. This cannot be undone.`);
      if (!ok) return;

      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        window.location.replace("/signin.html");
        return;
      }

      const userId = sessionData.session.user.id;

      statusMessage.style.display = "block";
      statusMessage.textContent = `Deleting ${unique.length} document(s)...`;

      const CHUNK = 20;

      try {
        for (let i = 0; i < unique.length; i += CHUNK) {
          const chunk = unique.slice(i, i + CHUNK);

          statusMessage.textContent = `Deleting ${Math.min(i + CHUNK, unique.length)}/${unique.length}...`;

          // 1) issue_examples first (avoid FK problems)
          const { error: exErr } = await supa
            .from("issue_examples")
            .delete()
            .eq("user_id", userId)
            .in("file_name", chunk);

          if (exErr) throw exErr;

          // 2) optional cleanup: dismissed feedback (ignore if table/policy missing)
          const fbRes = await supa
            .from("dismissed_issue_feedback")
            .delete()
            .eq("user_id", userId)
            .in("file_name", chunk);

          if (fbRes?.error) {
            console.warn("dismissed_issue_feedback delete failed (non-fatal):", fbRes.error);
          }

          // 3) mark_events
          const { error: evErr } = await supa
            .from("mark_events")
            .delete()
            .eq("user_id", userId)
            .in("file_name", chunk);

          if (evErr) throw evErr;
        }

        // Clear selections that were deleted
        unique.forEach(f => selectedFileNames.delete(f));
        syncBulkUI();

        statusMessage.textContent = `Deleted ${unique.length} document(s).`;
        setTimeout(() => { statusMessage.style.display = "none"; }, 1200);

        await loadData();
      } catch (err) {
        console.error("Bulk delete failed:", err);
        statusMessage.textContent =
          "Delete failed. Likely Row Level Security (RLS) is blocking deletes. Check console for details.";
      }
    }
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        window.location.replace("/signin.html");
        return;
      }

      const userId = sessionData.session.user.id;
      const { error: examplesError } = await supa
        .from("issue_examples")
        .delete()
        .eq("user_id", userId)
        .eq("file_name", fileName);

      if (examplesError) {
        alert(`Failed to delete examples: ${examplesError.message}`);
        return;
      }

      const { error: eventsError } = await supa
        .from("mark_events")
        .delete()
        .eq("user_id", userId)
        .eq("file_name", fileName);

      if (eventsError) {
        alert(`Failed to delete events: ${eventsError.message}`);
        return;
      }

      loadData();
    }

    // ===== Bucket selection =====
    function buildBucketCheckboxes() {
      const container = document.getElementById("bucketCheckboxes");
      container.innerHTML = "";
      
      const savedSelection = localStorage.getItem("vysti_bucket_selection");
      let selectedBuckets = [];
      if (savedSelection) {
        try {
          selectedBuckets = JSON.parse(savedSelection);
        } catch (e) {
          selectedBuckets = LABEL_BUCKETS.filter(b => b.id !== "other").map(b => b.id);
        }
      } else {
        // Default: select all except "other"
        selectedBuckets = LABEL_BUCKETS.filter(b => b.id !== "other").map(b => b.id);
      }
      
      LABEL_BUCKETS.forEach(bucket => {
        if (bucket.id === "other") return; // Skip "other" from UI
        
        const label = document.createElement("label");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = bucket.id;
        checkbox.checked = selectedBuckets.includes(bucket.id);
        checkbox.addEventListener("change", () => {
          saveBucketSelection();
          updateCharts();
        });
        
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(bucket.name));
        container.appendChild(label);
      });
    }
    
    function saveBucketSelection() {
      const selected = getSelectedBucketIds();
      localStorage.setItem("vysti_bucket_selection", JSON.stringify(selected));
    }
    
    function getSelectedBucketIds() {
      const checkboxes = document.querySelectorAll("#bucketCheckboxes input[type='checkbox']");
      return Array.from(checkboxes)
        .filter(cb => cb.checked)
        .map(cb => cb.value);
    }
    
    document.getElementById("bucketSelectAll").addEventListener("click", () => {
      const checkboxes = document.querySelectorAll("#bucketCheckboxes input[type='checkbox']");
      checkboxes.forEach(cb => cb.checked = true);
      saveBucketSelection();
      updateCharts();
    });
    
    document.getElementById("bucketClear").addEventListener("click", () => {
      const checkboxes = document.querySelectorAll("#bucketCheckboxes input[type='checkbox']");
      checkboxes.forEach(cb => cb.checked = false);
      saveBucketSelection();
      updateCharts();
    });
    
    function bucketCountsFromRow(row) {
      const out = new Map(); // bucketId -> count
      if (!row.label_counts || typeof row.label_counts !== "object") return out;
      for (const [label, raw] of Object.entries(row.label_counts)) {
        const n = typeof raw === "number" ? raw : parseInt(raw, 10) || 0;
        const bucketId = getBucketIdForLabel(label);
        out.set(bucketId, (out.get(bucketId) || 0) + n);
      }
      return out;
    }
    
    // Build a label → explanation lookup map from rows
    function buildLabelExplanationMap(rows) {
      const map = new Map();
      for (const row of rows) {
        let issues = row.issues;
        
        // Handle null/undefined
        if (!issues) {
          issues = [];
        }
        // Handle string (rare case - JSON string)
        else if (typeof issues === "string") {
          try {
            issues = JSON.parse(issues);
          } catch (e) {
            issues = [];
          }
        }
        // Ensure it's an array
        if (!Array.isArray(issues)) {
          issues = [];
        }
        
        for (const issue of issues) {
          const label = issue?.label;
          const expl = issue?.explanation;
          if (!label || !expl) continue;
          
          // Prefer first explanation OR prefer the longer one if conflicts exist
          const prev = map.get(label);
          if (!prev || (typeof prev === "string" && expl.length > prev.length)) {
            map.set(label, expl);
          }
        }
      }
      return map;
    }
    
    function computeWorstBestStudentsForLabel(rows, label) {
      const perStudent = new Map(); // student_name -> count
      const canonical = canonicalLabel(label);
      
      for (const row of rows) {
        const student = (row.student_name || "").trim();
        if (!student) continue;

        const obj = row.label_counts && typeof row.label_counts === "object" ? row.label_counts : {};
        let studentTotal = perStudent.get(student) || 0;
        
        // Sum counts for all aliases of the canonical label
        Object.entries(obj).forEach(([entryLabel, raw]) => {
          const entryCanonical = canonicalLabel(entryLabel);
          if (entryCanonical === canonical) {
            const n = typeof raw === "number" ? raw : (parseInt(raw, 10) || 0);
            studentTotal += n;
          }
        });
        
        perStudent.set(student, studentTotal);
      }

      if (perStudent.size === 0) {
        return { worst: "—", best: "—" };
      }

      // Worst = highest count, Best = lowest count
      let worstStudent = null, worstCount = -Infinity;
      let bestStudent = null, bestCount = Infinity;

      for (const [student, count] of perStudent.entries()) {
        if (count > worstCount) { worstCount = count; worstStudent = student; }
        if (count < bestCount) { bestCount = count; bestStudent = student; }
      }

      return { worst: worstStudent || "—", best: bestStudent || "—" };
    }
    
    // Wrap text for tooltip display
    function wrapTooltipText(text, maxLineLen = 70) {
      const words = text.split(/\s+/).filter(Boolean);
      const lines = [];
      let line = "";
      for (const w of words) {
        const test = line ? line + " " + w : w;
        if (test.length > maxLineLen) {
          if (line) lines.push(line);
          line = w;
        } else {
          line = test;
        }
      }
      if (line) lines.push(line);
      return lines;
    }
    
    // ===== Filter updates =====
    function updateFilters() {
      // Update series filter - build map of seriesKey -> best display string
      const seriesKeyToDisplay = new Map(); // seriesKey -> best display string
      allData.forEach(row => {
        const parsed = parseAssignmentName(row.assignment_display);
        if (parsed.seriesKey) {
          const existing = seriesKeyToDisplay.get(parsed.seriesKey);
          if (!existing) {
            // First occurrence, use it
            seriesKeyToDisplay.set(parsed.seriesKey, parsed.seriesDisplay || parsed.seriesRaw);
          } else {
            // Choose "best" display string by preferring:
            // 1) strings containing spaces (more readable)
            // 2) longer strings
            const candidate = parsed.seriesDisplay || parsed.seriesRaw;
            const existingHasSpace = existing.includes(" " );
            const candidateHasSpace = candidate.includes(" " );
            if (candidateHasSpace && !existingHasSpace) {
              seriesKeyToDisplay.set(parsed.seriesKey, candidate);
            } else if (candidate.length > existing.length && (candidateHasSpace === existingHasSpace)) {
              seriesKeyToDisplay.set(parsed.seriesKey, candidate);
            }
          }
        }
      });
      const seriesKeys = Array.from(seriesKeyToDisplay.keys()).sort();
      seriesFilter.innerHTML = '<option value="">All Series</option>';
      seriesKeys.forEach(seriesKey => {
        const option = document.createElement("option");
        option.value = seriesKey;
        option.textContent = seriesKeyToDisplay.get(seriesKey);
        seriesFilter.appendChild(option);
      });
    }

    // ===== Filter application =====
    function applyFilters() {
      // Start with data sorted by created_at descending (most recent first)
      let filtered = [...allData].sort((a, b) => 
        new Date(b.created_at) - new Date(a.created_at)
      );

      // Handle duplicates: if not including duplicates, keep only most recent per assignment/file
      // Since data is sorted by created_at descending, first occurrence is most recent
      if (!includeDuplicates.checked) {
        const seen = new Set();
        filtered = filtered.filter(row => {
          const key = row.file_name || row.assignment_display || "";
          if (!key) return true;

          if (seen.has(key)) {
            return false; // Already seen this key, skip (we keep the first/most recent)
          }
          seen.add(key);
          return true;
        });
      }

      // Apply series filter
      const selectedSeriesKey = seriesFilter.value;
      if (selectedSeriesKey) {
        filtered = filtered.filter(r => {
          const parsed = parseAssignmentName(r.assignment_display);
          return parsed.seriesKey === selectedSeriesKey;
        });
      }

      // Sort by assignment (series then number, with unparseable at end)
      filtered.sort((a, b) => {
        const aParsed = parseAssignmentName(a.assignment_display);
        const bParsed = parseAssignmentName(b.assignment_display);

        // Unparseable go to end
        if (aParsed.number === null && bParsed.number !== null) return 1;
        if (aParsed.number !== null && bParsed.number === null) return -1;
        if (aParsed.number === null && bParsed.number === null) {
          return (aParsed.original || "").localeCompare(bParsed.original || "");
        }

        // If series filter is applied, just sort by number
        if (selectedSeriesKey && aParsed.seriesKey === selectedSeriesKey && bParsed.seriesKey === selectedSeriesKey) {
          return aParsed.number - bParsed.number;
        }

        // Otherwise sort by seriesKey then number (so "AdvancedHW" + "Advanced Homework" are grouped together)
        if (aParsed.seriesKey !== bParsed.seriesKey) {
          return aParsed.seriesKey.localeCompare(bParsed.seriesKey);
        }
        return aParsed.number - bParsed.number;
      });

      // Apply range filter
      if (currentRange === "first") {
        // Filter to only the earliest numbered assignment (respecting Series filter)
        const numberedAssignments = filtered.filter(row => {
          const parsed = parseAssignmentName(row.assignment_display);
          return parsed.number !== null;
        });

        if (numberedAssignments.length > 0) {
          // Find the earliest assignment number
          let earliestNum = Infinity;
          numberedAssignments.forEach(row => {
            const parsed = parseAssignmentName(row.assignment_display);
            if (parsed.number !== null && parsed.number < earliestNum) {
              earliestNum = parsed.number;
            }
          });

          // Filter to only assignments with the earliest number
          filtered = filtered.filter(row => {
            const parsed = parseAssignmentName(row.assignment_display);
            return parsed.number === earliestNum;
          });
        }
        // If no numbered assignments, keep current filter (don't crash)
      } else if (currentRange === "latest") {
        // Filter to only the most recent/highest numbered assignment (respecting Series filter)
        const numberedAssignments = filtered.filter(row => {
          const parsed = parseAssignmentName(row.assignment_display);
          return parsed.number !== null;
        });

        if (numberedAssignments.length > 0) {
          // Find the latest assignment number
          let latestNum = -Infinity;
          numberedAssignments.forEach(row => {
            const parsed = parseAssignmentName(row.assignment_display);
            if (parsed.number !== null && parsed.number > latestNum) {
              latestNum = parsed.number;
            }
          });

          // Filter to only assignments with the latest number
          filtered = filtered.filter(row => {
            const parsed = parseAssignmentName(row.assignment_display);
            return parsed.number === latestNum;
          });
        }
        // If no numbered assignments, keep current filter (don't crash)
      } else if (currentRange !== "all") {
        const num = parseInt(currentRange, 10);
        if (!isNaN(num)) {
          filtered = filtered.slice(0, num);
        } else if (rangeStart.value && rangeEnd.value) {
          const start = parseInt(rangeStart.value, 10) - 1; // 0-indexed
          const end = parseInt(rangeEnd.value, 10);
          filtered = filtered.slice(start, end);
        }
      } else if (rangeStart.value && rangeEnd.value) {
        const start = parseInt(rangeStart.value, 10) - 1;
        const end = parseInt(rangeEnd.value, 10);
        filtered = filtered.slice(start, end);
      }

      filteredData = filtered;
      updateUI();
    }

    // ===== UI updates =====
    function updateUI() {
      updateCharts();
      updateTable();
    }
    
    function updateCharts() {
      updateLineChart();
      updateBarChart();
      updateBucketChart();
    }
    
    function updateLineChart() {
      const canvas = document.getElementById("lineChart");
      if (!canvas) return;

      const ctx = canvas.getContext("2d");

      if (lineChart) {
        lineChart.destroy();
      }

      const selectedSeriesKey = seriesFilter.value;

      // Group data for line chart by assignment
      const assignmentMap = new Map();
      filteredData.forEach(row => {
        const key = row.assignment_display || "Unnamed";
        if (!assignmentMap.has(key)) {
          assignmentMap.set(key, { total: 0, count: 0 });
        }
        const entry = assignmentMap.get(key);
        entry.total += row.total_labels || 0;
        entry.count += 1;
      });

      const assignments = Array.from(assignmentMap.entries())
        .map(([name, stats]) => ({
          name,
          total: stats.total
        }))
        .sort((a, b) => {
          const aParsed = parseAssignmentName(a.name);
          const bParsed = parseAssignmentName(b.name);
          if (aParsed.number === null && bParsed.number !== null) return 1;
          if (aParsed.number !== null && bParsed.number === null) return -1;
          if (aParsed.number === null) return 0;
          if (selectedSeriesKey && aParsed.seriesKey === selectedSeriesKey && bParsed.seriesKey === selectedSeriesKey) {
            return aParsed.number - bParsed.number;
          }
          if (aParsed.seriesKey !== bParsed.seriesKey) {
            return aParsed.seriesKey.localeCompare(bParsed.seriesKey);
          }
          return aParsed.number - bParsed.number;
        });

      lineChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: assignments.map(a => {
            const parsed = parseAssignmentName(a.name);
            return selectedSeriesKey && parsed.seriesKey === selectedSeriesKey 
              ? `#${parsed.number}` 
              : a.name;
          }),
          datasets: [{
            label: "Total Labels",
            data: assignments.map(a => a.total),
            borderColor: "rgb(169, 13, 34)",
            backgroundColor: "rgba(169, 13, 34, 0.1)",
            tension: 0.1,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    function updateBarChart() {
      const ctx = document.getElementById("barChart").getContext("2d");
      
      if (barChart) {
        barChart.destroy();
      }
      
      const selectedBucketIds = getSelectedBucketIds();
      
      // Count non-"other" buckets
      const nonOtherBuckets = LABEL_BUCKETS.filter(b => b.id !== "other").length;
      const allBucketsSelected = selectedBucketIds.length === nonOtherBuckets;
      
      // Aggregate label_counts across filtered data
      const labelCounter = new Map();
      
      // If all buckets are selected, or no buckets selected, show all labels (default behavior)
      // Otherwise, filter by selected buckets
      if (!allBucketsSelected && selectedBucketIds.length > 0) {
        filteredData.forEach(row => {
          if (row.label_counts && typeof row.label_counts === 'object') {
            Object.entries(row.label_counts).forEach(([label, count]) => {
              // Only include label if its bucket is selected
              const bucketId = getBucketIdForLabel(label);
              if (selectedBucketIds.includes(bucketId)) {
                const currentCount = labelCounter.get(label) || 0;
                labelCounter.set(label, currentCount + (typeof count === 'number' ? count : parseInt(count, 10) || 0));
              }
            });
          }
        });
      } else {
        // If all buckets selected or none selected, include all labels (default behavior)
        filteredData.forEach(row => {
          if (row.label_counts && typeof row.label_counts === 'object') {
            Object.entries(row.label_counts).forEach(([label, count]) => {
              const currentCount = labelCounter.get(label) || 0;
              labelCounter.set(label, currentCount + (typeof count === 'number' ? count : parseInt(count, 10) || 0));
            });
          }
        });
      }
      
      // Aggregate counts by canonical label (sum all aliases)
      const canonicalCounter = new Map(); // canonical -> totalCount
      labelCounter.forEach((count, label) => {
        const canonical = canonicalLabel(label);
        const existing = canonicalCounter.get(canonical) || 0;
        canonicalCounter.set(canonical, existing + count);
      });
      
      const topLabels = Array.from(canonicalCounter.entries())
        .map(([canonical, count]) => ({ label: canonical, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 8);
      
      // Build explanation map from filtered data
      const explMap = buildLabelExplanationMap(filteredData);
      const explanations = topLabels.map(l => explMap.get(l.label) || "");
      
      // Compute bucket names, worst students, and best students
      const bucketNames = topLabels.map(l => {
        const id = getBucketIdForLabel(l.label);
        return LABEL_BUCKETS.find(b => b.id === id)?.name || "Other";
      });
      
      const worstStudents = topLabels.map(l => computeWorstBestStudentsForLabel(filteredData, l.label).worst);
      const bestStudents = topLabels.map(l => computeWorstBestStudentsForLabel(filteredData, l.label).best);
      
      // Populate dropdown
      const examplesIssueSelect = document.getElementById("examplesIssueSelect");
      if (examplesIssueSelect) {
        examplesIssueSelect.innerHTML = "";
        if (topLabels.length > 0) {
          topLabels.forEach(({ label, count }) => {
            const option = document.createElement("option");
            option.value = label; // Store canonical label
            option.textContent = `${displayLabel(label)} (${count})`;
            examplesIssueSelect.appendChild(option);
          });
          examplesIssueSelect.style.display = "block";
          
          // Set default selection to first item
          examplesIssueSelect.value = topLabels[0].label;
        } else {
          examplesIssueSelect.style.display = "none";
        }
      }
      
      // Map each label to its bucket color
      const backgroundColor = topLabels.map(l => {
        const bucketId = getBucketIdForLabel(l.label);
        return getBucketColor(bucketId, 0.6);
      });
      const borderColor = topLabels.map(l => {
        const bucketId = getBucketIdForLabel(l.label);
        return getBucketColor(bucketId, 1.0);
      });
      
      barChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: topLabels.map(l => displayLabel(l.label)),
          datasets: [{
            label: "Count",
            data: topLabels.map(l => l.count),
            canonicalLabels: topLabels.map(l => l.label), // Store canonical labels for onClick
            explanations: explanations,
            bucketNames: bucketNames,
            worstStudents: worstStudents,
            bestStudents: bestStudents,
            backgroundColor: backgroundColor,
            borderColor: borderColor,
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true
            }
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              displayColors: false,
              callbacks: {
                title: (items) => {
                  const item = items?.[0];
                  if (!item) return "";
                  const idx = item.dataIndex;
                  return item.dataset?.bucketNames?.[idx] || "";
                },
                afterTitle: (items) => {
                  const item = items?.[0];
                  if (!item) return "";
                  // This is the issue label on the x-axis
                  return item.label || "";
                },
                label: (item) => {
                  const idx = item.dataIndex;
                  const worst = item.dataset?.worstStudents?.[idx] || "—";
                  const best  = item.dataset?.bestStudents?.[idx] || "—";
                  // One line to conserve space
                  return `Worst: ${worst}   Best: ${best}`;
                },
                afterBody: (items) => {
                  const item = items?.[0];
                  if (!item) return [];
                  const idx = item.dataIndex;
                  const expl = item.dataset?.explanations?.[idx];
                  if (!expl) return [];

                  const lines = wrapTooltipText(String(expl).trim(), 70);
                  const maxLines = 10;
                  const clipped = lines.slice(0, maxLines);

                  // If we clipped, add ellipsis to the last line
                  if (lines.length > maxLines && clipped.length) {
                    clipped[clipped.length - 1] = clipped[clipped.length - 1].replace(/[.…]?$/, "…");
                  }
                  return clipped;
                },
                footer: () => {
                  return "Examples shown on the left";
                }
              },
              footerColor: "#fff",
              footerFont: {
                weight: "700"
              }
            }
          },
          onHover: (event, activeElements) => {
            event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
          },
          onClick: (event, activeElements) => {
            if (activeElements.length === 0) return;
            const item = activeElements[0];
            const idx = item.dataIndex;
            const ds = item.chart.data.datasets[0];
            const canonical = ds?.canonicalLabels?.[idx] || item.chart.data.labels[idx];
            const bucketName = ds?.bucketNames?.[idx] || "";
            
            // Update dropdown to match clicked bar
            const examplesIssueSelect = document.getElementById("examplesIssueSelect");
            if (examplesIssueSelect) {
              examplesIssueSelect.value = canonical;
            }
            
            loadExamplesPanel({ label: canonical, bucketName });
          }
        }
      });
      
      // Preload examples for the first bar
      if (topLabels.length > 0) {
        const firstLabel = topLabels[0].label;
        const firstBucketName = bucketNames[0] || "";
        loadExamplesPanel({ label: firstLabel, bucketName: firstBucketName });
      } else if (examplesPanelContent) {
        examplesPanelContent.innerHTML = '<div class="examples-empty">No issues found for the current filters.</div>';
        if (examplesPanelCopyBtn) examplesPanelCopyBtn.style.display = "none";
        const examplesIssueSelect = document.getElementById("examplesIssueSelect");
        if (examplesIssueSelect) examplesIssueSelect.style.display = "none";
      }
    }
    
    function updateBucketChart() {
      const canvas = document.getElementById("bucketChart");
      const parent = canvas.parentElement;

      if (bucketChart) {
        bucketChart.destroy();
        bucketChart = null;
      }

      const selectedBucketIds = getSelectedBucketIds();

      if (selectedBucketIds.length === 0) {
        // Clear chart if no buckets selected
        const message = document.createElement("div");
        message.style.textAlign = "center";
        message.style.padding = "40px";
        message.style.color = "var(--muted)";
        message.textContent = "Please select at least one bucket to view chart";
        message.id = "bucketChartMessage";

        // Remove existing message if present
        const existing = parent.querySelector("#bucketChartMessage");
        if (existing) existing.remove();

        parent.appendChild(message);
        canvas.style.display = "none";
        return;
      }

      // Remove message and show canvas if buckets are selected
      const existing = parent.querySelector("#bucketChartMessage");
      if (existing) existing.remove();
      canvas.style.display = "block";

      const ctx = canvas.getContext("2d");

      const selectedSeriesKey = seriesFilter.value;

      // Build assignment map with bucket totals
      const assignmentMap = new Map();
      filteredData.forEach(row => {
        const key = row.assignment_display || "Unnamed";
        if (!assignmentMap.has(key)) {
          assignmentMap.set(key, new Map());
        }
        const bucketCounts = bucketCountsFromRow(row);
        bucketCounts.forEach((count, bucketId) => {
          const current = assignmentMap.get(key).get(bucketId) || 0;
          assignmentMap.get(key).set(bucketId, current + count);
        });
      });

      // Convert to sorted assignments array
      const assignments = Array.from(assignmentMap.entries())
        .map(([name, bucketMap]) => ({ name, bucketMap }))
        .sort((a, b) => {
          const aParsed = parseAssignmentName(a.name);
          const bParsed = parseAssignmentName(b.name);
          if (aParsed.number === null && bParsed.number !== null) return 1;
          if (aParsed.number !== null && bParsed.number === null) return -1;
          if (aParsed.number === null) return 0;
          if (selectedSeriesKey && aParsed.seriesKey === selectedSeriesKey && bParsed.seriesKey === selectedSeriesKey) {
            return aParsed.number - bParsed.number;
          }
          if (aParsed.seriesKey !== bParsed.seriesKey) {
            return aParsed.seriesKey.localeCompare(bParsed.seriesKey);
          }
          return aParsed.number - bParsed.number;
        });

      const labels = assignments.map(a => {
        const parsed = parseAssignmentName(a.name);
        return selectedSeriesKey && parsed.seriesKey === selectedSeriesKey 
          ? `#${parsed.number}` 
          : a.name;
      });

      // Build datasets for selected buckets (in LABEL_BUCKETS order)
      const datasets = [];
      LABEL_BUCKETS.forEach((bucket, idx) => {
        if (!selectedBucketIds.includes(bucket.id)) return;

        const data = assignments.map(a => a.bucketMap.get(bucket.id) || 0);
        datasets.push({
          label: bucket.name,
          data: data,
          backgroundColor: getBucketColor(bucket.id, 0.8),
          borderColor: getBucketColor(bucket.id, 1.0),
          borderWidth: 1
        });
      });

      bucketChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              stacked: true
            },
            y: {
              stacked: true,
              beginAtZero: true
            }
          }
        }
      });
    }

    function updateTable() {
      dataTableBody.innerHTML = "";

      if (filteredData.length === 0) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 7;
        td.textContent = "No data to display";
        td.style.textAlign = "center";
        td.style.padding = "20px";
        td.style.color = "var(--muted)";
        tr.appendChild(td);
        dataTableBody.appendChild(tr);
        syncBulkUI();
        return;
      }

      // Separate parseable and unparseable assignments
      const parseableRows = [];
      const unparseableRows = [];

      filteredData.forEach(row => {
        const parsed = parseAssignmentName(row.assignment_display);
        if (parsed.number === null && row.assignment_display) {
          unparseableRows.push(row);
        } else {
          parseableRows.push(row);
        }
      });

      function buildRow(row, highlightUnparseable) {
        const tr = document.createElement("tr");
        if (highlightUnparseable) {
          tr.style.background = "#fffbf0";
        }

        const selectCell = document.createElement("td");
        selectCell.className = "nowrap";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.disabled = !row.file_name;
        cb.checked = !!row.file_name && selectedFileNames.has(row.file_name);

        cb.addEventListener("change", () => {
          const f = row.file_name;
          if (!f) return;
          if (cb.checked) selectedFileNames.add(f);
          else selectedFileNames.delete(f);
          syncBulkUI();
        });

        // clicking the row shouldn't toggle checkbox accidentally
        selectCell.appendChild(cb);
        tr.appendChild(selectCell);

        const dateCell = document.createElement("td");
        dateCell.className = "nowrap";
        const d = new Date(row.created_at);
        dateCell.textContent = d.toLocaleDateString();
        tr.appendChild(dateCell);

        const assignmentCell = document.createElement("td");
        assignmentCell.textContent = row.assignment_display || "—";
        if (highlightUnparseable) {
          assignmentCell.style.color = "#856404";
        }
        tr.appendChild(assignmentCell);

        const modeCell = document.createElement("td");
        modeCell.textContent = row.mode || "—";
        tr.appendChild(modeCell);

        const labelsCell = document.createElement("td");
        labelsCell.className = "nowrap";
        labelsCell.textContent = row.total_labels != null ? row.total_labels : "—";
        tr.appendChild(labelsCell);

        const labelCountsCell = document.createElement("td");
        if (row.label_counts && typeof row.label_counts === 'object') {
          labelCountsCell.textContent = Object.entries(row.label_counts)
            .map(([k, v]) => `${k}: ${v}`)
            .join(", ");
        } else {
          labelCountsCell.textContent = "—";
        }
        tr.appendChild(labelCountsCell);

        const actionsCell = document.createElement("td");
        const deleteBtn = document.createElement("button");
        deleteBtn.type = "button";
        deleteBtn.className = "delete-btn";
        deleteBtn.textContent = "Delete";
        deleteBtn.disabled = !deleteButtonsEnabled || !row.file_name;
        deleteBtn.title = !row.file_name ? "No file to delete" : (deleteButtonsEnabled ? "" : "Delete disabled");
        deleteBtn.addEventListener("click", () => {
          if (deleteBtn.disabled) return;
          deleteDocumentsByFileNames([row.file_name]);
        });
        actionsCell.appendChild(deleteBtn);
        tr.appendChild(actionsCell);

        return tr;
      }

      // Show parseable rows first
      parseableRows.forEach(row => {
        dataTableBody.appendChild(buildRow(row, false));
      });

      // Show warning section for unparseable assignments
      if (unparseableRows.length > 0) {
        // Add separator row
        const separatorTr = document.createElement("tr");
        const separatorTd = document.createElement("td");
        separatorTd.colSpan = 7;
        separatorTd.style.padding = "16px 12px 8px";
        separatorTd.style.borderTop = "2px solid #ffc107";
        separatorTd.style.background = "#fffbf0";
        separatorTd.innerHTML = '<strong style="color: #856404;">⚠️ Unsorted / Missing assignment number</strong><br><span style="font-size: 12px; color: #856404;">These assignments cannot be sorted sequentially. Please use format like "Foundation 01" for progress graphs.</span>';
        dataTableBody.appendChild(separatorTr);
        separatorTr.appendChild(separatorTd);

        // Add unparseable rows
        unparseableRows.forEach(row => {
          dataTableBody.appendChild(buildRow(row, true));
        });
      }

      syncBulkUI();
    }

    // ===== CSV Export =====
    function exportToCSV() {
      if (filteredData.length === 0) {
        alert("No data to export");
        return;
      }
      
      const headers = ["Date", "Assignment", "Mode", "Total Labels", "Label Counts"];
      const rows = filteredData.map(row => {
        const date = new Date(row.created_at).toLocaleDateString();
        const assignment = row.assignment_display || "";
        const mode = row.mode || "";
        const totalLabels = row.total_labels != null ? row.total_labels : "";
        const labelCounts = row.label_counts && typeof row.label_counts === 'object'
          ? Object.entries(row.label_counts).map(([k, v]) => `${k}: ${v}`).join("; ")
          : "";
        
        return [date, assignment, mode, totalLabels, labelCounts];
      });
      
      const csvContent = [
        headers.join(","),
        ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(","))
      ].join("\n");
      
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      const url = URL.createObjectURL(blob);
      link.setAttribute("href", url);
      link.setAttribute("download", `vysti-progress-${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = "hidden";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    
    // ===== PDF Export =====
    function exportToPDF() {
      if (filteredData.length === 0) {
        alert("No data to export");
        return;
      }
      
      const printHeader = document.getElementById("printHeader");
      const printGeneratedAt = document.getElementById("printGeneratedAt");
      const printMeta = document.getElementById("printMeta");
      
      // Build filter summary
      const summary = [];
      // Series
      const seriesValue = seriesFilter.value || "All Series";
      summary.push(`<div><strong>Series:</strong> ${seriesValue}</div>`);
      
      // Range
      let rangeText = "";
      if (rangeStart.value && rangeEnd.value) {
        rangeText = `Custom: ${rangeStart.value}-${rangeEnd.value}`;
      } else {
        const activeRangeBtn = document.querySelector(".range-btn.active");
        if (activeRangeBtn) {
          const rangeData = activeRangeBtn.dataset.range;
          if (rangeData === "first") rangeText = "First";
          else if (rangeData === "latest") rangeText = "Latest";
          else if (rangeData === "all") rangeText = "All";
          else rangeText = "All";
        } else {
          rangeText = "All";
        }
      }
      summary.push(`<div><strong>Range:</strong> ${rangeText}</div>`);
      
      // Buckets
      const selectedBucketIds = getSelectedBucketIds();
      let bucketText = "";
      if (selectedBucketIds.length === 0) {
        bucketText = "All Categories";
      } else {
        const selectedBuckets = selectedBucketIds.map(id => {
          const bucket = LABEL_BUCKETS.find(b => b.id === id);
          return bucket ? bucket.name : id;
        });
        bucketText = selectedBuckets.join(", ");
      }
      summary.push(`<div><strong>Buckets:</strong> ${bucketText}</div>`);
      
      // Include repeated submissions
      const duplicatesText = includeDuplicates.checked ? "Yes" : "No";
      summary.push(`<div><strong>Include repeated submissions:</strong> ${duplicatesText}</div>`);
      
      // Set print header content
      printMeta.innerHTML = summary.join("");
      printGeneratedAt.textContent = `Generated: ${new Date().toLocaleString()}`;
      
      // Add printing class to body
      document.body.classList.add("printing");
      
      // Small timeout to allow layout updates
      setTimeout(() => {
        window.print();
      }, 50);
      
      // Remove printing class after print
      window.onafterprint = () => {
        document.body.classList.remove("printing");
        window.onafterprint = null;
      };
    }
    
    // ===== Examples Modal Functions =====
    const examplesModal = document.getElementById("examplesModal");
    const modalCloseBtn = document.getElementById("modalCloseBtn");
    const modalBucketName = document.getElementById("modalBucketName");
    const modalLabel = document.getElementById("modalLabel");
    const modalContent = document.getElementById("modalContent");
    const copyAllBtn = document.getElementById("copyAllBtn");
    
    // Examples Panel DOM refs
    const examplesPanelBucket = document.getElementById("examplesPanelBucket");
    const examplesPanelLabel = document.getElementById("examplesPanelLabel");
    const examplesPanelBestWorst = document.getElementById("examplesPanelBestWorst");
    const examplesPanelContent = document.getElementById("examplesPanelContent");
    const examplesPanelCopyBtn = document.getElementById("examplesPanelCopyBtn");
    
    let currentExamples = [];
    let currentLabel = "";
    let currentBucketName = "";
    
    // Close modal handlers
    modalCloseBtn.addEventListener("click", () => {
      examplesModal.style.display = "none";
    });
    
    examplesModal.addEventListener("click", (e) => {
      if (e.target === examplesModal) {
        examplesModal.style.display = "none";
      }
    });
    
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && examplesModal.style.display !== "none") {
        examplesModal.style.display = "none";
      }
    });
    
    // Fetch examples from Supabase
    async function fetchExamplesForLabel(label) {
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        return [];
      }

      // Get canonical label and aliases
      const canonical = canonicalLabel(label);
      const aliases = labelAliasesForQuery(canonical);

      let query = supa
        .from("issue_examples")
        .select("sentence, assignment_name, file_name, created_at")
        .eq("user_id", sessionData.session.user.id);

      // Use .in() if there are aliases, otherwise use .eq()
      if (aliases.length > 1) {
        query = query.in("label", aliases);
      } else {
        query = query.eq("label", canonical);
      }

      const { data, error } = await query
        .order("created_at", { ascending: false })
        .limit(50);

      if (error) {
        console.error("Error fetching examples:", error);
        return [];
      }

      if (!data || data.length === 0) {
        return [];
      }

      // Filter by filteredData keys (file_name or assignment_display)
      const allowedKeys = new Set();
      filteredData.forEach(row => {
        const key = row.file_name || row.assignment_display || "";
        if (key) {
          allowedKeys.add(key);
        }
      });

      // Filter examples to only those in filteredData
      let filtered = data.filter(ex => {
        const key = ex.file_name || ex.assignment_name || "";
        return key ? allowedKeys.has(key) : false;
      });

      // Limit to first 10 for display
      return filtered.slice(0, 10);
    }

// Load examples into the panel
    async function loadExamplesPanel({ label, bucketName }) {
      if (!examplesPanelContent) return;

      // Use canonical label
      const canonical = canonicalLabel(label || "");
      currentLabel = canonical;
      currentBucketName = bucketName || "";

      if (examplesPanelBucket) examplesPanelBucket.textContent = currentBucketName;
      if (examplesPanelLabel) examplesPanelLabel.textContent = displayLabel(currentLabel);

      // Compute most/least issues from filteredData by assignment/file
      const perAssignment = new Map(); // assignment_display -> totalCount
      const allAssignments = new Set();

      filteredData.forEach(row => {
        const assignment = (row.assignment_display || "").trim();
        if (!assignment) return;
        allAssignments.add(assignment);

        const obj = row.label_counts && typeof row.label_counts === "object" ? row.label_counts : {};
        let assignmentTotal = perAssignment.get(assignment) || 0;

        // Sum counts for all aliases of the canonical label
        Object.entries(obj).forEach(([entryLabel, raw]) => {
          const entryCanonical = canonicalLabel(entryLabel);
          if (entryCanonical === canonical) {
            const n = typeof raw === "number" ? raw : (parseInt(raw, 10) || 0);
            assignmentTotal += n;
          }
        });

        perAssignment.set(assignment, assignmentTotal);
      });

      // Initialize all assignments with 0 if not in perAssignment
      allAssignments.forEach(assignment => {
        if (!perAssignment.has(assignment)) {
          perAssignment.set(assignment, 0);
        }
      });

      // Find most and least
      let mostName = "—";
      let mostCount = -Infinity;
      let leastName = "—";
      let leastCount = Infinity;

      for (const [assignment, count] of perAssignment.entries()) {
        if (count > mostCount) {
          mostCount = count;
          mostName = assignment;
        }
        if (count < leastCount) {
          leastCount = count;
          leastName = assignment;
        }
      }

      if (mostCount === -Infinity) mostCount = 0;
      if (leastCount === Infinity) leastCount = 0;

      const mostTxt = mostName !== "—" ? `Most Issues: ${mostName} (${mostCount})` : "Most Issues: —";
      const leastTxt = leastName !== "—" ? `Least Issues: ${leastName} (${leastCount})` : "Least Issues: —";
      if (examplesPanelBestWorst) examplesPanelBestWorst.textContent = `${mostTxt}   ${leastTxt}`;

      examplesPanelContent.innerHTML = '<div class="examples-loading">Loading examples...</div>';
      if (examplesPanelCopyBtn) examplesPanelCopyBtn.style.display = "none";

      const examples = await fetchExamplesForLabel(currentLabel);
      currentExamples = examples;

      if (!examples || examples.length === 0) {
        examplesPanelContent.innerHTML =
          '<div class="examples-empty">No examples saved yet for this issue. Examples appear after essays are marked/ingested.</div>';
        return;
      }

      renderExamples(examples, examplesPanelContent);
      if (examplesPanelCopyBtn) examplesPanelCopyBtn.style.display = "inline-block";
    }
    
    // Open examples modal
    async function openExamplesModal({ label, bucketName }) {
      currentLabel = label;
      currentBucketName = bucketName;
      
      modalBucketName.textContent = bucketName;
      modalLabel.textContent = label;
      modalContent.innerHTML = '<div class="examples-loading">Loading examples...</div>';
      examplesModal.style.display = "flex";
      
      const examples = await fetchExamplesForLabel(label);
      currentExamples = examples;
      
      if (examples.length === 0) {
        modalContent.innerHTML = '<div class="examples-empty">No examples saved yet for this issue. Examples appear after essays are marked/ingested.</div>';
        return;
      }
      
      renderExamples(examples, modalContent);
    }
    
    // Render examples list
    function renderExamples(examples, containerEl) {
      const target = containerEl || modalContent;
      target.innerHTML = "";

      // Compute occurrence counts for each example
      // Use filteredData to respect current filters (including duplicates toggle)
      const canonical = canonicalLabel(currentLabel);

      examples.forEach((example) => {
        const item = document.createElement("div");
        item.className = "example-item";

        const studentInfo = document.createElement("div");
        studentInfo.className = "example-student-info";

        // Compute occurrence count for this assignment + current label
        let occurrenceCount = 0;
        const assignmentKey = example.file_name || example.assignment_name || "";

        if (assignmentKey) {
          // Sum counts from filteredData (already respects duplicates toggle)
          filteredData.forEach(row => {
            const rowKey = row.file_name || row.assignment_display || "";
            if (rowKey && rowKey === assignmentKey) {
              const obj = row.label_counts && typeof row.label_counts === "object" ? row.label_counts : {};
              // Sum counts for all aliases of the canonical label
              Object.entries(obj).forEach(([entryLabel, raw]) => {
                const entryCanonical = canonicalLabel(entryLabel);
                if (entryCanonical === canonical) {
                  const n = typeof raw === "number" ? raw : (parseInt(raw, 10) || 0);
                  occurrenceCount += n;
                }
              });
            }
          });
        }

        const assignmentName = document.createElement("span");
        assignmentName.className = "example-student-name";
        const displayAssignment = assignmentKey || "Unknown";
        assignmentName.textContent = occurrenceCount > 0 
          ? `${displayAssignment} (${occurrenceCount})`
          : displayAssignment;
        studentInfo.appendChild(assignmentName);

        if (example.assignment_name || example.file_name) {
          const assignmentDetail = document.createElement("span");
          assignmentDetail.className = "example-assignment-name";
          const detail = example.assignment_name && example.file_name && example.assignment_name !== example.file_name
            ? `${example.assignment_name} • ${example.file_name}`
            : (example.assignment_name || example.file_name);
          assignmentDetail.textContent = `• ${detail}`;
          studentInfo.appendChild(assignmentDetail);
        }

        item.appendChild(studentInfo);

        const sentence = document.createElement("div");
        sentence.className = "example-sentence";
        sentence.textContent = example.sentence || "";
        item.appendChild(sentence);

        const copyBtn = document.createElement("button");
        copyBtn.className = "example-copy-btn";
        copyBtn.textContent = "Copy this example";
        copyBtn.addEventListener("click", () => {
          copySentence(example, copyBtn);
        });
        item.appendChild(copyBtn);

        target.appendChild(item);
      });
    }

    // Copy single sentence
    async function copySentence(example, buttonElement) {
      const assignmentLabel = example.assignment_name || example.file_name || "Assignment";
      const text = `${assignmentLabel} — "${example.sentence || ""}"`;
      await copyToClipboard(text, buttonElement, "Copied!");
    }
    
    // Copy all examples as revision assignment
    async function copyAllExamples() {
      if (currentExamples.length === 0) return;
      
      // Get button element (could be panel or modal button)
      const panelBtn = document.getElementById("examplesPanelCopyBtn");
      const modalBtn = document.getElementById("copyAllBtn");
      const btn = panelBtn || modalBtn;
      
      let text = `Revision Assignment: ${currentBucketName} — ${displayLabel(currentLabel)}\n`;
      text += `Directions: Rewrite each sentence to fix the issue.\n\n`;
      
      currentExamples.forEach((ex, idx) => {
        const assignmentLabel = ex.assignment_name || ex.file_name || "___";
        text += `${idx + 1}) Assignment: ${assignmentLabel}\n`;
        text += `   Sentence: "${ex.sentence || ""}"\n`;
        if (idx < currentExamples.length - 1) {
          text += "\n";
        }
      });
      
      await copyToClipboard(text, btn, "Copied!");
    }
    
    // Clipboard helper with fallback
    async function copyToClipboard(text, buttonElement, feedbackText) {
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          // Fallback for older browsers
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand("copy");
          document.body.removeChild(textarea);
        }
        
        // Visual feedback: temporarily change button text and style
        if (buttonElement && feedbackText) {
          const originalText = buttonElement.textContent;
          const originalStyle = {
            backgroundColor: buttonElement.style.backgroundColor,
            borderColor: buttonElement.style.borderColor
          };
          
          buttonElement.textContent = feedbackText;
          buttonElement.style.backgroundColor = "#4CAF50";
          buttonElement.style.borderColor = "#4CAF50";
          
          setTimeout(() => {
            buttonElement.textContent = originalText;
            buttonElement.style.backgroundColor = originalStyle.backgroundColor;
            buttonElement.style.borderColor = originalStyle.borderColor;
          }, 1500);
        }
      } catch (err) {
        console.error("Failed to copy:", err);
        alert("Failed to copy to clipboard");
      }
    }
    
    copyAllBtn.addEventListener("click", copyAllExamples);
    
    // Wire up examples panel copy button
    if (examplesPanelCopyBtn) {
      examplesPanelCopyBtn.addEventListener("click", copyAllExamples);
    }
    
    // Wire up examples dropdown change handler
    const examplesIssueSelect = document.getElementById("examplesIssueSelect");
    if (examplesIssueSelect) {
      examplesIssueSelect.addEventListener("change", (e) => {
        const selectedLabel = e.target.value;
        if (!selectedLabel) return;
        
        // Get bucket name for the selected label
        const bucketId = getBucketIdForLabel(selectedLabel);
        const bucketName = LABEL_BUCKETS.find(b => b.id === bucketId)?.name || "Other";
        
        loadExamplesPanel({ label: selectedLabel, bucketName });
      });
    }
    
    // ===== Event listeners =====
    rangeBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        rangeBtns.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentRange = btn.dataset.range;
        applyFilters();
      });
    });
    
    rangeStart.addEventListener("input", () => {
      if (rangeStart.value && rangeEnd.value) {
        rangeBtns.forEach(b => b.classList.remove("active"));
        currentRange = "custom";
        applyFilters();
      }
    });
    
    rangeEnd.addEventListener("input", () => {
      if (rangeStart.value && rangeEnd.value) {
        rangeBtns.forEach(b => b.classList.remove("active"));
        currentRange = "custom";
        applyFilters();
      }
    });
    seriesFilter.addEventListener("change", applyFilters);
    includeDuplicates.addEventListener("change", applyFilters);
    exportBtn.addEventListener("click", exportToCSV);

    if (checkAllBtn) {
      checkAllBtn.addEventListener("click", () => {
        getVisibleUniqueFileNames().forEach(f => selectedFileNames.add(f));
        updateTable();
        syncBulkUI();
      });
    }

    if (clearChecksBtn) {
      clearChecksBtn.addEventListener("click", () => {
        selectedFileNames.clear();
        updateTable();
        syncBulkUI();
      });
    }

    if (selectAllRows) {
      selectAllRows.addEventListener("change", (e) => {
        const shouldSelect = !!e.target.checked;
        const visible = getVisibleUniqueFileNames();
        visible.forEach(f => shouldSelect ? selectedFileNames.add(f) : selectedFileNames.delete(f));
        updateTable();
        syncBulkUI();
      });
    }

    if (deleteSelectedBtn) {
      deleteSelectedBtn.addEventListener("click", () => {
        deleteDocumentsByFileNames(Array.from(selectedFileNames));
      });
    }
    
    const exportPdfBtn = document.getElementById("exportPdfBtn");
    if (exportPdfBtn) {
      exportPdfBtn.addEventListener("click", exportToPDF);
    }
    
    // ===== Initial load =====
    refreshAuthUI();
  </script>
</body>
</html>

