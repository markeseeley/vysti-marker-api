<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vysti Marker – Analytics Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/marker.css">
  
  <!-- Supabase JS client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  
  <style>
    .progress-page {
      max-width: 1400px;
      margin: 0 auto;
      padding: 24px 18px 40px;
    }
    
    .filters-section {
      background: var(--card);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 24px;
      box-shadow: 0 2px 4px rgba(0,0,0,.08);
    }
    
    .filters-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    
    .filter-group {
      display: flex;
      flex-direction: column;
    }
    
    .filter-group label {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--text);
    }
    
    .range-selector {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    
    .range-btn {
      padding: 6px 12px;
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    .range-btn:hover {
      background: rgba(169,13,34,.05);
      border-color: var(--maroon);
    }
    
    .range-btn.active {
      background: var(--maroon);
      color: #fff;
      border-color: var(--maroon);
    }
    
    .range-custom {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 8px;
    }
    
    .range-custom input {
      width: 80px;
      height: 32px;
      padding: 0 8px;
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 8px;
      font-size: 13px;
    }
    
    .duplicates-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 12px;
    }
    
    .duplicates-toggle input[type="checkbox"] {
      width: 44px;
      height: 24px;
      appearance: none;
      border-radius: 12px;
      background: #BCC1CA;
      position: relative;
      cursor: pointer;
    }
    
    .duplicates-toggle input[type="checkbox"]::before {
      content: "";
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: #fff;
      transition: transform .15s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,.18);
    }
    
    .duplicates-toggle input[type="checkbox"]:checked {
      background: var(--maroon);
    }
    
    .duplicates-toggle input[type="checkbox"]:checked::before {
      transform: translateX(20px);
    }
    
    .bucket-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      max-width: 520px;
      margin-top: 8px;
    }
    
    .bucket-checkboxes label {
      display: flex;
      gap: 6px;
      align-items: center;
      font-size: 0.9rem;
      cursor: pointer;
      font-weight: normal;
    }
    
    .bucket-checkboxes input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    
    .bucket-actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }
    
    .bucket-actions button {
      padding: 6px 12px;
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    .bucket-actions button:hover {
      background: rgba(169,13,34,.05);
      border-color: var(--maroon);
    }
    
    .charts-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      margin-bottom: 24px;
    }
    
    @media (max-width: 980px) {
      .charts-section {
        grid-template-columns: 1fr;
      }
    }
    
    .chart-card {
      background: var(--card);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,.08);
    }
    
    .chart-card h3 {
      margin: 0 0 16px;
      font-size: 18px;
      font-weight: 600;
    }
    
    .chart-container {
      position: relative;
      height: 300px;
    }
    
    .table-section {
      background: var(--card);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,.08);
    }
    
    .table-section h3 {
      margin: 0 0 16px;
      font-size: 18px;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .export-btn {
      padding: 8px 16px;
      border: 1px solid var(--maroon);
      border-radius: 8px;
      background: var(--maroon);
      color: #fff;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .export-btn:hover {
      filter: brightness(.95);
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    
    thead {
      background: #f5f6f8;
    }
    
    th, td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid rgba(0,0,0,.08);
    }
    
    th {
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      color: var(--muted);
    }
    
    tbody tr:hover {
      background: rgba(169,13,34,.02);
    }
    
    .nowrap {
      white-space: nowrap;
    }
    
    .status-message {
      padding: 12px;
      background: rgba(169,13,34,.05);
      border-radius: 8px;
      margin-bottom: 16px;
      font-size: 13px;
      color: var(--text);
    }
    
    /* Print header styles */
    .print-header {
      display: none;
    }
    
    .print-title {
      margin-bottom: 16px;
    }
    
    .print-title h1 {
      margin: 0 0 8px;
      font-size: 24px;
      font-weight: 700;
      color: var(--text);
    }
    
    .print-generated {
      font-size: 12px;
      color: var(--muted);
    }
    
    .print-meta {
      font-size: 13px;
      color: var(--text);
      line-height: 1.6;
    }
    
    .print-meta > div {
      margin-bottom: 4px;
    }
    
    /* Print styles */
    @media print {
      .print-header {
        display: block;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 2px solid rgba(0,0,0,.1);
      }
      
      header.topbar {
        display: none !important;
      }
      
      .filters-section {
        display: none !important;
      }
      
      .export-btn {
        display: none !important;
      }
      
      body {
        background: white !important;
      }
      
      .progress-page {
        background: white !important;
      }
      
      .chart-card,
      .table-section {
        background: white !important;
        box-shadow: none !important;
        border: 1px solid rgba(0,0,0,.1) !important;
      }
      
      .charts-section,
      .chart-card,
      .table-section {
        break-inside: avoid;
        page-break-inside: avoid;
      }
      
      * {
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }
      
      @page {
        margin: 16mm;
      }
    }
    
    body.printing {
      background: white;
    }
    
    body.printing .progress-page {
      background: white;
    }
    
    /* Examples Modal Styles */
    .examples-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    
    .examples-modal {
      background: var(--card);
      border-radius: 12px;
      max-width: 900px;
      width: 90%;
      max-height: 75vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }
    
    .examples-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 20px 24px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .examples-modal-bucket {
      font-size: 13px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .examples-modal-label {
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
    }
    
    .examples-modal-close {
      background: none;
      border: none;
      font-size: 28px;
      line-height: 1;
      color: var(--muted);
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .examples-modal-close:hover {
      background: rgba(0, 0, 0, 0.05);
      color: var(--text);
    }
    
    .examples-modal-actions {
      padding: 12px 24px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .examples-copy-all-btn {
      padding: 8px 16px;
      border: 1px solid var(--maroon);
      border-radius: 8px;
      background: var(--maroon);
      color: #fff;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .examples-copy-all-btn:hover {
      filter: brightness(.95);
    }
    
    .examples-modal-content {
      padding: 20px 24px;
      overflow-y: auto;
      flex: 1;
    }
    
    .example-item {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.08);
    }
    
    .example-item:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    
    .example-student-info {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .example-student-name {
      font-weight: 700;
      color: var(--text);
      font-size: 14px;
    }
    
    .example-assignment-name {
      font-size: 13px;
      color: var(--muted);
    }
    
    .example-sentence {
      background: #f5f6f8;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 8px;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 14px;
      line-height: 1.5;
      color: var(--text);
      border: 1px solid rgba(0, 0, 0, 0.08);
    }
    
    .example-copy-btn {
      padding: 6px 12px;
      border: 1px solid rgba(0, 0, 0, 0.14);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
      color: var(--text);
    }
    
    .example-copy-btn:hover {
      background: rgba(169,13,34,.05);
      border-color: var(--maroon);
    }
    
    .examples-loading {
      text-align: center;
      padding: 40px;
      color: var(--muted);
    }
    
    .examples-empty {
      text-align: center;
      padding: 40px;
      color: var(--muted);
    }
    
    .examples-issue-select {
      height: 34px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #fff;
      padding: 0 10px;
      font-size: 13px;
      font-weight: 600;
      max-width: 320px;
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <img src="/assets/logo.svg" alt="Vysti" />
    </div>
    
    <nav>
      <a href="/progress.html" class="active">Dashboard</a>
      <a href="/index.html">Mark Assignments</a>
      <a href="/ingest.html">Ingest Marked Essays</a>
      <a href="/classes.html">Classes</a>
    </nav>
    
    <div class="actions">
      <button class="iconbtn" type="button" title="Notifications" aria-label="Notifications"></button>
      <img class="avatar" src="/assets/avatar.png" alt="Profile" />
      <button class="topbar-btn" id="logoutBtn" type="button">Sign Out</button>
    </div>
  </header>

  <main class="page">
    <div class="progress-page" id="progressPage" style="display:none;">
      <div id="printHeader" class="print-header" aria-hidden="true">
        <div class="print-title">
          <h1>Vysti Progress Report</h1>
          <div id="printGeneratedAt" class="print-generated"></div>
        </div>
        <div id="printMeta" class="print-meta"></div>
      </div>
      
      <div class="filters-section">
        <h2 style="margin: 0 0 16px; font-size: 20px; font-weight: 600;">Filters</h2>
        
        <div class="filters-grid">
          <div class="filter-group">
            <label for="classFilter">Class</label>
            <select id="classFilter">
              <option value="">All Classes</option>
              <option value="__unassigned__">Unassigned</option>
            </select>
          </div>
          
          <div class="filter-group">
            <label for="studentFilter">Student</label>
            <select id="studentFilter">
              <option value="">All Students</option>
            </select>
          </div>
          
          <div class="filter-group">
            <label for="seriesFilter">Assignment Series</label>
            <select id="seriesFilter">
              <option value="">All Series</option>
            </select>
          </div>
          
          <div class="filter-group">
            <label>Assignment Range</label>
            <div class="range-selector">
              <button class="range-btn" data-range="first">First</button>
              <button class="range-btn" data-range="latest">Latest</button>
              <button class="range-btn active" data-range="all">All</button>
            </div>
            <div class="range-custom">
              <input type="number" id="rangeStart" placeholder="Start" min="1" />
              <span>to</span>
              <input type="number" id="rangeEnd" placeholder="End" min="1" />
            </div>
          </div>
        </div>
        
        <div class="duplicates-toggle">
          <input type="checkbox" id="includeDuplicates" />
          <label for="includeDuplicates" style="margin: 0; font-size: 13px; font-weight: 600;">Include duplicates (show all entries for same student+assignment)</label>
        </div>
        
        <div class="filter-group" style="margin-top: 20px;">
          <label>Buckets</label>
          <div class="bucket-checkboxes" id="bucketCheckboxes"></div>
          <div class="bucket-actions">
            <button type="button" id="bucketSelectAll">All</button>
            <button type="button" id="bucketClear">None</button>
          </div>
        </div>
      </div>
      
      <div id="statusMessage" class="status-message" style="display:none;"></div>
      
      <div class="charts-section">
        <div class="chart-card" id="examplesPanelCard">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px;">
            <h3 style="margin:0;">Examples of Issues</h3>
            <div style="display:flex; gap:10px; align-items:center;">
              <select id="examplesIssueSelect" class="examples-issue-select" style="display:none;"></select>
              <button class="examples-copy-all-btn" id="examplesPanelCopyBtn" style="display:none;">Create revision assignment</button>
            </div>
          </div>

          <div id="examplesPanelMeta" style="margin-bottom:10px;">
            <div class="examples-modal-bucket" id="examplesPanelBucket"></div>
            <div class="examples-modal-label" id="examplesPanelLabel"></div>
            <div style="margin-top:8px; color: var(--muted); font-size: 13px; font-weight:600;" id="examplesPanelBestWorst"></div>
          </div>

          <div class="chart-container" style="height:300px;">
            <div id="examplesPanelContent" style="height:100%; overflow:auto;">
              <div class="examples-empty">Select an issue from the dropdown above to view examples.</div>
            </div>
          </div>
        </div>
        
        <div class="chart-card">
          <h3>Most Common Issues</h3>
          <div class="chart-container">
            <canvas id="barChart"></canvas>
          </div>
        </div>
      </div>
      
      <div class="chart-card" style="margin-bottom: 24px;">
        <h3>Progress by Category</h3>
        <div class="chart-container">
          <canvas id="bucketChart"></canvas>
        </div>
      </div>
      
      <div class="table-section">
        <h3>
          <span>Data Table</span>
          <div style="display: flex; gap: 8px;">
            <button class="export-btn" id="exportPdfBtn">Export PDF</button>
            <button class="export-btn" id="exportBtn">Export CSV</button>
          </div>
        </h3>
        <table>
          <thead>
            <tr>
              <th class="nowrap">Date</th>
              <th>Student</th>
              <th>Assignment</th>
              <th>Mode</th>
              <th class="nowrap">Total Labels</th>
              <th>Label Counts</th>
            </tr>
          </thead>
          <tbody id="dataTableBody">
            <!-- rows injected by JS -->
          </tbody>
        </table>
      </div>
    </div>
  </main>

  <!-- Examples Modal -->
  <div id="examplesModal" class="examples-modal-overlay" style="display: none;">
    <div class="examples-modal">
      <div class="examples-modal-header">
        <div>
          <div class="examples-modal-bucket" id="modalBucketName"></div>
          <div class="examples-modal-label" id="modalLabel"></div>
        </div>
        <button class="examples-modal-close" id="modalCloseBtn" aria-label="Close">×</button>
      </div>
      <div class="examples-modal-actions">
        <button class="examples-copy-all-btn" id="copyAllBtn">Copy all</button>
      </div>
      <div class="examples-modal-content" id="modalContent">
        <!-- Examples will be rendered here -->
      </div>
    </div>
  </div>

  <script>
    // ===== Bucket definitions =====
    const LABEL_BUCKETS = [
      {
        id: "thesis_org",
        name: "Thesis & Organization",
        matchers: [
          /thesis/i,
          /topic sentence/i,
          /organization/i,
          /transition/i,
          /boundary statement/i,
          /introduction/i,
          /conclusion/i,
          /paragraph/i,
          /structure/i
        ]
      },
      {
        id: "evidence_integration",
        name: "Evidence & Integration",
        matchers: [
          /quote/i,
          /quotation/i,
          /evidence/i,
          /citation/i,
          /\bcite\b/i,
          /works cited/i,
          /power verbs/i,
          /support/i
        ]
      },
      {
        id: "voice_audience",
        name: "Voice & Audience",
        matchers: [
          /personal pronoun/i,
          /\bI\b/i,
          /\bwe\b/i,
          /\byou\b/i,
          /reader/i,
          /audience/i
        ]
      },
      {
        id: "style_clarity",
        name: "Style & Clarity",
        matchers: [
          /contraction/i,
          /\bwhich\b/i,
          /\bfact\b/i,
          /\bprove\b/i,
          /weak verb/i,
          /vague/i,
          /people/i,
          /human/i,
          /word choice/i,
          /avoid using the word/i,
          /more than once in a sentence/i
        ]
      },
      {
        id: "grammar_mechanics",
        name: "Grammar & Mechanics",
        matchers: [
          /subject[- ]verb/i,
          /agreement/i,
          /tense/i,
          /comma/i,
          /punctuation/i,
          /spelling/i,
          /apostrophe/i
        ]
      },
      {
        id: "formatting",
        name: "Formatting & Conventions",
        matchers: [
          /MLA/i,
          /header/i,
          /format/i,
          /title/i,
          /author/i
        ]
      },
      { id: "other", name: "Other", matchers: [] }
    ];

    const BUCKET_OVERRIDES = {
      "Avoid quotations in the conclusion": "evidence_integration",
      "Avoid quotations in the introduction": "evidence_integration",
      "Clarify pronouns and antecedents": "grammar_mechanics",
      "Avoid weak verbs": "evidence_integration"
    };
    
    // ===== Label Canonicalization =====
    // Canonical label groups: maps aliases to canonical display label
    const LABEL_CANONICAL_GROUPS = {
      "Avoid weak verbs": [
        "Refer to the Power Verbs list",
        "Refer to the Power Verbs List",
        "Avoid weak verbs"
      ]
    };
    
    // Helper: normalize label string (lowercase + trim)
    function normalizeLabel(s) {
      if (!s) return "";
      return String(s).toLowerCase().trim();
    }
    
    // Helper: get canonical label for a given label
    function canonicalLabel(label) {
      if (!label) return label;
      const normalized = normalizeLabel(label);
      
      // Check each canonical group
      for (const [canonical, aliases] of Object.entries(LABEL_CANONICAL_GROUPS)) {
        const normalizedAliases = aliases.map(normalizeLabel);
        if (normalizedAliases.includes(normalized)) {
          return canonical;
        }
      }
      
      return label; // Return original if no canonical found
    }
    
    // Helper: get all aliases (including canonical) for a canonical label
    function labelAliasesForQuery(canonical) {
      if (!canonical) return [canonical];
      const group = LABEL_CANONICAL_GROUPS[canonical];
      if (group) {
        return [...group]; // Return all aliases including canonical
      }
      return [canonical]; // Return just the label if no group
    }
    
    // Helper: get display label (canonicalized)
    function displayLabel(label) {
      return canonicalLabel(label);
    }

    // Shared bucket color palette (same order as LABEL_BUCKETS)
    // Thesis maroon, Evidence blue, Voice green, Style yellow, Grammar purple, Formatting red, Other teal
    const BUCKET_COLORS = [
      "rgba(169, 13, 34, 1)",    // maroon - Thesis & Organization
      "rgba(52, 152, 219, 1)",   // blue - Evidence & Integration
      "rgba(46, 204, 113, 1)",   // green - Voice & Audience
      "rgba(241, 196, 15, 1)",   // yellow - Style & Clarity
      "rgba(155, 89, 182, 1)",   // purple - Grammar & Mechanics
      "rgba(231, 76, 60, 1)",    // red - Formatting & Conventions
      "rgba(26, 188, 156, 1)",   // teal - Other
    ];

    // Helper function to get bucket color by bucketId
    // Returns color with specified alpha (default 1.0 for full opacity)
    function getBucketColor(bucketId, alpha = 1.0) {
      const bucketIndex = LABEL_BUCKETS.findIndex(b => b.id === bucketId);
      if (bucketIndex === -1) {
        // Fallback to "other" color if bucket not found
        const otherIndex = LABEL_BUCKETS.findIndex(b => b.id === "other");
        const baseColor = BUCKET_COLORS[otherIndex >= 0 ? otherIndex : BUCKET_COLORS.length - 1];
        return baseColor.replace("1)", `${alpha})`);
      }
      const baseColor = BUCKET_COLORS[bucketIndex];
      return baseColor.replace("1)", `${alpha})`);
    }

    function getBucketIdForLabel(label) {
      if (!label) return "other";
      if (BUCKET_OVERRIDES[label]) return BUCKET_OVERRIDES[label];
      for (const b of LABEL_BUCKETS) {
        if (b.id === "other") continue;
        if (b.matchers.some(rx => rx.test(label))) return b.id;
      }
      return "other";
    }

    // ===== Supabase config =====
    const SUPABASE_URL = "https://divdfodsdtfbdwoqvsfy.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRpdmRmb2RzZHRmYmR3b3F2c2Z5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU0MjU1OTksImV4cCI6MjA4MTAwMTU5OX0.fnm_9qX5DqdR0j6y-2mRRkwr8Icm1uRNPbUo6lqzock";
    
    const { createClient } = supabase;
    const supa = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    
    const progressPage = document.getElementById("progressPage");
    const logoutBtn = document.getElementById("logoutBtn");
    const classFilter = document.getElementById("classFilter");
    const studentFilter = document.getElementById("studentFilter");
    const seriesFilter = document.getElementById("seriesFilter");
    const rangeBtns = document.querySelectorAll(".range-btn");
    const rangeStart = document.getElementById("rangeStart");
    const rangeEnd = document.getElementById("rangeEnd");
    const includeDuplicates = document.getElementById("includeDuplicates");
    const statusMessage = document.getElementById("statusMessage");
    const dataTableBody = document.getElementById("dataTableBody");
    const exportBtn = document.getElementById("exportBtn");
    
    let allData = [];
    let filteredData = [];
    let lineChart = null;
    let barChart = null;
    let bucketChart = null;
    let currentRange = "all";
    
    // ===== URL class_id handling =====
    let appliedUrlClassId = false;
    let initialClassIdFromUrl = null;
    
    // Helper: get URL parameter
    function getUrlParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }
    
    // Helper: clear URL parameter
    function clearUrlParam(name) {
      const url = new URL(window.location.href);
      url.searchParams.delete(name);
      window.history.replaceState({}, "", url.toString());
    }
    
    // ===== Auth =====
    async function refreshAuthUI() {
      const { data } = await supa.auth.getSession();
      const session = data.session;
      
      if (!session) {
        window.location.replace("/signin.html");
        return;
      }
      
      progressPage.style.display = "block";
      loadData();
    }
    
    logoutBtn.addEventListener("click", async () => {
      await supa.auth.signOut();
      localStorage.removeItem("vysti_role");
      window.location.replace("/signin.html");
    });
    
    supa.auth.onAuthStateChange((_event, _session) => {
      refreshAuthUI();
    });
    
    // ===== Assignment name parsing =====
    
    // Normalize series string to a stable key for comparison
    // - Lowercase
    // - Remove spaces/underscores/hyphens and other non-alphanumerics
    // - Expand trailing "hw" -> "homework" (so "advancedhw" becomes "advancedhomework")
    function normalizeSeriesKey(seriesRaw) {
      if (!seriesRaw) return "";
      let normalized = seriesRaw.toLowerCase();
      // Remove all non-alphanumeric characters
      normalized = normalized.replace(/[^a-z0-9]/g, "");
      // Expand trailing "hw" -> "homework" (but only if it's at the end with no preceding whitespace)
      // This handles "advancedhw" -> "advancedhomework" but not "hw02" (which would be "hw" + number)
      if (normalized.endsWith("hw") && normalized.length > 2) {
        normalized = normalized.slice(0, -2) + "homework";
      }
      return normalized;
    }
    
    // Create human-readable display string for series
    // - Trim, collapse whitespace
    // - If the raw series ends with "HW" with no preceding whitespace, convert "...HW" -> "... Homework"
    function seriesDisplay(seriesRaw) {
      if (!seriesRaw) return "";
      // Trim and collapse whitespace
      let display = seriesRaw.trim().replace(/\s+/g, " ");
      // If it ends with "HW" (case-insensitive, no space before it), expand to " Homework"
      // Match pattern like "AdvancedHW" but not "Advanced HW" or just "HW"
      if (display.length > 2 && /[A-Za-z]HW$/i.test(display)) {
        // Replace trailing "HW" (case-insensitive) with " Homework"
        display = display.replace(/HW$/i, " Homework");
      }
      return display;
    }
    
    function parseAssignmentName(name) {
      if (!name) return { seriesRaw: "", seriesDisplay: "", seriesKey: "", number: null, original: name };
      
      // Extract trailing number for natural numeric sort
      // Handles: "Foundation HW06", "HW02", "Foundation 3", "High Level HW11", etc.
      const numMatch = name.match(/(\d+)$/);
      if (numMatch) {
        const number = parseInt(numMatch[1], 10);
        // Extract series (everything before the trailing number)
        const seriesMatch = name.match(/^(.+?)\s*\d+$/);
        const seriesRaw = seriesMatch ? seriesMatch[1].trim() : "";
        
        return {
          seriesRaw: seriesRaw,
          seriesDisplay: seriesDisplay(seriesRaw),
          seriesKey: normalizeSeriesKey(seriesRaw),
          number: number,
          original: name
        };
      }
      
      // Fallback: try to match pattern like "Foundation 3" at the start
      const match = name.match(/^([A-Za-z]+)\s*(\d+)/);
      if (match) {
        const seriesRaw = match[1];
        return {
          seriesRaw: seriesRaw,
          seriesDisplay: seriesDisplay(seriesRaw),
          seriesKey: normalizeSeriesKey(seriesRaw),
          number: parseInt(match[2], 10),
          original: name
        };
      }
      
      return { seriesRaw: "", seriesDisplay: "", seriesKey: "", number: null, original: name };
    }
    
    // ===== Data loading =====
    async function loadData() {
      statusMessage.style.display = "block";
      statusMessage.textContent = "Loading data...";
      
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        window.location.replace("/signin.html");
        return;
      }
      
      // Read class_id from URL query string only once on initial load (before applying it)
      if (!appliedUrlClassId) {
        const urlClassId = getUrlParam("class_id");
        if (urlClassId) {
          initialClassIdFromUrl = urlClassId;
        } else {
          initialClassIdFromUrl = null;
          // Mark as applied even if no URL param (so we don't check again)
          appliedUrlClassId = true;
        }
      }
      
      // Load classes first (this will apply URL class_id if needed and set appliedUrlClassId)
      await loadClasses();
      
      // Build query - always use dropdown value (which will be set from URL in loadClasses if needed)
      let query = supa
        .from("mark_events")
        .select("created_at, student_name, assignment_name, mode, total_labels, label_counts, issues, class_id")
        .eq("user_id", sessionData.session.user.id);
      
      // Always use dropdown value now
      const selectedClass = classFilter.value;
      if (selectedClass === "__unassigned__") {
        query = query.is("class_id", null);
      } else if (selectedClass) {
        query = query.eq("class_id", selectedClass);
      }
      
      const { data, error } = await query.order("created_at", { ascending: false });
      
      if (error) {
        statusMessage.textContent = `Error loading data: ${error.message}`;
        return;
      }
      
      if (!data || data.length === 0) {
        statusMessage.textContent = "No data found.";
        allData = [];
        filteredData = [];
        updateUI();
        return;
      }
      
      allData = data;
      statusMessage.style.display = "none";
      
      updateFilters();
      buildBucketCheckboxes();
      applyFilters();
    }
    
    // ===== Load classes =====
    async function loadClasses() {
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) return;
      
      // Preserve current selection before repopulating
      const currentSelection = classFilter.value;
      
      const { data, error } = await supa
        .from("classes")
        .select("*")
        .eq("user_id", sessionData.session.user.id)
        .eq("archived", false)
        .order("created_at", { ascending: false });
      
      if (error) {
        console.error("Error loading classes:", error);
        return;
      }
      
      classFilter.innerHTML = '<option value="">All Classes</option><option value="__unassigned__">Unassigned</option>';
      (data || []).forEach(cls => {
        const option = document.createElement("option");
        option.value = cls.id;
        option.textContent = cls.name;
        classFilter.appendChild(option);
      });
      
      // Apply initial URL class_id only once after classes are loaded, otherwise restore previous selection
      if (initialClassIdFromUrl !== null) {
        // Check if the option exists in the dropdown
        const optionExists = Array.from(classFilter.options).some(opt => opt.value === initialClassIdFromUrl);
        if (optionExists) {
          classFilter.value = initialClassIdFromUrl;
        }
        // Mark as applied and clear the URL parameter immediately after applying
        appliedUrlClassId = true;
        clearUrlParam("class_id");
        // Clear the initial value so it's not used again
        initialClassIdFromUrl = null;
      } else if (currentSelection) {
        // Restore previous selection if URL class_id wasn't applied
        const optionExists = Array.from(classFilter.options).some(opt => opt.value === currentSelection);
        if (optionExists) {
          classFilter.value = currentSelection;
        }
      }
    }
    
    // ===== Bucket selection =====
    function buildBucketCheckboxes() {
      const container = document.getElementById("bucketCheckboxes");
      container.innerHTML = "";
      
      const savedSelection = localStorage.getItem("vysti_bucket_selection");
      let selectedBuckets = [];
      if (savedSelection) {
        try {
          selectedBuckets = JSON.parse(savedSelection);
        } catch (e) {
          selectedBuckets = LABEL_BUCKETS.filter(b => b.id !== "other").map(b => b.id);
        }
      } else {
        // Default: select all except "other"
        selectedBuckets = LABEL_BUCKETS.filter(b => b.id !== "other").map(b => b.id);
      }
      
      LABEL_BUCKETS.forEach(bucket => {
        if (bucket.id === "other") return; // Skip "other" from UI
        
        const label = document.createElement("label");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = bucket.id;
        checkbox.checked = selectedBuckets.includes(bucket.id);
        checkbox.addEventListener("change", () => {
          saveBucketSelection();
          updateCharts();
        });
        
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(bucket.name));
        container.appendChild(label);
      });
    }
    
    function saveBucketSelection() {
      const selected = getSelectedBucketIds();
      localStorage.setItem("vysti_bucket_selection", JSON.stringify(selected));
    }
    
    function getSelectedBucketIds() {
      const checkboxes = document.querySelectorAll("#bucketCheckboxes input[type='checkbox']");
      return Array.from(checkboxes)
        .filter(cb => cb.checked)
        .map(cb => cb.value);
    }
    
    document.getElementById("bucketSelectAll").addEventListener("click", () => {
      const checkboxes = document.querySelectorAll("#bucketCheckboxes input[type='checkbox']");
      checkboxes.forEach(cb => cb.checked = true);
      saveBucketSelection();
      updateCharts();
    });
    
    document.getElementById("bucketClear").addEventListener("click", () => {
      const checkboxes = document.querySelectorAll("#bucketCheckboxes input[type='checkbox']");
      checkboxes.forEach(cb => cb.checked = false);
      saveBucketSelection();
      updateCharts();
    });
    
    function bucketCountsFromRow(row) {
      const out = new Map(); // bucketId -> count
      if (!row.label_counts || typeof row.label_counts !== "object") return out;
      for (const [label, raw] of Object.entries(row.label_counts)) {
        const n = typeof raw === "number" ? raw : parseInt(raw, 10) || 0;
        const bucketId = getBucketIdForLabel(label);
        out.set(bucketId, (out.get(bucketId) || 0) + n);
      }
      return out;
    }
    
    // Build a label → explanation lookup map from rows
    function buildLabelExplanationMap(rows) {
      const map = new Map();
      for (const row of rows) {
        let issues = row.issues;
        
        // Handle null/undefined
        if (!issues) {
          issues = [];
        }
        // Handle string (rare case - JSON string)
        else if (typeof issues === "string") {
          try {
            issues = JSON.parse(issues);
          } catch (e) {
            issues = [];
          }
        }
        // Ensure it's an array
        if (!Array.isArray(issues)) {
          issues = [];
        }
        
        for (const issue of issues) {
          const label = issue?.label;
          const expl = issue?.explanation;
          if (!label || !expl) continue;
          
          // Prefer first explanation OR prefer the longer one if conflicts exist
          const prev = map.get(label);
          if (!prev || (typeof prev === "string" && expl.length > prev.length)) {
            map.set(label, expl);
          }
        }
      }
      return map;
    }
    
    function computeWorstBestStudentsForLabel(rows, label) {
      const perStudent = new Map(); // student_name -> count
      const canonical = canonicalLabel(label);
      
      for (const row of rows) {
        const student = (row.student_name || "").trim();
        if (!student) continue;

        const obj = row.label_counts && typeof row.label_counts === "object" ? row.label_counts : {};
        let studentTotal = perStudent.get(student) || 0;
        
        // Sum counts for all aliases of the canonical label
        Object.entries(obj).forEach(([entryLabel, raw]) => {
          const entryCanonical = canonicalLabel(entryLabel);
          if (entryCanonical === canonical) {
            const n = typeof raw === "number" ? raw : (parseInt(raw, 10) || 0);
            studentTotal += n;
          }
        });
        
        perStudent.set(student, studentTotal);
      }

      if (perStudent.size === 0) {
        return { worst: "—", best: "—" };
      }

      // Worst = highest count, Best = lowest count
      let worstStudent = null, worstCount = -Infinity;
      let bestStudent = null, bestCount = Infinity;

      for (const [student, count] of perStudent.entries()) {
        if (count > worstCount) { worstCount = count; worstStudent = student; }
        if (count < bestCount) { bestCount = count; bestStudent = student; }
      }

      return { worst: worstStudent || "—", best: bestStudent || "—" };
    }
    
    // Wrap text for tooltip display
    function wrapTooltipText(text, maxLineLen = 70) {
      const words = text.split(/\s+/).filter(Boolean);
      const lines = [];
      let line = "";
      for (const w of words) {
        const test = line ? line + " " + w : w;
        if (test.length > maxLineLen) {
          if (line) lines.push(line);
          line = w;
        } else {
          line = test;
        }
      }
      if (line) lines.push(line);
      return lines;
    }
    
    // ===== Filter updates =====
    function updateFilters() {
      // Update student filter - only show students from filtered dataset
      const students = [...new Set(allData.map(r => r.student_name).filter(Boolean))].sort();
      studentFilter.innerHTML = '<option value="">All Students</option>';
      students.forEach(student => {
        const option = document.createElement("option");
        option.value = student;
        option.textContent = student;
        studentFilter.appendChild(option);
      });
      
      // Update series filter - build map of seriesKey -> best display string
      const seriesKeyToDisplay = new Map(); // seriesKey -> best display string
      allData.forEach(row => {
        const parsed = parseAssignmentName(row.assignment_name);
        if (parsed.seriesKey) {
          const existing = seriesKeyToDisplay.get(parsed.seriesKey);
          if (!existing) {
            // First occurrence, use it
            seriesKeyToDisplay.set(parsed.seriesKey, parsed.seriesDisplay || parsed.seriesRaw);
          } else {
            // Choose "best" display string by preferring:
            // 1) strings containing spaces (more readable)
            // 2) longer strings
            const candidate = parsed.seriesDisplay || parsed.seriesRaw;
            const existingHasSpace = existing.includes(" ");
            const candidateHasSpace = candidate.includes(" ");
            if (candidateHasSpace && !existingHasSpace) {
              seriesKeyToDisplay.set(parsed.seriesKey, candidate);
            } else if (candidate.length > existing.length && (candidateHasSpace === existingHasSpace)) {
              seriesKeyToDisplay.set(parsed.seriesKey, candidate);
            }
          }
        }
      });
      const seriesKeys = Array.from(seriesKeyToDisplay.keys()).sort();
      seriesFilter.innerHTML = '<option value="">All Series</option>';
      seriesKeys.forEach(seriesKey => {
        const option = document.createElement("option");
        option.value = seriesKey;
        option.textContent = seriesKeyToDisplay.get(seriesKey);
        seriesFilter.appendChild(option);
      });
    }
    
    // ===== Filter application =====
    function applyFilters() {
      // Start with data sorted by created_at descending (most recent first)
      let filtered = [...allData].sort((a, b) => 
        new Date(b.created_at) - new Date(a.created_at)
      );
      
      // Handle duplicates: if not including duplicates, keep only most recent per student+assignment
      // Since data is sorted by created_at descending, first occurrence is most recent
      if (!includeDuplicates.checked) {
        const seen = new Set();
        filtered = filtered.filter(row => {
          const key = `${row.student_name || ""}::${row.assignment_name || ""}`;
          if (!key || key === "::") return true; // Keep rows without student/assignment
          
          if (seen.has(key)) {
            return false; // Already seen this combination, skip (we keep the first/most recent)
          }
          seen.add(key);
          return true;
        });
      }
      
      // Apply student filter
      const selectedStudent = studentFilter.value;
      if (selectedStudent) {
        filtered = filtered.filter(r => r.student_name === selectedStudent);
      }
      
      // Apply series filter
      const selectedSeriesKey = seriesFilter.value;
      if (selectedSeriesKey) {
        filtered = filtered.filter(r => {
          const parsed = parseAssignmentName(r.assignment_name);
          return parsed.seriesKey === selectedSeriesKey;
        });
      }
      
      // Sort by assignment (series then number, with unparseable at end)
      filtered.sort((a, b) => {
        const aParsed = parseAssignmentName(a.assignment_name);
        const bParsed = parseAssignmentName(b.assignment_name);
        
        // Unparseable go to end
        if (aParsed.number === null && bParsed.number !== null) return 1;
        if (aParsed.number !== null && bParsed.number === null) return -1;
        if (aParsed.number === null && bParsed.number === null) {
          return (aParsed.original || "").localeCompare(bParsed.original || "");
        }
        
        // If series filter is applied, just sort by number
        if (selectedSeriesKey && aParsed.seriesKey === selectedSeriesKey && bParsed.seriesKey === selectedSeriesKey) {
          return aParsed.number - bParsed.number;
        }
        
        // Otherwise sort by seriesKey then number (so "AdvancedHW" + "Advanced Homework" are grouped together)
        if (aParsed.seriesKey !== bParsed.seriesKey) {
          return aParsed.seriesKey.localeCompare(bParsed.seriesKey);
        }
        return aParsed.number - bParsed.number;
      });
      
      // Apply range filter
      if (currentRange === "first") {
        // Filter to only the earliest numbered assignment (respecting Series filter)
        const numberedAssignments = filtered.filter(row => {
          const parsed = parseAssignmentName(row.assignment_name);
          return parsed.number !== null;
        });
        
        if (numberedAssignments.length > 0) {
          // Find the earliest assignment number
          let earliestNum = Infinity;
          numberedAssignments.forEach(row => {
            const parsed = parseAssignmentName(row.assignment_name);
            if (parsed.number !== null && parsed.number < earliestNum) {
              earliestNum = parsed.number;
            }
          });
          
          // Filter to only assignments with the earliest number
          filtered = filtered.filter(row => {
            const parsed = parseAssignmentName(row.assignment_name);
            return parsed.number === earliestNum;
          });
        }
        // If no numbered assignments, keep current filter (don't crash)
      } else if (currentRange === "latest") {
        // Filter to only the most recent/highest numbered assignment (respecting Series filter)
        const numberedAssignments = filtered.filter(row => {
          const parsed = parseAssignmentName(row.assignment_name);
          return parsed.number !== null;
        });
        
        if (numberedAssignments.length > 0) {
          // Find the latest assignment number
          let latestNum = -Infinity;
          numberedAssignments.forEach(row => {
            const parsed = parseAssignmentName(row.assignment_name);
            if (parsed.number !== null && parsed.number > latestNum) {
              latestNum = parsed.number;
            }
          });
          
          // Filter to only assignments with the latest number
          filtered = filtered.filter(row => {
            const parsed = parseAssignmentName(row.assignment_name);
            return parsed.number === latestNum;
          });
        }
        // If no numbered assignments, keep current filter (don't crash)
      } else if (currentRange !== "all") {
        const num = parseInt(currentRange, 10);
        if (!isNaN(num)) {
          filtered = filtered.slice(0, num);
        } else if (rangeStart.value && rangeEnd.value) {
          const start = parseInt(rangeStart.value, 10) - 1; // 0-indexed
          const end = parseInt(rangeEnd.value, 10);
          filtered = filtered.slice(start, end);
        }
      } else if (rangeStart.value && rangeEnd.value) {
        const start = parseInt(rangeStart.value, 10) - 1;
        const end = parseInt(rangeEnd.value, 10);
        filtered = filtered.slice(start, end);
      }
      
      filteredData = filtered;
      updateUI();
    }
    
    // ===== UI updates =====
    function updateUI() {
      updateCharts();
      updateTable();
    }
    
    function updateCharts() {
      updateLineChart();
      updateBarChart();
      updateBucketChart();
    }
    
    function updateLineChart() {
      const canvas = document.getElementById("lineChart");
      if (!canvas) return;
      
      const ctx = canvas.getContext("2d");
      
      if (lineChart) {
        lineChart.destroy();
      }
      
      const selectedStudent = studentFilter.value;
      const selectedSeriesKey = seriesFilter.value;
      
      // Group data for line chart
      if (selectedStudent) {
        // Per student: show their assignments
        const studentData = filteredData.filter(r => r.student_name === selectedStudent);
        const labels = studentData.map((r, i) => {
          const parsed = parseAssignmentName(r.assignment_name);
          if (parsed.number !== null) {
            return selectedSeriesKey && parsed.seriesKey === selectedSeriesKey ? `#${parsed.number}` : r.assignment_name;
          }
          return r.assignment_name || `Assignment ${i + 1}`;
        });
        const data = studentData.map(r => r.total_labels || 0);
        
        lineChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: labels,
            datasets: [{
              label: `${selectedStudent} - Total Labels`,
              data: data,
              borderColor: "rgb(169, 13, 34)",
              backgroundColor: "rgba(169, 13, 34, 0.1)",
              tension: 0.1,
              fill: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true
              }
            }
          }
        });
      } else {
        // Class average: group by assignment
        const assignmentMap = new Map();
        filteredData.forEach(row => {
          const key = row.assignment_name || "Unnamed";
          if (!assignmentMap.has(key)) {
            assignmentMap.set(key, { total: 0, count: 0 });
          }
          const entry = assignmentMap.get(key);
          entry.total += row.total_labels || 0;
          entry.count += 1;
        });
        
        const assignments = Array.from(assignmentMap.entries())
          .map(([name, stats]) => ({
            name,
            avg: stats.count > 0 ? stats.total / stats.count : 0
          }))
          .sort((a, b) => {
            const aParsed = parseAssignmentName(a.name);
            const bParsed = parseAssignmentName(b.name);
            if (aParsed.number === null && bParsed.number !== null) return 1;
            if (aParsed.number !== null && bParsed.number === null) return -1;
            if (aParsed.number === null) return 0;
            if (selectedSeriesKey && aParsed.seriesKey === selectedSeriesKey && bParsed.seriesKey === selectedSeriesKey) {
              return aParsed.number - bParsed.number;
            }
            if (aParsed.seriesKey !== bParsed.seriesKey) {
              return aParsed.seriesKey.localeCompare(bParsed.seriesKey);
            }
            return aParsed.number - bParsed.number;
          });
        
        lineChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: assignments.map(a => {
              const parsed = parseAssignmentName(a.name);
              return selectedSeriesKey && parsed.seriesKey === selectedSeriesKey 
                ? `#${parsed.number}` 
                : a.name;
            }),
            datasets: [{
              label: "Class Average - Total Labels",
              data: assignments.map(a => a.avg),
              borderColor: "rgb(169, 13, 34)",
              backgroundColor: "rgba(169, 13, 34, 0.1)",
              tension: 0.1,
              fill: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true
              }
            }
          }
        });
      }
    }
    
    function updateBarChart() {
      const ctx = document.getElementById("barChart").getContext("2d");
      
      if (barChart) {
        barChart.destroy();
      }
      
      const selectedBucketIds = getSelectedBucketIds();
      
      // Count non-"other" buckets
      const nonOtherBuckets = LABEL_BUCKETS.filter(b => b.id !== "other").length;
      const allBucketsSelected = selectedBucketIds.length === nonOtherBuckets;
      
      // Aggregate label_counts across filtered data
      const labelCounter = new Map();
      
      // If all buckets are selected, or no buckets selected, show all labels (default behavior)
      // Otherwise, filter by selected buckets
      if (!allBucketsSelected && selectedBucketIds.length > 0) {
        filteredData.forEach(row => {
          if (row.label_counts && typeof row.label_counts === 'object') {
            Object.entries(row.label_counts).forEach(([label, count]) => {
              // Only include label if its bucket is selected
              const bucketId = getBucketIdForLabel(label);
              if (selectedBucketIds.includes(bucketId)) {
                const currentCount = labelCounter.get(label) || 0;
                labelCounter.set(label, currentCount + (typeof count === 'number' ? count : parseInt(count, 10) || 0));
              }
            });
          }
        });
      } else {
        // If all buckets selected or none selected, include all labels (default behavior)
        filteredData.forEach(row => {
          if (row.label_counts && typeof row.label_counts === 'object') {
            Object.entries(row.label_counts).forEach(([label, count]) => {
              const currentCount = labelCounter.get(label) || 0;
              labelCounter.set(label, currentCount + (typeof count === 'number' ? count : parseInt(count, 10) || 0));
            });
          }
        });
      }
      
      // Aggregate counts by canonical label (sum all aliases)
      const canonicalCounter = new Map(); // canonical -> totalCount
      labelCounter.forEach((count, label) => {
        const canonical = canonicalLabel(label);
        const existing = canonicalCounter.get(canonical) || 0;
        canonicalCounter.set(canonical, existing + count);
      });
      
      const topLabels = Array.from(canonicalCounter.entries())
        .map(([canonical, count]) => ({ label: canonical, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 8);
      
      // Build explanation map from filtered data
      const explMap = buildLabelExplanationMap(filteredData);
      const explanations = topLabels.map(l => explMap.get(l.label) || "");
      
      // Compute bucket names, worst students, and best students
      const bucketNames = topLabels.map(l => {
        const id = getBucketIdForLabel(l.label);
        return LABEL_BUCKETS.find(b => b.id === id)?.name || "Other";
      });
      
      const worstStudents = topLabels.map(l => computeWorstBestStudentsForLabel(filteredData, l.label).worst);
      const bestStudents = topLabels.map(l => computeWorstBestStudentsForLabel(filteredData, l.label).best);
      
      // Populate dropdown
      const examplesIssueSelect = document.getElementById("examplesIssueSelect");
      if (examplesIssueSelect) {
        examplesIssueSelect.innerHTML = "";
        if (topLabels.length > 0) {
          topLabels.forEach(({ label, count }) => {
            const option = document.createElement("option");
            option.value = label; // Store canonical label
            option.textContent = `${displayLabel(label)} (${count})`;
            examplesIssueSelect.appendChild(option);
          });
          examplesIssueSelect.style.display = "block";
          
          // Set default selection to first item
          examplesIssueSelect.value = topLabels[0].label;
        } else {
          examplesIssueSelect.style.display = "none";
        }
      }
      
      // Map each label to its bucket color
      const backgroundColor = topLabels.map(l => {
        const bucketId = getBucketIdForLabel(l.label);
        return getBucketColor(bucketId, 0.6);
      });
      const borderColor = topLabels.map(l => {
        const bucketId = getBucketIdForLabel(l.label);
        return getBucketColor(bucketId, 1.0);
      });
      
      barChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: topLabels.map(l => displayLabel(l.label)),
          datasets: [{
            label: "Count",
            data: topLabels.map(l => l.count),
            canonicalLabels: topLabels.map(l => l.label), // Store canonical labels for onClick
            explanations: explanations,
            bucketNames: bucketNames,
            worstStudents: worstStudents,
            bestStudents: bestStudents,
            backgroundColor: backgroundColor,
            borderColor: borderColor,
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true
            }
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              displayColors: false,
              callbacks: {
                title: (items) => {
                  const item = items?.[0];
                  if (!item) return "";
                  const idx = item.dataIndex;
                  return item.dataset?.bucketNames?.[idx] || "";
                },
                afterTitle: (items) => {
                  const item = items?.[0];
                  if (!item) return "";
                  // This is the issue label on the x-axis
                  return item.label || "";
                },
                label: (item) => {
                  const idx = item.dataIndex;
                  const worst = item.dataset?.worstStudents?.[idx] || "—";
                  const best  = item.dataset?.bestStudents?.[idx] || "—";
                  // One line to conserve space
                  return `Worst: ${worst}   Best: ${best}`;
                },
                afterBody: (items) => {
                  const item = items?.[0];
                  if (!item) return [];
                  const idx = item.dataIndex;
                  const expl = item.dataset?.explanations?.[idx];
                  if (!expl) return [];

                  const lines = wrapTooltipText(String(expl).trim(), 70);
                  const maxLines = 10;
                  const clipped = lines.slice(0, maxLines);

                  // If we clipped, add ellipsis to the last line
                  if (lines.length > maxLines && clipped.length) {
                    clipped[clipped.length - 1] = clipped[clipped.length - 1].replace(/[.…]?$/, "…");
                  }
                  return clipped;
                },
                footer: () => {
                  return "Examples shown on the left";
                }
              },
              footerColor: "#fff",
              footerFont: {
                weight: "700"
              }
            }
          },
          onHover: (event, activeElements) => {
            event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
          },
          onClick: (event, activeElements) => {
            if (activeElements.length === 0) return;
            const item = activeElements[0];
            const idx = item.dataIndex;
            const ds = item.chart.data.datasets[0];
            const canonical = ds?.canonicalLabels?.[idx] || item.chart.data.labels[idx];
            const bucketName = ds?.bucketNames?.[idx] || "";
            
            // Update dropdown to match clicked bar
            const examplesIssueSelect = document.getElementById("examplesIssueSelect");
            if (examplesIssueSelect) {
              examplesIssueSelect.value = canonical;
            }
            
            loadExamplesPanel({ label: canonical, bucketName });
          }
        }
      });
      
      // Preload examples for the first bar
      if (topLabels.length > 0) {
        const firstLabel = topLabels[0].label;
        const firstBucketName = bucketNames[0] || "";
        loadExamplesPanel({ label: firstLabel, bucketName: firstBucketName });
      } else if (examplesPanelContent) {
        examplesPanelContent.innerHTML = '<div class="examples-empty">No issues found for the current filters.</div>';
        if (examplesPanelCopyBtn) examplesPanelCopyBtn.style.display = "none";
        const examplesIssueSelect = document.getElementById("examplesIssueSelect");
        if (examplesIssueSelect) examplesIssueSelect.style.display = "none";
      }
    }
    
    function updateBucketChart() {
      const canvas = document.getElementById("bucketChart");
      const parent = canvas.parentElement;
      
      if (bucketChart) {
        bucketChart.destroy();
        bucketChart = null;
      }
      
      const selectedBucketIds = getSelectedBucketIds();
      
      if (selectedBucketIds.length === 0) {
        // Clear chart if no buckets selected
        const message = document.createElement("div");
        message.style.textAlign = "center";
        message.style.padding = "40px";
        message.style.color = "var(--muted)";
        message.textContent = "Please select at least one bucket to view chart";
        message.id = "bucketChartMessage";
        
        // Remove existing message if present
        const existing = parent.querySelector("#bucketChartMessage");
        if (existing) existing.remove();
        
        parent.appendChild(message);
        canvas.style.display = "none";
        return;
      }
      
      // Remove message and show canvas if buckets are selected
      const existing = parent.querySelector("#bucketChartMessage");
      if (existing) existing.remove();
      canvas.style.display = "block";
      
      const ctx = canvas.getContext("2d");
      
      const selectedStudent = studentFilter.value;
      const selectedSeriesKey = seriesFilter.value;
      
      if (selectedStudent) {
        // Per student: show their bucket totals per assignment
        const studentData = filteredData.filter(r => r.student_name === selectedStudent);
        
        // Build assignment map with bucket totals
        const assignmentMap = new Map();
        studentData.forEach(row => {
          const key = row.assignment_name || "Unnamed";
          if (!assignmentMap.has(key)) {
            assignmentMap.set(key, new Map());
          }
          const bucketCounts = bucketCountsFromRow(row);
          bucketCounts.forEach((count, bucketId) => {
            const current = assignmentMap.get(key).get(bucketId) || 0;
            assignmentMap.get(key).set(bucketId, current + count);
          });
        });
        
        // Convert to sorted assignments array
        const assignments = Array.from(assignmentMap.entries())
          .map(([name, bucketMap]) => ({ name, bucketMap }))
          .sort((a, b) => {
            const aParsed = parseAssignmentName(a.name);
            const bParsed = parseAssignmentName(b.name);
            if (aParsed.number === null && bParsed.number !== null) return 1;
            if (aParsed.number !== null && bParsed.number === null) return -1;
            if (aParsed.number === null) return 0;
            if (selectedSeriesKey && aParsed.seriesKey === selectedSeriesKey && bParsed.seriesKey === selectedSeriesKey) {
              return aParsed.number - bParsed.number;
            }
            if (aParsed.seriesKey !== bParsed.seriesKey) {
              return aParsed.seriesKey.localeCompare(bParsed.seriesKey);
            }
            return aParsed.number - bParsed.number;
          });
        
        const labels = assignments.map(a => {
          const parsed = parseAssignmentName(a.name);
          return selectedSeriesKey && parsed.seriesKey === selectedSeriesKey 
            ? `#${parsed.number}` 
            : a.name;
        });
        
        // Build datasets for selected buckets (in LABEL_BUCKETS order)
        const datasets = [];
        LABEL_BUCKETS.forEach((bucket, idx) => {
          if (!selectedBucketIds.includes(bucket.id)) return;
          
          const data = assignments.map(a => a.bucketMap.get(bucket.id) || 0);
          datasets.push({
            label: bucket.name,
            data: data,
            backgroundColor: getBucketColor(bucket.id, 0.8),
            borderColor: getBucketColor(bucket.id, 1.0),
            borderWidth: 1
          });
        });
        
        bucketChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: labels,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                stacked: true
              },
              y: {
                stacked: true,
                beginAtZero: true
              }
            }
          }
        });
      } else {
        // Class average: group by assignment and compute averages
        const assignmentMap = new Map();
        const assignmentCountMap = new Map();
        
        filteredData.forEach(row => {
          const key = row.assignment_name || "Unnamed";
          if (!assignmentMap.has(key)) {
            assignmentMap.set(key, new Map());
            assignmentCountMap.set(key, 0);
          }
          assignmentCountMap.set(key, assignmentCountMap.get(key) + 1);
          
          const bucketCounts = bucketCountsFromRow(row);
          bucketCounts.forEach((count, bucketId) => {
            const current = assignmentMap.get(key).get(bucketId) || 0;
            assignmentMap.get(key).set(bucketId, current + count);
          });
        });
        
        // Convert to sorted assignments array with averages
        const assignments = Array.from(assignmentMap.entries())
          .map(([name, bucketMap]) => {
            const count = assignmentCountMap.get(name) || 1;
            const avgBucketMap = new Map();
            bucketMap.forEach((total, bucketId) => {
              avgBucketMap.set(bucketId, total / count);
            });
            return { name, avgBucketMap };
          })
          .sort((a, b) => {
            const aParsed = parseAssignmentName(a.name);
            const bParsed = parseAssignmentName(b.name);
            if (aParsed.number === null && bParsed.number !== null) return 1;
            if (aParsed.number !== null && bParsed.number === null) return -1;
            if (aParsed.number === null) return 0;
            if (selectedSeriesKey && aParsed.seriesKey === selectedSeriesKey && bParsed.seriesKey === selectedSeriesKey) {
              return aParsed.number - bParsed.number;
            }
            if (aParsed.seriesKey !== bParsed.seriesKey) {
              return aParsed.seriesKey.localeCompare(bParsed.seriesKey);
            }
            return aParsed.number - bParsed.number;
          });
        
        const labels = assignments.map(a => {
          const parsed = parseAssignmentName(a.name);
          return selectedSeriesKey && parsed.seriesKey === selectedSeriesKey 
            ? `#${parsed.number}` 
            : a.name;
        });
        
        // Build datasets for selected buckets (in LABEL_BUCKETS order)
        const datasets = [];
        LABEL_BUCKETS.forEach((bucket, idx) => {
          if (!selectedBucketIds.includes(bucket.id)) return;
          
          const data = assignments.map(a => a.avgBucketMap.get(bucket.id) || 0);
          datasets.push({
            label: bucket.name,
            data: data,
            backgroundColor: getBucketColor(bucket.id, 0.8),
            borderColor: getBucketColor(bucket.id, 1.0),
            borderWidth: 1
          });
        });
        
        bucketChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: labels,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                stacked: true
              },
              y: {
                stacked: true,
                beginAtZero: true
              }
            }
          }
        });
      }
    }
    
    function updateTable() {
      dataTableBody.innerHTML = "";
      
      if (filteredData.length === 0) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 6;
        td.textContent = "No data to display";
        td.style.textAlign = "center";
        td.style.padding = "20px";
        td.style.color = "var(--muted)";
        tr.appendChild(td);
        dataTableBody.appendChild(tr);
        return;
      }
      
      // Separate parseable and unparseable assignments
      const parseableRows = [];
      const unparseableRows = [];
      
      filteredData.forEach(row => {
        const parsed = parseAssignmentName(row.assignment_name);
        if (parsed.number === null && row.assignment_name) {
          unparseableRows.push(row);
        } else {
          parseableRows.push(row);
        }
      });
      
      // Show parseable rows first
      parseableRows.forEach(row => {
        const tr = document.createElement("tr");
        
        const dateCell = document.createElement("td");
        dateCell.className = "nowrap";
        const d = new Date(row.created_at);
        dateCell.textContent = d.toLocaleDateString();
        tr.appendChild(dateCell);
        
        const studentCell = document.createElement("td");
        studentCell.textContent = row.student_name || "—";
        tr.appendChild(studentCell);
        
        const assignmentCell = document.createElement("td");
        assignmentCell.textContent = row.assignment_name || "—";
        tr.appendChild(assignmentCell);
        
        const modeCell = document.createElement("td");
        modeCell.textContent = row.mode || "—";
        tr.appendChild(modeCell);
        
        const labelsCell = document.createElement("td");
        labelsCell.className = "nowrap";
        labelsCell.textContent = row.total_labels != null ? row.total_labels : "—";
        tr.appendChild(labelsCell);
        
        const labelCountsCell = document.createElement("td");
        if (row.label_counts && typeof row.label_counts === 'object') {
          labelCountsCell.textContent = Object.entries(row.label_counts)
            .map(([k, v]) => `${k}: ${v}`)
            .join(", ");
        } else {
          labelCountsCell.textContent = "—";
        }
        tr.appendChild(labelCountsCell);
        
        dataTableBody.appendChild(tr);
      });
      
      // Show warning section for unparseable assignments
      if (unparseableRows.length > 0) {
        // Add separator row
        const separatorTr = document.createElement("tr");
        const separatorTd = document.createElement("td");
        separatorTd.colSpan = 6;
        separatorTd.style.padding = "16px 12px 8px";
        separatorTd.style.borderTop = "2px solid #ffc107";
        separatorTd.style.background = "#fffbf0";
        separatorTd.innerHTML = '<strong style="color: #856404;">⚠️ Unsorted / Missing assignment number</strong><br><span style="font-size: 12px; color: #856404;">These assignments cannot be sorted sequentially. Please use format like "Foundation 01" for progress graphs.</span>';
        dataTableBody.appendChild(separatorTr);
        separatorTr.appendChild(separatorTd);
        
        // Add unparseable rows
        unparseableRows.forEach(row => {
          const tr = document.createElement("tr");
          tr.style.background = "#fffbf0";
          
          const dateCell = document.createElement("td");
          dateCell.className = "nowrap";
          const d = new Date(row.created_at);
          dateCell.textContent = d.toLocaleDateString();
          tr.appendChild(dateCell);
          
          const studentCell = document.createElement("td");
          studentCell.textContent = row.student_name || "—";
          tr.appendChild(studentCell);
          
          const assignmentCell = document.createElement("td");
          assignmentCell.textContent = row.assignment_name || "—";
          assignmentCell.style.color = "#856404";
          tr.appendChild(assignmentCell);
          
          const modeCell = document.createElement("td");
          modeCell.textContent = row.mode || "—";
          tr.appendChild(modeCell);
          
          const labelsCell = document.createElement("td");
          labelsCell.className = "nowrap";
          labelsCell.textContent = row.total_labels != null ? row.total_labels : "—";
          tr.appendChild(labelsCell);
          
          const labelCountsCell = document.createElement("td");
          if (row.label_counts && typeof row.label_counts === 'object') {
            labelCountsCell.textContent = Object.entries(row.label_counts)
              .map(([k, v]) => `${k}: ${v}`)
              .join(", ");
          } else {
            labelCountsCell.textContent = "—";
          }
          tr.appendChild(labelCountsCell);
          
          dataTableBody.appendChild(tr);
        });
      }
    }
    
    // ===== CSV Export =====
    function exportToCSV() {
      if (filteredData.length === 0) {
        alert("No data to export");
        return;
      }
      
      const headers = ["Date", "Student", "Assignment", "Mode", "Total Labels", "Label Counts"];
      const rows = filteredData.map(row => {
        const date = new Date(row.created_at).toLocaleDateString();
        const student = row.student_name || "";
        const assignment = row.assignment_name || "";
        const mode = row.mode || "";
        const totalLabels = row.total_labels != null ? row.total_labels : "";
        const labelCounts = row.label_counts && typeof row.label_counts === 'object'
          ? Object.entries(row.label_counts).map(([k, v]) => `${k}: ${v}`).join("; ")
          : "";
        
        return [date, student, assignment, mode, totalLabels, labelCounts];
      });
      
      const csvContent = [
        headers.join(","),
        ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(","))
      ].join("\n");
      
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      const url = URL.createObjectURL(blob);
      link.setAttribute("href", url);
      link.setAttribute("download", `vysti-progress-${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = "hidden";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    
    // ===== PDF Export =====
    function exportToPDF() {
      if (filteredData.length === 0) {
        alert("No data to export");
        return;
      }
      
      const printHeader = document.getElementById("printHeader");
      const printGeneratedAt = document.getElementById("printGeneratedAt");
      const printMeta = document.getElementById("printMeta");
      
      // Build filter summary
      const summary = [];
      
      // Student
      const studentValue = studentFilter.value || "All Students";
      summary.push(`<div><strong>Student:</strong> ${studentValue}</div>`);
      
      // Series
      const seriesValue = seriesFilter.value || "All Series";
      summary.push(`<div><strong>Series:</strong> ${seriesValue}</div>`);
      
      // Range
      let rangeText = "";
      if (rangeStart.value && rangeEnd.value) {
        rangeText = `Custom: ${rangeStart.value}-${rangeEnd.value}`;
      } else {
        const activeRangeBtn = document.querySelector(".range-btn.active");
        if (activeRangeBtn) {
          const rangeData = activeRangeBtn.dataset.range;
          if (rangeData === "first") rangeText = "First";
          else if (rangeData === "latest") rangeText = "Latest";
          else if (rangeData === "all") rangeText = "All";
          else rangeText = "All";
        } else {
          rangeText = "All";
        }
      }
      summary.push(`<div><strong>Range:</strong> ${rangeText}</div>`);
      
      // Buckets
      const selectedBucketIds = getSelectedBucketIds();
      let bucketText = "";
      if (selectedBucketIds.length === 0) {
        bucketText = "All Categories";
      } else {
        const selectedBuckets = selectedBucketIds.map(id => {
          const bucket = LABEL_BUCKETS.find(b => b.id === id);
          return bucket ? bucket.name : id;
        });
        bucketText = selectedBuckets.join(", ");
      }
      summary.push(`<div><strong>Buckets:</strong> ${bucketText}</div>`);
      
      // Include duplicates
      const duplicatesText = includeDuplicates.checked ? "Yes" : "No";
      summary.push(`<div><strong>Include duplicates:</strong> ${duplicatesText}</div>`);
      
      // Class (if classFilter exists)
      if (classFilter) {
        const classValue = classFilter.value;
        let classText = "All Classes";
        if (classValue === "__unassigned__") {
          classText = "Unassigned";
        } else if (classValue) {
          const selectedOption = classFilter.options[classFilter.selectedIndex];
          classText = selectedOption ? selectedOption.textContent : "All Classes";
        }
        summary.push(`<div><strong>Class:</strong> ${classText}</div>`);
      }
      
      // Set print header content
      printMeta.innerHTML = summary.join("");
      printGeneratedAt.textContent = `Generated: ${new Date().toLocaleString()}`;
      
      // Add printing class to body
      document.body.classList.add("printing");
      
      // Small timeout to allow layout updates
      setTimeout(() => {
        window.print();
      }, 50);
      
      // Remove printing class after print
      window.onafterprint = () => {
        document.body.classList.remove("printing");
        window.onafterprint = null;
      };
    }
    
    // ===== Examples Modal Functions =====
    const examplesModal = document.getElementById("examplesModal");
    const modalCloseBtn = document.getElementById("modalCloseBtn");
    const modalBucketName = document.getElementById("modalBucketName");
    const modalLabel = document.getElementById("modalLabel");
    const modalContent = document.getElementById("modalContent");
    const copyAllBtn = document.getElementById("copyAllBtn");
    
    // Examples Panel DOM refs
    const examplesPanelBucket = document.getElementById("examplesPanelBucket");
    const examplesPanelLabel = document.getElementById("examplesPanelLabel");
    const examplesPanelBestWorst = document.getElementById("examplesPanelBestWorst");
    const examplesPanelContent = document.getElementById("examplesPanelContent");
    const examplesPanelCopyBtn = document.getElementById("examplesPanelCopyBtn");
    
    let currentExamples = [];
    let currentLabel = "";
    let currentBucketName = "";
    
    // Close modal handlers
    modalCloseBtn.addEventListener("click", () => {
      examplesModal.style.display = "none";
    });
    
    examplesModal.addEventListener("click", (e) => {
      if (e.target === examplesModal) {
        examplesModal.style.display = "none";
      }
    });
    
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && examplesModal.style.display !== "none") {
        examplesModal.style.display = "none";
      }
    });
    
    // Fetch examples from Supabase
    async function fetchExamplesForLabel(label) {
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        return [];
      }
      
      // Get canonical label and aliases
      const canonical = canonicalLabel(label);
      const aliases = labelAliasesForQuery(canonical);
      
      let query = supa
        .from("issue_examples")
        .select("student_name, assignment_name, sentence, created_at, class_id")
        .eq("user_id", sessionData.session.user.id);
      
      // Use .in() if there are aliases, otherwise use .eq()
      if (aliases.length > 1) {
        query = query.in("label", aliases);
      } else {
        query = query.eq("label", canonical);
      }
      
      // Apply class filter
      const selectedClass = classFilter.value;
      if (selectedClass === "__unassigned__") {
        query = query.is("class_id", null);
      } else if (selectedClass) {
        query = query.eq("class_id", selectedClass);
      }
      
      const { data, error } = await query
        .order("created_at", { ascending: false })
        .limit(50);
      
      if (error) {
        console.error("Error fetching examples:", error);
        return [];
      }
      
      if (!data || data.length === 0) {
        return [];
      }
      
      // Filter by filteredData keys (student_name::assignment_name)
      const allowedKeys = new Set();
      filteredData.forEach(row => {
        const key = `${row.student_name || ""}::${row.assignment_name || ""}`;
        if (key && key !== "::") {
          allowedKeys.add(key);
        }
      });
      
      // Filter examples to only those in filteredData
      let filtered = data.filter(ex => {
        const key = `${ex.student_name || ""}::${ex.assignment_name || ""}`;
        return allowedKeys.has(key);
      });
      
      // Limit to first 10 for display
      return filtered.slice(0, 10);
    }
    
    // Load examples into the panel
    async function loadExamplesPanel({ label, bucketName }) {
      if (!examplesPanelContent) return;

      // Use canonical label
      const canonical = canonicalLabel(label || "");
      currentLabel = canonical;
      currentBucketName = bucketName || "";

      if (examplesPanelBucket) examplesPanelBucket.textContent = currentBucketName;
      if (examplesPanelLabel) examplesPanelLabel.textContent = displayLabel(currentLabel);

      // Compute most/least issues from filteredData
      const perStudent = new Map(); // student_name -> totalCount
      const allStudents = new Set(); // Track all students in filteredData
      
      filteredData.forEach(row => {
        const student = (row.student_name || "").trim();
        if (!student) return;
        allStudents.add(student);
        
        const obj = row.label_counts && typeof row.label_counts === "object" ? row.label_counts : {};
        let studentTotal = perStudent.get(student) || 0;
        
        // Sum counts for all aliases of the canonical label
        Object.entries(obj).forEach(([entryLabel, raw]) => {
          const entryCanonical = canonicalLabel(entryLabel);
          if (entryCanonical === canonical) {
            const n = typeof raw === "number" ? raw : (parseInt(raw, 10) || 0);
            studentTotal += n;
          }
        });
        
        perStudent.set(student, studentTotal);
      });
      
      // Initialize all students with 0 if not in perStudent
      allStudents.forEach(student => {
        if (!perStudent.has(student)) {
          perStudent.set(student, 0);
        }
      });
      
      // Find most and least
      let mostName = "—";
      let mostCount = -Infinity;
      let leastName = "—";
      let leastCount = Infinity;
      
      for (const [student, count] of perStudent.entries()) {
        if (count > mostCount) {
          mostCount = count;
          mostName = student;
        }
        if (count < leastCount) {
          leastCount = count;
          leastName = student;
        }
      }
      
      if (mostCount === -Infinity) mostCount = 0;
      if (leastCount === Infinity) leastCount = 0;
      
      const mostTxt = mostName !== "—" ? `Most Issues: ${mostName} (${mostCount})` : "Most Issues: —";
      const leastTxt = leastName !== "—" ? `Least Issues: ${leastName} (${leastCount})` : "Least Issues: —";
      if (examplesPanelBestWorst) examplesPanelBestWorst.textContent = `${mostTxt}   ${leastTxt}`;

      examplesPanelContent.innerHTML = '<div class="examples-loading">Loading examples...</div>';
      if (examplesPanelCopyBtn) examplesPanelCopyBtn.style.display = "none";

      const examples = await fetchExamplesForLabel(currentLabel);
      currentExamples = examples;

      if (!examples || examples.length === 0) {
        examplesPanelContent.innerHTML =
          '<div class="examples-empty">No examples saved yet for this issue. Examples appear after essays are marked/ingested.</div>';
        return;
      }

      renderExamples(examples, examplesPanelContent);
      if (examplesPanelCopyBtn) examplesPanelCopyBtn.style.display = "inline-block";
    }
    
    // Open examples modal
    async function openExamplesModal({ label, bucketName }) {
      currentLabel = label;
      currentBucketName = bucketName;
      
      modalBucketName.textContent = bucketName;
      modalLabel.textContent = label;
      modalContent.innerHTML = '<div class="examples-loading">Loading examples...</div>';
      examplesModal.style.display = "flex";
      
      const examples = await fetchExamplesForLabel(label);
      currentExamples = examples;
      
      if (examples.length === 0) {
        modalContent.innerHTML = '<div class="examples-empty">No examples saved yet for this issue. Examples appear after essays are marked/ingested.</div>';
        return;
      }
      
      renderExamples(examples, modalContent);
    }
    
    // Render examples list
    function renderExamples(examples, containerEl) {
      const target = containerEl || modalContent;
      target.innerHTML = "";
      
      // Compute occurrence counts for each example
      // Use filteredData to respect current filters (including duplicates toggle)
      const canonical = canonicalLabel(currentLabel);
      
      examples.forEach((example) => {
        const item = document.createElement("div");
        item.className = "example-item";
        
        const studentInfo = document.createElement("div");
        studentInfo.className = "example-student-info";
        
        // Compute occurrence count for this student + assignment + current label
        let occurrenceCount = 0;
        const studentNameStr = example.student_name || "";
        const assignmentNameStr = example.assignment_name || "";
        
        if (studentNameStr && assignmentNameStr) {
          // Sum counts from filteredData (already respects duplicates toggle)
          filteredData.forEach(row => {
            if (row.student_name === studentNameStr && row.assignment_name === assignmentNameStr) {
              const obj = row.label_counts && typeof row.label_counts === "object" ? row.label_counts : {};
              // Sum counts for all aliases of the canonical label
              Object.entries(obj).forEach(([entryLabel, raw]) => {
                const entryCanonical = canonicalLabel(entryLabel);
                if (entryCanonical === canonical) {
                  const n = typeof raw === "number" ? raw : (parseInt(raw, 10) || 0);
                  occurrenceCount += n;
                }
              });
            }
          });
        }
        
        const studentName = document.createElement("span");
        studentName.className = "example-student-name";
        const displayName = occurrenceCount > 0 
          ? `${example.student_name || "Unknown"} (${occurrenceCount})`
          : (example.student_name || "Unknown");
        studentName.textContent = displayName;
        studentInfo.appendChild(studentName);
        
        if (example.assignment_name) {
          const assignmentName = document.createElement("span");
          assignmentName.className = "example-assignment-name";
          assignmentName.textContent = `• ${example.assignment_name}`;
          studentInfo.appendChild(assignmentName);
        }
        
        item.appendChild(studentInfo);
        
        const sentence = document.createElement("div");
        sentence.className = "example-sentence";
        sentence.textContent = example.sentence || "";
        item.appendChild(sentence);
        
        const copyBtn = document.createElement("button");
        copyBtn.className = "example-copy-btn";
        copyBtn.textContent = "Copy this example";
        copyBtn.addEventListener("click", () => {
          copySentence(example, copyBtn);
        });
        item.appendChild(copyBtn);
        
        target.appendChild(item);
      });
    }
    
    // Copy single sentence
    async function copySentence(example, buttonElement) {
      const text = `${example.student_name || "Student"} — "${example.sentence || ""}"`;
      await copyToClipboard(text, buttonElement, "Copied!");
    }
    
    // Copy all examples as revision assignment
    async function copyAllExamples() {
      if (currentExamples.length === 0) return;
      
      // Get button element (could be panel or modal button)
      const panelBtn = document.getElementById("examplesPanelCopyBtn");
      const modalBtn = document.getElementById("copyAllBtn");
      const btn = panelBtn || modalBtn;
      
      let text = `Revision Assignment: ${currentBucketName} — ${displayLabel(currentLabel)}\n`;
      text += `Directions: Rewrite each sentence to fix the issue.\n\n`;
      
      currentExamples.forEach((ex, idx) => {
        text += `${idx + 1}) Student: ${ex.student_name || "___"} | Assignment: ${ex.assignment_name || "___"}\n`;
        text += `   Sentence: "${ex.sentence || ""}"\n`;
        if (idx < currentExamples.length - 1) {
          text += "\n";
        }
      });
      
      await copyToClipboard(text, btn, "Copied!");
    }
    
    // Clipboard helper with fallback
    async function copyToClipboard(text, buttonElement, feedbackText) {
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          // Fallback for older browsers
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand("copy");
          document.body.removeChild(textarea);
        }
        
        // Visual feedback: temporarily change button text and style
        if (buttonElement && feedbackText) {
          const originalText = buttonElement.textContent;
          const originalStyle = {
            backgroundColor: buttonElement.style.backgroundColor,
            borderColor: buttonElement.style.borderColor
          };
          
          buttonElement.textContent = feedbackText;
          buttonElement.style.backgroundColor = "#4CAF50";
          buttonElement.style.borderColor = "#4CAF50";
          
          setTimeout(() => {
            buttonElement.textContent = originalText;
            buttonElement.style.backgroundColor = originalStyle.backgroundColor;
            buttonElement.style.borderColor = originalStyle.borderColor;
          }, 1500);
        }
      } catch (err) {
        console.error("Failed to copy:", err);
        alert("Failed to copy to clipboard");
      }
    }
    
    copyAllBtn.addEventListener("click", copyAllExamples);
    
    // Wire up examples panel copy button
    if (examplesPanelCopyBtn) {
      examplesPanelCopyBtn.addEventListener("click", copyAllExamples);
    }
    
    // Wire up examples dropdown change handler
    const examplesIssueSelect = document.getElementById("examplesIssueSelect");
    if (examplesIssueSelect) {
      examplesIssueSelect.addEventListener("change", (e) => {
        const selectedLabel = e.target.value;
        if (!selectedLabel) return;
        
        // Get bucket name for the selected label
        const bucketId = getBucketIdForLabel(selectedLabel);
        const bucketName = LABEL_BUCKETS.find(b => b.id === bucketId)?.name || "Other";
        
        loadExamplesPanel({ label: selectedLabel, bucketName });
      });
    }
    
    // ===== Event listeners =====
    rangeBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        rangeBtns.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentRange = btn.dataset.range;
        applyFilters();
      });
    });
    
    rangeStart.addEventListener("input", () => {
      if (rangeStart.value && rangeEnd.value) {
        rangeBtns.forEach(b => b.classList.remove("active"));
        currentRange = "custom";
        applyFilters();
      }
    });
    
    rangeEnd.addEventListener("input", () => {
      if (rangeStart.value && rangeEnd.value) {
        rangeBtns.forEach(b => b.classList.remove("active"));
        currentRange = "custom";
        applyFilters();
      }
    });
    
    classFilter.addEventListener("change", () => {
      // Clear any lingering URL class_id parameter
      clearUrlParam("class_id");
      // Reload data with new class selection
      loadData();
    });
    studentFilter.addEventListener("change", applyFilters);
    seriesFilter.addEventListener("change", applyFilters);
    includeDuplicates.addEventListener("change", applyFilters);
    exportBtn.addEventListener("click", exportToCSV);
    
    const exportPdfBtn = document.getElementById("exportPdfBtn");
    if (exportPdfBtn) {
      exportPdfBtn.addEventListener("click", exportToPDF);
    }
    
    // ===== Initial load =====
    refreshAuthUI();
  </script>
</body>
</html>

