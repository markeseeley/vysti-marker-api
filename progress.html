<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vysti Marker – Analytics Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/marker.css">
  
  <!-- Supabase JS client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  
  <style>
    .progress-page {
      max-width: 1400px;
      margin: 0 auto;
      padding: 24px 18px 40px;
    }
    
    .filters-section {
      background: var(--card);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 24px;
      box-shadow: 0 2px 4px rgba(0,0,0,.08);
    }
    
    .filters-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }
    
    .filter-group {
      display: flex;
      flex-direction: column;
    }
    
    .filter-group label {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--text);
    }
    
    .range-selector {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    
    .range-btn {
      padding: 6px 12px;
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    .range-btn:hover {
      background: rgba(169,13,34,.05);
      border-color: var(--maroon);
    }
    
    .range-btn.active {
      background: var(--maroon);
      color: #fff;
      border-color: var(--maroon);
    }
    
    .range-custom {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 8px;
    }
    
    .range-custom input {
      width: 80px;
      height: 32px;
      padding: 0 8px;
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 8px;
      font-size: 13px;
    }
    
    .duplicates-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 12px;
    }
    
    .duplicates-toggle input[type="checkbox"] {
      width: 44px;
      height: 24px;
      appearance: none;
      border-radius: 12px;
      background: #BCC1CA;
      position: relative;
      cursor: pointer;
    }
    
    .duplicates-toggle input[type="checkbox"]::before {
      content: "";
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background: #fff;
      transition: transform .15s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,.18);
    }
    
    .duplicates-toggle input[type="checkbox"]:checked {
      background: var(--maroon);
    }
    
    .duplicates-toggle input[type="checkbox"]:checked::before {
      transform: translateX(20px);
    }
    
    .bucket-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      max-width: 520px;
      margin-top: 8px;
    }
    
    .bucket-checkboxes label {
      display: flex;
      gap: 6px;
      align-items: center;
      font-size: 0.9rem;
      cursor: pointer;
      font-weight: normal;
    }
    
    .bucket-checkboxes input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    
    .bucket-actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }
    
    .bucket-actions button {
      padding: 6px 12px;
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    .bucket-actions button:hover {
      background: rgba(169,13,34,.05);
      border-color: var(--maroon);
    }
    
    .charts-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
      margin-bottom: 24px;
    }
    
    @media (max-width: 980px) {
      .charts-section {
        grid-template-columns: 1fr;
      }
    }
    
    .chart-card {
      background: var(--card);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,.08);
    }
    
    .chart-card h3 {
      margin: 0 0 16px;
      font-size: 18px;
      font-weight: 600;
    }
    
    .chart-container {
      position: relative;
      height: 300px;
    }
    
    .table-section {
      background: var(--card);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,.08);
    }
    
    .table-section h3 {
      margin: 0 0 16px;
      font-size: 18px;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .export-btn {
      padding: 8px 16px;
      border: 1px solid var(--maroon);
      border-radius: 8px;
      background: var(--maroon);
      color: #fff;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .export-btn:hover {
      filter: brightness(.95);
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    
    thead {
      background: #f5f6f8;
    }
    
    th, td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid rgba(0,0,0,.08);
    }
    
    th {
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      color: var(--muted);
    }
    
    tbody tr:hover {
      background: rgba(169,13,34,.02);
    }
    
    .nowrap {
      white-space: nowrap;
    }
    
    .status-message {
      padding: 12px;
      background: rgba(169,13,34,.05);
      border-radius: 8px;
      margin-bottom: 16px;
      font-size: 13px;
      color: var(--text);
    }
    
    /* Print header styles */
    .print-header {
      display: none;
    }
    
    .print-title {
      margin-bottom: 16px;
    }
    
    .print-title h1 {
      margin: 0 0 8px;
      font-size: 24px;
      font-weight: 700;
      color: var(--text);
    }
    
    .print-generated {
      font-size: 12px;
      color: var(--muted);
    }
    
    .print-meta {
      font-size: 13px;
      color: var(--text);
      line-height: 1.6;
    }
    
    .print-meta > div {
      margin-bottom: 4px;
    }
    
    /* Print styles */
    @media print {
      .print-header {
        display: block;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 2px solid rgba(0,0,0,.1);
      }
      
      header.topbar {
        display: none !important;
      }
      
      .filters-section {
        display: none !important;
      }
      
      .export-btn {
        display: none !important;
      }
      
      body {
        background: white !important;
      }
      
      .progress-page {
        background: white !important;
      }
      
      .chart-card,
      .table-section {
        background: white !important;
        box-shadow: none !important;
        border: 1px solid rgba(0,0,0,.1) !important;
      }
      
      .charts-section,
      .chart-card,
      .table-section {
        break-inside: avoid;
        page-break-inside: avoid;
      }
      
      * {
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }
      
      @page {
        margin: 16mm;
      }
    }
    
    body.printing {
      background: white;
    }
    
    body.printing .progress-page {
      background: white;
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <img src="/assets/logo.svg" alt="Vysti" />
    </div>
    
    <nav>
      <a href="/progress.html" class="active">Dashboard</a>
      <a href="/index.html">Mark Assignments</a>
      <a href="/ingest.html">Ingest Marked Essays</a>
      <a href="/classes.html">Classes</a>
    </nav>
    
    <div class="actions">
      <button class="iconbtn" type="button" title="Notifications" aria-label="Notifications"></button>
      <img class="avatar" src="/assets/avatar.png" alt="Profile" />
      <button class="iconbtn" id="logoutBtn" type="button" title="Log out" aria-label="Log out"></button>
    </div>
  </header>

  <main class="page">
    <div class="progress-page" id="progressPage" style="display:none;">
      <div id="printHeader" class="print-header" aria-hidden="true">
        <div class="print-title">
          <h1>Vysti Progress Report</h1>
          <div id="printGeneratedAt" class="print-generated"></div>
        </div>
        <div id="printMeta" class="print-meta"></div>
      </div>
      
      <div class="filters-section">
        <h2 style="margin: 0 0 16px; font-size: 20px; font-weight: 600;">Filters</h2>
        
        <div class="filters-grid">
          <div class="filter-group">
            <label for="classFilter">Class</label>
            <select id="classFilter">
              <option value="">All Classes</option>
              <option value="__unassigned__">Unassigned</option>
            </select>
          </div>
          
          <div class="filter-group">
            <label for="studentFilter">Student</label>
            <select id="studentFilter">
              <option value="">All Students</option>
            </select>
          </div>
          
          <div class="filter-group">
            <label for="seriesFilter">Assignment Series</label>
            <select id="seriesFilter">
              <option value="">All Series</option>
            </select>
          </div>
          
          <div class="filter-group">
            <label>Assignment Range</label>
            <div class="range-selector">
              <button class="range-btn" data-range="6">First 6</button>
              <button class="range-btn" data-range="12">First 12</button>
              <button class="range-btn active" data-range="all">All</button>
            </div>
            <div class="range-custom">
              <input type="number" id="rangeStart" placeholder="Start" min="1" />
              <span>to</span>
              <input type="number" id="rangeEnd" placeholder="End" min="1" />
            </div>
          </div>
        </div>
        
        <div class="duplicates-toggle">
          <input type="checkbox" id="includeDuplicates" />
          <label for="includeDuplicates" style="margin: 0; font-size: 13px; font-weight: 600;">Include duplicates (show all entries for same student+assignment)</label>
        </div>
        
        <div class="filter-group" style="margin-top: 20px;">
          <label>Buckets</label>
          <div class="bucket-checkboxes" id="bucketCheckboxes"></div>
          <div class="bucket-actions">
            <button type="button" id="bucketSelectAll">All</button>
            <button type="button" id="bucketClear">None</button>
          </div>
        </div>
      </div>
      
      <div id="statusMessage" class="status-message" style="display:none;"></div>
      
      <div class="charts-section">
        <div class="chart-card">
          <h3>Total Labels vs Assignment Order</h3>
          <div class="chart-container">
            <canvas id="lineChart"></canvas>
          </div>
        </div>
        
        <div class="chart-card">
          <h3>Top 8 Labels</h3>
          <div class="chart-container">
            <canvas id="barChart"></canvas>
          </div>
        </div>
      </div>
      
      <div class="chart-card" style="margin-bottom: 24px;">
        <h3>Progress by Category</h3>
        <div class="chart-container">
          <canvas id="bucketChart"></canvas>
        </div>
      </div>
      
      <div class="table-section">
        <h3>
          <span>Data Table</span>
          <div style="display: flex; gap: 8px;">
            <button class="export-btn" id="exportPdfBtn">Export PDF</button>
            <button class="export-btn" id="exportBtn">Export CSV</button>
          </div>
        </h3>
        <table>
          <thead>
            <tr>
              <th class="nowrap">Date</th>
              <th>Student</th>
              <th>Assignment</th>
              <th>Mode</th>
              <th class="nowrap">Total Labels</th>
              <th>Label Counts</th>
            </tr>
          </thead>
          <tbody id="dataTableBody">
            <!-- rows injected by JS -->
          </tbody>
        </table>
      </div>
    </div>
  </main>

  <script>
    // ===== Bucket definitions =====
    const LABEL_BUCKETS = [
      {
        id: "thesis_org",
        name: "Thesis & Organization",
        matchers: [
          /thesis/i,
          /topic sentence/i,
          /organization/i,
          /transition/i,
          /boundary statement/i,
          /introduction/i,
          /conclusion/i,
          /paragraph/i,
          /structure/i
        ]
      },
      {
        id: "evidence_integration",
        name: "Evidence & Integration",
        matchers: [
          /quote/i,
          /quotation/i,
          /evidence/i,
          /citation/i,
          /\bcite\b/i,
          /works cited/i,
          /power verbs/i,
          /support/i
        ]
      },
      {
        id: "voice_audience",
        name: "Voice & Audience",
        matchers: [
          /personal pronoun/i,
          /\bI\b/i,
          /\bwe\b/i,
          /\byou\b/i,
          /reader/i,
          /audience/i
        ]
      },
      {
        id: "style_clarity",
        name: "Style & Clarity",
        matchers: [
          /contraction/i,
          /\bwhich\b/i,
          /\bfact\b/i,
          /\bprove\b/i,
          /weak verb/i,
          /vague/i,
          /people/i,
          /human/i,
          /word choice/i,
          /avoid using the word/i,
          /more than once in a sentence/i
        ]
      },
      {
        id: "grammar_mechanics",
        name: "Grammar & Mechanics",
        matchers: [
          /subject[- ]verb/i,
          /agreement/i,
          /tense/i,
          /comma/i,
          /punctuation/i,
          /spelling/i,
          /apostrophe/i
        ]
      },
      {
        id: "formatting",
        name: "Formatting & Conventions",
        matchers: [
          /MLA/i,
          /header/i,
          /format/i,
          /title/i,
          /author/i
        ]
      },
      { id: "other", name: "Other", matchers: [] }
    ];

    const BUCKET_OVERRIDES = {
      "Avoid quotations in the conclusion": "evidence_integration",
      "Avoid quotations in the introduction": "evidence_integration"
    };

    function getBucketIdForLabel(label) {
      if (!label) return "other";
      if (BUCKET_OVERRIDES[label]) return BUCKET_OVERRIDES[label];
      for (const b of LABEL_BUCKETS) {
        if (b.id === "other") continue;
        if (b.matchers.some(rx => rx.test(label))) return b.id;
      }
      return "other";
    }

    // ===== Supabase config =====
    const SUPABASE_URL = "https://divdfodsdtfbdwoqvsfy.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRpdmRmb2RzZHRmYmR3b3F2c2Z5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU0MjU1OTksImV4cCI6MjA4MTAwMTU5OX0.fnm_9qX5DqdR0j6y-2mRRkwr8Icm1uRNPbUo6lqzock";
    
    const { createClient } = supabase;
    const supa = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    
    const progressPage = document.getElementById("progressPage");
    const logoutBtn = document.getElementById("logoutBtn");
    const classFilter = document.getElementById("classFilter");
    const studentFilter = document.getElementById("studentFilter");
    const seriesFilter = document.getElementById("seriesFilter");
    const rangeBtns = document.querySelectorAll(".range-btn");
    const rangeStart = document.getElementById("rangeStart");
    const rangeEnd = document.getElementById("rangeEnd");
    const includeDuplicates = document.getElementById("includeDuplicates");
    const statusMessage = document.getElementById("statusMessage");
    const dataTableBody = document.getElementById("dataTableBody");
    const exportBtn = document.getElementById("exportBtn");
    
    let allData = [];
    let filteredData = [];
    let lineChart = null;
    let barChart = null;
    let bucketChart = null;
    let currentRange = "all";
    
    // ===== Auth =====
    async function refreshAuthUI() {
      const { data } = await supa.auth.getSession();
      const session = data.session;
      
      if (!session) {
        window.location.replace("/signin.html");
        return;
      }
      
      progressPage.style.display = "block";
      loadData();
    }
    
    logoutBtn.addEventListener("click", async () => {
      await supa.auth.signOut();
      window.location.replace("/signin.html");
    });
    
    supa.auth.onAuthStateChange((_event, _session) => {
      refreshAuthUI();
    });
    
    // ===== Assignment name parsing =====
    function parseAssignmentName(name) {
      if (!name) return { series: "", number: null, original: name };
      
      // Extract trailing number for natural numeric sort
      // Handles: "Foundation HW06", "HW02", "Foundation 3", "High Level HW11", etc.
      const numMatch = name.match(/(\d+)$/);
      if (numMatch) {
        const number = parseInt(numMatch[1], 10);
        // Extract series (everything before the trailing number)
        const seriesMatch = name.match(/^(.+?)\s*\d+$/);
        const series = seriesMatch ? seriesMatch[1].trim() : "";
        
        return {
          series: series,
          number: number,
          original: name
        };
      }
      
      // Fallback: try to match pattern like "Foundation 3" at the start
      const match = name.match(/^([A-Za-z]+)\s*(\d+)/);
      if (match) {
        return {
          series: match[1],
          number: parseInt(match[2], 10),
          original: name
        };
      }
      
      return { series: "", number: null, original: name };
    }
    
    // ===== Data loading =====
    async function loadData() {
      statusMessage.style.display = "block";
      statusMessage.textContent = "Loading data...";
      
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        window.location.replace("/signin.html");
        return;
      }
      
      // Build query
      let query = supa
        .from("mark_events")
        .select("created_at, student_name, assignment_name, mode, total_labels, label_counts, class_id")
        .eq("user_id", sessionData.session.user.id);
      
      // Apply class filter
      const selectedClass = classFilter.value;
      if (selectedClass === "__unassigned__") {
        query = query.is("class_id", null);
      } else if (selectedClass) {
        query = query.eq("class_id", selectedClass);
      }
      
      const { data, error } = await query.order("created_at", { ascending: false });
      
      if (error) {
        statusMessage.textContent = `Error loading data: ${error.message}`;
        return;
      }
      
      if (!data || data.length === 0) {
        statusMessage.textContent = "No data found.";
        allData = [];
        filteredData = [];
        updateUI();
        return;
      }
      
      allData = data;
      statusMessage.style.display = "none";
      await loadClasses();
      updateFilters();
      buildBucketCheckboxes();
      applyFilters();
    }
    
    // ===== Load classes =====
    async function loadClasses() {
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) return;
      
      const { data, error } = await supa
        .from("classes")
        .select("*")
        .eq("user_id", sessionData.session.user.id)
        .eq("archived", false)
        .order("created_at", { ascending: false });
      
      if (error) {
        console.error("Error loading classes:", error);
        return;
      }
      
      classFilter.innerHTML = '<option value="">All Classes</option><option value="__unassigned__">Unassigned</option>';
      (data || []).forEach(cls => {
        const option = document.createElement("option");
        option.value = cls.id;
        option.textContent = cls.name;
        classFilter.appendChild(option);
      });
    }
    
    // ===== Bucket selection =====
    function buildBucketCheckboxes() {
      const container = document.getElementById("bucketCheckboxes");
      container.innerHTML = "";
      
      const savedSelection = localStorage.getItem("vysti_bucket_selection");
      let selectedBuckets = [];
      if (savedSelection) {
        try {
          selectedBuckets = JSON.parse(savedSelection);
        } catch (e) {
          selectedBuckets = LABEL_BUCKETS.filter(b => b.id !== "other").map(b => b.id);
        }
      } else {
        // Default: select all except "other"
        selectedBuckets = LABEL_BUCKETS.filter(b => b.id !== "other").map(b => b.id);
      }
      
      LABEL_BUCKETS.forEach(bucket => {
        if (bucket.id === "other") return; // Skip "other" from UI
        
        const label = document.createElement("label");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = bucket.id;
        checkbox.checked = selectedBuckets.includes(bucket.id);
        checkbox.addEventListener("change", () => {
          saveBucketSelection();
          updateCharts();
        });
        
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(bucket.name));
        container.appendChild(label);
      });
    }
    
    function saveBucketSelection() {
      const selected = getSelectedBucketIds();
      localStorage.setItem("vysti_bucket_selection", JSON.stringify(selected));
    }
    
    function getSelectedBucketIds() {
      const checkboxes = document.querySelectorAll("#bucketCheckboxes input[type='checkbox']");
      return Array.from(checkboxes)
        .filter(cb => cb.checked)
        .map(cb => cb.value);
    }
    
    document.getElementById("bucketSelectAll").addEventListener("click", () => {
      const checkboxes = document.querySelectorAll("#bucketCheckboxes input[type='checkbox']");
      checkboxes.forEach(cb => cb.checked = true);
      saveBucketSelection();
      updateCharts();
    });
    
    document.getElementById("bucketClear").addEventListener("click", () => {
      const checkboxes = document.querySelectorAll("#bucketCheckboxes input[type='checkbox']");
      checkboxes.forEach(cb => cb.checked = false);
      saveBucketSelection();
      updateCharts();
    });
    
    function bucketCountsFromRow(row) {
      const out = new Map(); // bucketId -> count
      if (!row.label_counts || typeof row.label_counts !== "object") return out;
      for (const [label, raw] of Object.entries(row.label_counts)) {
        const n = typeof raw === "number" ? raw : parseInt(raw, 10) || 0;
        const bucketId = getBucketIdForLabel(label);
        out.set(bucketId, (out.get(bucketId) || 0) + n);
      }
      return out;
    }
    
    // ===== Filter updates =====
    function updateFilters() {
      // Update student filter - only show students from filtered dataset
      const students = [...new Set(allData.map(r => r.student_name).filter(Boolean))].sort();
      studentFilter.innerHTML = '<option value="">All Students</option>';
      students.forEach(student => {
        const option = document.createElement("option");
        option.value = student;
        option.textContent = student;
        studentFilter.appendChild(option);
      });
      
      // Update series filter
      const seriesSet = new Set();
      allData.forEach(row => {
        const parsed = parseAssignmentName(row.assignment_name);
        if (parsed.series) {
          seriesSet.add(parsed.series);
        }
      });
      const seriesList = Array.from(seriesSet).sort();
      seriesFilter.innerHTML = '<option value="">All Series</option>';
      seriesList.forEach(series => {
        const option = document.createElement("option");
        option.value = series;
        option.textContent = series;
        seriesFilter.appendChild(option);
      });
    }
    
    // ===== Filter application =====
    function applyFilters() {
      // Start with data sorted by created_at descending (most recent first)
      let filtered = [...allData].sort((a, b) => 
        new Date(b.created_at) - new Date(a.created_at)
      );
      
      // Handle duplicates: if not including duplicates, keep only most recent per student+assignment
      // Since data is sorted by created_at descending, first occurrence is most recent
      if (!includeDuplicates.checked) {
        const seen = new Set();
        filtered = filtered.filter(row => {
          const key = `${row.student_name || ""}::${row.assignment_name || ""}`;
          if (!key || key === "::") return true; // Keep rows without student/assignment
          
          if (seen.has(key)) {
            return false; // Already seen this combination, skip (we keep the first/most recent)
          }
          seen.add(key);
          return true;
        });
      }
      
      // Apply student filter
      const selectedStudent = studentFilter.value;
      if (selectedStudent) {
        filtered = filtered.filter(r => r.student_name === selectedStudent);
      }
      
      // Apply series filter
      const selectedSeries = seriesFilter.value;
      if (selectedSeries) {
        filtered = filtered.filter(r => {
          const parsed = parseAssignmentName(r.assignment_name);
          return parsed.series === selectedSeries;
        });
      }
      
      // Sort by assignment (series then number, with unparseable at end)
      filtered.sort((a, b) => {
        const aParsed = parseAssignmentName(a.assignment_name);
        const bParsed = parseAssignmentName(b.assignment_name);
        
        // Unparseable go to end
        if (aParsed.number === null && bParsed.number !== null) return 1;
        if (aParsed.number !== null && bParsed.number === null) return -1;
        if (aParsed.number === null && bParsed.number === null) {
          return (aParsed.original || "").localeCompare(bParsed.original || "");
        }
        
        // If series filter is applied, just sort by number
        if (selectedSeries && aParsed.series === selectedSeries && bParsed.series === selectedSeries) {
          return aParsed.number - bParsed.number;
        }
        
        // Otherwise sort by series then number
        if (aParsed.series !== bParsed.series) {
          return aParsed.series.localeCompare(bParsed.series);
        }
        return aParsed.number - bParsed.number;
      });
      
      // Apply range filter
      if (currentRange !== "all") {
        const num = parseInt(currentRange, 10);
        if (!isNaN(num)) {
          filtered = filtered.slice(0, num);
        } else if (rangeStart.value && rangeEnd.value) {
          const start = parseInt(rangeStart.value, 10) - 1; // 0-indexed
          const end = parseInt(rangeEnd.value, 10);
          filtered = filtered.slice(start, end);
        }
      } else if (rangeStart.value && rangeEnd.value) {
        const start = parseInt(rangeStart.value, 10) - 1;
        const end = parseInt(rangeEnd.value, 10);
        filtered = filtered.slice(start, end);
      }
      
      filteredData = filtered;
      updateUI();
    }
    
    // ===== UI updates =====
    function updateUI() {
      updateCharts();
      updateTable();
    }
    
    function updateCharts() {
      updateLineChart();
      updateBarChart();
      updateBucketChart();
    }
    
    function updateLineChart() {
      const ctx = document.getElementById("lineChart").getContext("2d");
      
      if (lineChart) {
        lineChart.destroy();
      }
      
      const selectedStudent = studentFilter.value;
      const selectedSeries = seriesFilter.value;
      
      // Group data for line chart
      if (selectedStudent) {
        // Per student: show their assignments
        const studentData = filteredData.filter(r => r.student_name === selectedStudent);
        const labels = studentData.map((r, i) => {
          const parsed = parseAssignmentName(r.assignment_name);
          if (parsed.number !== null) {
            return selectedSeries ? `#${parsed.number}` : r.assignment_name;
          }
          return r.assignment_name || `Assignment ${i + 1}`;
        });
        const data = studentData.map(r => r.total_labels || 0);
        
        lineChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: labels,
            datasets: [{
              label: `${selectedStudent} - Total Labels`,
              data: data,
              borderColor: "rgb(169, 13, 34)",
              backgroundColor: "rgba(169, 13, 34, 0.1)",
              tension: 0.1,
              fill: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true
              }
            }
          }
        });
      } else {
        // Class average: group by assignment
        const assignmentMap = new Map();
        filteredData.forEach(row => {
          const key = row.assignment_name || "Unnamed";
          if (!assignmentMap.has(key)) {
            assignmentMap.set(key, { total: 0, count: 0 });
          }
          const entry = assignmentMap.get(key);
          entry.total += row.total_labels || 0;
          entry.count += 1;
        });
        
        const assignments = Array.from(assignmentMap.entries())
          .map(([name, stats]) => ({
            name,
            avg: stats.count > 0 ? stats.total / stats.count : 0
          }))
          .sort((a, b) => {
            const aParsed = parseAssignmentName(a.name);
            const bParsed = parseAssignmentName(b.name);
            if (aParsed.number === null && bParsed.number !== null) return 1;
            if (aParsed.number !== null && bParsed.number === null) return -1;
            if (aParsed.number === null) return 0;
            if (selectedSeries && aParsed.series === selectedSeries && bParsed.series === selectedSeries) {
              return aParsed.number - bParsed.number;
            }
            if (aParsed.series !== bParsed.series) {
              return aParsed.series.localeCompare(bParsed.series);
            }
            return aParsed.number - bParsed.number;
          });
        
        lineChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: assignments.map(a => {
              const parsed = parseAssignmentName(a.name);
              return selectedSeries && parsed.series === selectedSeries 
                ? `#${parsed.number}` 
                : a.name;
            }),
            datasets: [{
              label: "Class Average - Total Labels",
              data: assignments.map(a => a.avg),
              borderColor: "rgb(169, 13, 34)",
              backgroundColor: "rgba(169, 13, 34, 0.1)",
              tension: 0.1,
              fill: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true
              }
            }
          }
        });
      }
    }
    
    function updateBarChart() {
      const ctx = document.getElementById("barChart").getContext("2d");
      
      if (barChart) {
        barChart.destroy();
      }
      
      const selectedBucketIds = getSelectedBucketIds();
      
      // Count non-"other" buckets
      const nonOtherBuckets = LABEL_BUCKETS.filter(b => b.id !== "other").length;
      const allBucketsSelected = selectedBucketIds.length === nonOtherBuckets;
      
      // Aggregate label_counts across filtered data
      const labelCounter = new Map();
      
      // If all buckets are selected, or no buckets selected, show all labels (default behavior)
      // Otherwise, filter by selected buckets
      if (!allBucketsSelected && selectedBucketIds.length > 0) {
        filteredData.forEach(row => {
          if (row.label_counts && typeof row.label_counts === 'object') {
            Object.entries(row.label_counts).forEach(([label, count]) => {
              // Only include label if its bucket is selected
              const bucketId = getBucketIdForLabel(label);
              if (selectedBucketIds.includes(bucketId)) {
                const currentCount = labelCounter.get(label) || 0;
                labelCounter.set(label, currentCount + (typeof count === 'number' ? count : parseInt(count, 10) || 0));
              }
            });
          }
        });
      } else {
        // If all buckets selected or none selected, include all labels (default behavior)
        filteredData.forEach(row => {
          if (row.label_counts && typeof row.label_counts === 'object') {
            Object.entries(row.label_counts).forEach(([label, count]) => {
              const currentCount = labelCounter.get(label) || 0;
              labelCounter.set(label, currentCount + (typeof count === 'number' ? count : parseInt(count, 10) || 0));
            });
          }
        });
      }
      
      const topLabels = Array.from(labelCounter.entries())
        .map(([label, count]) => ({ label, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 8);
      
      barChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: topLabels.map(l => l.label),
          datasets: [{
            label: "Count",
            data: topLabels.map(l => l.count),
            backgroundColor: "rgba(169, 13, 34, 0.6)",
            borderColor: "rgba(169, 13, 34, 1)",
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }
    
    function updateBucketChart() {
      const canvas = document.getElementById("bucketChart");
      const parent = canvas.parentElement;
      
      if (bucketChart) {
        bucketChart.destroy();
        bucketChart = null;
      }
      
      const selectedBucketIds = getSelectedBucketIds();
      
      if (selectedBucketIds.length === 0) {
        // Clear chart if no buckets selected
        const message = document.createElement("div");
        message.style.textAlign = "center";
        message.style.padding = "40px";
        message.style.color = "var(--muted)";
        message.textContent = "Please select at least one bucket to view chart";
        message.id = "bucketChartMessage";
        
        // Remove existing message if present
        const existing = parent.querySelector("#bucketChartMessage");
        if (existing) existing.remove();
        
        parent.appendChild(message);
        canvas.style.display = "none";
        return;
      }
      
      // Remove message and show canvas if buckets are selected
      const existing = parent.querySelector("#bucketChartMessage");
      if (existing) existing.remove();
      canvas.style.display = "block";
      
      const ctx = canvas.getContext("2d");
      
      const selectedStudent = studentFilter.value;
      const selectedSeries = seriesFilter.value;
      
      // Color palette for buckets
      const colors = [
        "rgba(169, 13, 34, 0.8)",    // maroon
        "rgba(52, 152, 219, 0.8)",   // blue
        "rgba(46, 204, 113, 0.8)",   // green
        "rgba(241, 196, 15, 0.8)",   // yellow
        "rgba(155, 89, 182, 0.8)",   // purple
        "rgba(231, 76, 60, 0.8)",    // red
        "rgba(26, 188, 156, 0.8)",   // teal
      ];
      
      if (selectedStudent) {
        // Per student: show their bucket totals per assignment
        const studentData = filteredData.filter(r => r.student_name === selectedStudent);
        
        // Build assignment map with bucket totals
        const assignmentMap = new Map();
        studentData.forEach(row => {
          const key = row.assignment_name || "Unnamed";
          if (!assignmentMap.has(key)) {
            assignmentMap.set(key, new Map());
          }
          const bucketCounts = bucketCountsFromRow(row);
          bucketCounts.forEach((count, bucketId) => {
            const current = assignmentMap.get(key).get(bucketId) || 0;
            assignmentMap.get(key).set(bucketId, current + count);
          });
        });
        
        // Convert to sorted assignments array
        const assignments = Array.from(assignmentMap.entries())
          .map(([name, bucketMap]) => ({ name, bucketMap }))
          .sort((a, b) => {
            const aParsed = parseAssignmentName(a.name);
            const bParsed = parseAssignmentName(b.name);
            if (aParsed.number === null && bParsed.number !== null) return 1;
            if (aParsed.number !== null && bParsed.number === null) return -1;
            if (aParsed.number === null) return 0;
            if (selectedSeries && aParsed.series === selectedSeries && bParsed.series === selectedSeries) {
              return aParsed.number - bParsed.number;
            }
            if (aParsed.series !== bParsed.series) {
              return aParsed.series.localeCompare(bParsed.series);
            }
            return aParsed.number - bParsed.number;
          });
        
        const labels = assignments.map(a => {
          const parsed = parseAssignmentName(a.name);
          return selectedSeries && parsed.series === selectedSeries 
            ? `#${parsed.number}` 
            : a.name;
        });
        
        // Build datasets for selected buckets (in LABEL_BUCKETS order)
        const datasets = [];
        LABEL_BUCKETS.forEach((bucket, idx) => {
          if (!selectedBucketIds.includes(bucket.id)) return;
          
          const data = assignments.map(a => a.bucketMap.get(bucket.id) || 0);
          datasets.push({
            label: bucket.name,
            data: data,
            backgroundColor: colors[idx % colors.length],
            borderColor: colors[idx % colors.length].replace("0.8", "1"),
            borderWidth: 1
          });
        });
        
        bucketChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: labels,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                stacked: true
              },
              y: {
                stacked: true,
                beginAtZero: true
              }
            }
          }
        });
      } else {
        // Class average: group by assignment and compute averages
        const assignmentMap = new Map();
        const assignmentCountMap = new Map();
        
        filteredData.forEach(row => {
          const key = row.assignment_name || "Unnamed";
          if (!assignmentMap.has(key)) {
            assignmentMap.set(key, new Map());
            assignmentCountMap.set(key, 0);
          }
          assignmentCountMap.set(key, assignmentCountMap.get(key) + 1);
          
          const bucketCounts = bucketCountsFromRow(row);
          bucketCounts.forEach((count, bucketId) => {
            const current = assignmentMap.get(key).get(bucketId) || 0;
            assignmentMap.get(key).set(bucketId, current + count);
          });
        });
        
        // Convert to sorted assignments array with averages
        const assignments = Array.from(assignmentMap.entries())
          .map(([name, bucketMap]) => {
            const count = assignmentCountMap.get(name) || 1;
            const avgBucketMap = new Map();
            bucketMap.forEach((total, bucketId) => {
              avgBucketMap.set(bucketId, total / count);
            });
            return { name, avgBucketMap };
          })
          .sort((a, b) => {
            const aParsed = parseAssignmentName(a.name);
            const bParsed = parseAssignmentName(b.name);
            if (aParsed.number === null && bParsed.number !== null) return 1;
            if (aParsed.number !== null && bParsed.number === null) return -1;
            if (aParsed.number === null) return 0;
            if (selectedSeries && aParsed.series === selectedSeries && bParsed.series === selectedSeries) {
              return aParsed.number - bParsed.number;
            }
            if (aParsed.series !== bParsed.series) {
              return aParsed.series.localeCompare(bParsed.series);
            }
            return aParsed.number - bParsed.number;
          });
        
        const labels = assignments.map(a => {
          const parsed = parseAssignmentName(a.name);
          return selectedSeries && parsed.series === selectedSeries 
            ? `#${parsed.number}` 
            : a.name;
        });
        
        // Build datasets for selected buckets (in LABEL_BUCKETS order)
        const datasets = [];
        LABEL_BUCKETS.forEach((bucket, idx) => {
          if (!selectedBucketIds.includes(bucket.id)) return;
          
          const data = assignments.map(a => a.avgBucketMap.get(bucket.id) || 0);
          datasets.push({
            label: bucket.name,
            data: data,
            backgroundColor: colors[idx % colors.length],
            borderColor: colors[idx % colors.length].replace("0.8", "1"),
            borderWidth: 1
          });
        });
        
        bucketChart = new Chart(ctx, {
          type: "bar",
          data: {
            labels: labels,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                stacked: true
              },
              y: {
                stacked: true,
                beginAtZero: true
              }
            }
          }
        });
      }
    }
    
    function updateTable() {
      dataTableBody.innerHTML = "";
      
      if (filteredData.length === 0) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 6;
        td.textContent = "No data to display";
        td.style.textAlign = "center";
        td.style.padding = "20px";
        td.style.color = "var(--muted)";
        tr.appendChild(td);
        dataTableBody.appendChild(tr);
        return;
      }
      
      // Separate parseable and unparseable assignments
      const parseableRows = [];
      const unparseableRows = [];
      
      filteredData.forEach(row => {
        const parsed = parseAssignmentName(row.assignment_name);
        if (parsed.number === null && row.assignment_name) {
          unparseableRows.push(row);
        } else {
          parseableRows.push(row);
        }
      });
      
      // Show parseable rows first
      parseableRows.forEach(row => {
        const tr = document.createElement("tr");
        
        const dateCell = document.createElement("td");
        dateCell.className = "nowrap";
        const d = new Date(row.created_at);
        dateCell.textContent = d.toLocaleDateString();
        tr.appendChild(dateCell);
        
        const studentCell = document.createElement("td");
        studentCell.textContent = row.student_name || "—";
        tr.appendChild(studentCell);
        
        const assignmentCell = document.createElement("td");
        assignmentCell.textContent = row.assignment_name || "—";
        tr.appendChild(assignmentCell);
        
        const modeCell = document.createElement("td");
        modeCell.textContent = row.mode || "—";
        tr.appendChild(modeCell);
        
        const labelsCell = document.createElement("td");
        labelsCell.className = "nowrap";
        labelsCell.textContent = row.total_labels != null ? row.total_labels : "—";
        tr.appendChild(labelsCell);
        
        const labelCountsCell = document.createElement("td");
        if (row.label_counts && typeof row.label_counts === 'object') {
          labelCountsCell.textContent = Object.entries(row.label_counts)
            .map(([k, v]) => `${k}: ${v}`)
            .join(", ");
        } else {
          labelCountsCell.textContent = "—";
        }
        tr.appendChild(labelCountsCell);
        
        dataTableBody.appendChild(tr);
      });
      
      // Show warning section for unparseable assignments
      if (unparseableRows.length > 0) {
        // Add separator row
        const separatorTr = document.createElement("tr");
        const separatorTd = document.createElement("td");
        separatorTd.colSpan = 6;
        separatorTd.style.padding = "16px 12px 8px";
        separatorTd.style.borderTop = "2px solid #ffc107";
        separatorTd.style.background = "#fffbf0";
        separatorTd.innerHTML = '<strong style="color: #856404;">⚠️ Unsorted / Missing assignment number</strong><br><span style="font-size: 12px; color: #856404;">These assignments cannot be sorted sequentially. Please use format like "Foundation 01" for progress graphs.</span>';
        dataTableBody.appendChild(separatorTr);
        separatorTr.appendChild(separatorTd);
        
        // Add unparseable rows
        unparseableRows.forEach(row => {
          const tr = document.createElement("tr");
          tr.style.background = "#fffbf0";
          
          const dateCell = document.createElement("td");
          dateCell.className = "nowrap";
          const d = new Date(row.created_at);
          dateCell.textContent = d.toLocaleDateString();
          tr.appendChild(dateCell);
          
          const studentCell = document.createElement("td");
          studentCell.textContent = row.student_name || "—";
          tr.appendChild(studentCell);
          
          const assignmentCell = document.createElement("td");
          assignmentCell.textContent = row.assignment_name || "—";
          assignmentCell.style.color = "#856404";
          tr.appendChild(assignmentCell);
          
          const modeCell = document.createElement("td");
          modeCell.textContent = row.mode || "—";
          tr.appendChild(modeCell);
          
          const labelsCell = document.createElement("td");
          labelsCell.className = "nowrap";
          labelsCell.textContent = row.total_labels != null ? row.total_labels : "—";
          tr.appendChild(labelsCell);
          
          const labelCountsCell = document.createElement("td");
          if (row.label_counts && typeof row.label_counts === 'object') {
            labelCountsCell.textContent = Object.entries(row.label_counts)
              .map(([k, v]) => `${k}: ${v}`)
              .join(", ");
          } else {
            labelCountsCell.textContent = "—";
          }
          tr.appendChild(labelCountsCell);
          
          dataTableBody.appendChild(tr);
        });
      }
    }
    
    // ===== CSV Export =====
    function exportToCSV() {
      if (filteredData.length === 0) {
        alert("No data to export");
        return;
      }
      
      const headers = ["Date", "Student", "Assignment", "Mode", "Total Labels", "Label Counts"];
      const rows = filteredData.map(row => {
        const date = new Date(row.created_at).toLocaleDateString();
        const student = row.student_name || "";
        const assignment = row.assignment_name || "";
        const mode = row.mode || "";
        const totalLabels = row.total_labels != null ? row.total_labels : "";
        const labelCounts = row.label_counts && typeof row.label_counts === 'object'
          ? Object.entries(row.label_counts).map(([k, v]) => `${k}: ${v}`).join("; ")
          : "";
        
        return [date, student, assignment, mode, totalLabels, labelCounts];
      });
      
      const csvContent = [
        headers.join(","),
        ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(","))
      ].join("\n");
      
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      const url = URL.createObjectURL(blob);
      link.setAttribute("href", url);
      link.setAttribute("download", `vysti-progress-${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = "hidden";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    
    // ===== PDF Export =====
    function exportToPDF() {
      if (filteredData.length === 0) {
        alert("No data to export");
        return;
      }
      
      const printHeader = document.getElementById("printHeader");
      const printGeneratedAt = document.getElementById("printGeneratedAt");
      const printMeta = document.getElementById("printMeta");
      
      // Build filter summary
      const summary = [];
      
      // Student
      const studentValue = studentFilter.value || "All Students";
      summary.push(`<div><strong>Student:</strong> ${studentValue}</div>`);
      
      // Series
      const seriesValue = seriesFilter.value || "All Series";
      summary.push(`<div><strong>Series:</strong> ${seriesValue}</div>`);
      
      // Range
      let rangeText = "";
      if (rangeStart.value && rangeEnd.value) {
        rangeText = `Custom: ${rangeStart.value}-${rangeEnd.value}`;
      } else {
        const activeRangeBtn = document.querySelector(".range-btn.active");
        if (activeRangeBtn) {
          const rangeData = activeRangeBtn.dataset.range;
          if (rangeData === "6") rangeText = "First 6";
          else if (rangeData === "12") rangeText = "First 12";
          else if (rangeData === "all") rangeText = "All";
          else rangeText = "All";
        } else {
          rangeText = "All";
        }
      }
      summary.push(`<div><strong>Range:</strong> ${rangeText}</div>`);
      
      // Buckets
      const selectedBucketIds = getSelectedBucketIds();
      let bucketText = "";
      if (selectedBucketIds.length === 0) {
        bucketText = "All Categories";
      } else {
        const selectedBuckets = selectedBucketIds.map(id => {
          const bucket = LABEL_BUCKETS.find(b => b.id === id);
          return bucket ? bucket.name : id;
        });
        bucketText = selectedBuckets.join(", ");
      }
      summary.push(`<div><strong>Buckets:</strong> ${bucketText}</div>`);
      
      // Include duplicates
      const duplicatesText = includeDuplicates.checked ? "Yes" : "No";
      summary.push(`<div><strong>Include duplicates:</strong> ${duplicatesText}</div>`);
      
      // Class (if classFilter exists)
      if (classFilter) {
        const classValue = classFilter.value;
        let classText = "All Classes";
        if (classValue === "__unassigned__") {
          classText = "Unassigned";
        } else if (classValue) {
          const selectedOption = classFilter.options[classFilter.selectedIndex];
          classText = selectedOption ? selectedOption.textContent : "All Classes";
        }
        summary.push(`<div><strong>Class:</strong> ${classText}</div>`);
      }
      
      // Set print header content
      printMeta.innerHTML = summary.join("");
      printGeneratedAt.textContent = `Generated: ${new Date().toLocaleString()}`;
      
      // Add printing class to body
      document.body.classList.add("printing");
      
      // Small timeout to allow layout updates
      setTimeout(() => {
        window.print();
      }, 50);
      
      // Remove printing class after print
      window.onafterprint = () => {
        document.body.classList.remove("printing");
        window.onafterprint = null;
      };
    }
    
    // ===== Event listeners =====
    rangeBtns.forEach(btn => {
      btn.addEventListener("click", () => {
        rangeBtns.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentRange = btn.dataset.range;
        applyFilters();
      });
    });
    
    rangeStart.addEventListener("input", () => {
      if (rangeStart.value && rangeEnd.value) {
        rangeBtns.forEach(b => b.classList.remove("active"));
        currentRange = "custom";
        applyFilters();
      }
    });
    
    rangeEnd.addEventListener("input", () => {
      if (rangeStart.value && rangeEnd.value) {
        rangeBtns.forEach(b => b.classList.remove("active"));
        currentRange = "custom";
        applyFilters();
      }
    });
    
    classFilter.addEventListener("change", loadData);
    studentFilter.addEventListener("change", applyFilters);
    seriesFilter.addEventListener("change", applyFilters);
    includeDuplicates.addEventListener("change", applyFilters);
    exportBtn.addEventListener("click", exportToCSV);
    
    const exportPdfBtn = document.getElementById("exportPdfBtn");
    if (exportPdfBtn) {
      exportPdfBtn.addEventListener("click", exportToPDF);
    }
    
    // ===== Initial load =====
    refreshAuthUI();
  </script>
</body>
</html>

