<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vysti Marker â€” Student Check</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/marker.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docx-preview/dist/docx-preview.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <style>
    .assignment-tracker-block {
      margin-bottom: 18px;
      padding: 16px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    .assignment-tracker-title {
      font-size: var(--fs-sm);
      font-weight: 700;
      color: var(--text);
      margin-bottom: 4px;
    }
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .assignment-tracker-help {
      font-size: var(--fs-sm);
      color: var(--muted);
      margin-bottom: 12px;
    }
    .primary-btn.is-loading {
      cursor: progress;
      opacity: 0.95; /* keep readable even while disabled */
    }

    /* Loading indicator: blinking cursor (optional; controlled in JS) */
    @keyframes vysti-caret-blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }
    button.loading-cursor::after {
      content: " \258c"; /* U+258C (left half block) */
      animation: vysti-caret-blink 900ms step-end infinite;
    }

    /* Preview action area (centered button below preview) */
    .preview-actions {
      margin-top: 16px;
      display: flex;
      justify-content: center;
    }
    .preview-actions .primary-btn {
      width: min(360px, 100%);
      margin-top: 0; /* override default .primary-btn margin-top */
    }
    .marked-preview-card {
      margin-top: 24px;
      grid-column: 1 / -1;
    }
    .preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }
    .preview-header-right{
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }
    .preview-header-stats-row{
      display: flex;
      align-items: stretch;
      gap: 10px;
    }
    .preview-header-stats{
      display: block;
    }
    .preview-stat{
      min-height: 0;
    }
    .preview-title {
      margin: 0;
      font-size: var(--fs-h3);
      font-weight: 700;
    }
    .preview-zoom {
      height: 32px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: var(--fs-xs);
      color: var(--muted);
    }
    .preview-tools{
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
    }
    .preview-pill-btn{
      height: 32px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      line-height: 1;
      padding: 0 12px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,.14);
      background: #fff;
      color: rgba(0,0,0,.75);
      font-size: var(--fs-xs);
      font-weight: 700;
      cursor: pointer;
    }
    .preview-pill-btn:hover{ background: rgba(0,0,0,.03); }
    .preview-pill-btn:active{ transform: translateY(0.5px); }
    .preview-pill-icon{
      font-size: 14px;
      line-height: 1;
    }
    @media (max-width: 980px){
      .preview-header-right{
        flex-wrap: wrap;
        justify-content: flex-end;
      }
    }
    #previewZoom {
      width: auto;
      height: 32px;
      padding: 0 8px;
      border-radius: 8px;
      font-size: var(--fs-xs);
    }
    .metric-success{
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
      font-size: var(--fs-xs);
      font-weight: 800;
      color: rgba(0,0,0,.65);
    }
    .metric-success .star{
      color: #f0ad4e;
      font-size: 14px;
      line-height: 1;
    }
    .power-quests{
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 6px;
    }
    .quest-row{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .quest-row.pill-row{
      justify-content: flex-start;
      flex-wrap: wrap;
    }
    .quest-pill{
      display: inline-flex;
      align-items: center;
      padding: 6px 10px;
      border-radius: 999px;
      background: #fff;
      border: 1px solid rgba(0,0,0,.18);
      font-size: var(--fs-xs);
      font-weight: 800;
      color: rgba(0,0,0,.70);
      white-space: nowrap;
    }
    .quest-pill-btn{
      appearance: none;
      cursor: pointer;
    }
    .quest-pill-btn:disabled{
      opacity: .55;
      cursor: not-allowed;
      background: #f6f6f6;
    }
    .quest-pill-btn:hover{
      background: rgba(0,0,0,.03);
    }
    .quest-pill.weak.quest-pill-btn:hover{
      background: rgba(217,83,79,.06);
    }
    .quest-pill.power.quest-pill-btn:hover{
      background: rgba(46,204,113,.08);
    }
    .quest-pill-btn:active{
      transform: translateY(0.5px);
    }
    .quest-pill.weak{ border-color: rgba(217,83,79,.55); }
    .quest-pill.power{ border-color: rgba(46,204,113,.55); }
    .quest-dots{
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    .quest-dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,.85);
      background: #fff;
    }
    .quest-dot.good{ background: #2ecc71; }
    .quest-dot.bad{ background: #d9534f; }
    .quest-dot.empty{ background: #fff; }
    .quest-more{
      font-size: var(--fs-xs);
      font-weight: 800;
      color: rgba(0,0,0,.45);
    }
    .marked-preview-container {
      max-height: 600px;
      overflow: auto;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 16px;
      background: #fff;
    }
    .revision-practice-card {
      margin-top: 24px;
      grid-column: 1 / -1;
    }
    .revision-practice-title {
      margin-bottom: 12px;
      font-size: var(--fs-h3);
      font-weight: 700;
      text-align: center;
    }
    .most-common-footer {
      margin-top: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .most-common-word-count,
    .most-common-total-issues {
      font-size: var(--fs-sm);
      font-weight: 600;
      color: var(--text);
    }
    .most-common-techniques {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: #fff;
      text-align: right;
      margin-left: auto;
    }
    .most-common-techniques-title {
      font-size: var(--fs-xs);
      font-weight: 700;
      color: var(--muted);
      margin-bottom: 6px;
      text-transform: none;
      letter-spacing: 0.02em;
    }
    .most-common-techniques-list {
      font-size: var(--fs-sm);
      color: var(--text);
      line-height: 1.4;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .issue-select-wrapper {
      display: none;
    }
    .issue-buttons-wrap {
      display: none;
      flex-direction: column;
      gap: 14px;
    }
    .issue-section-block {
      padding-top: 4px;
    }
    .issue-section-heading {
      text-align: center;
      font-size: var(--fs-sm);
      font-weight: 700;
      color: rgba(0, 0, 0, 0.7);
      margin: 6px 0 8px;
      letter-spacing: 0.02em;
    }
    .issue-button-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }
    .issue-btn {
      appearance: none;
      border: 1px solid var(--issue-border, #e0e0e0);
      background: var(--issue-bg, #fff);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: var(--fs-xs);
      cursor: pointer;
      transition: border-color 120ms ease, box-shadow 120ms ease, transform 80ms ease, background-color 120ms ease;
    }
    .issue-btn:hover {
      border-color: var(--issue-border, #e0e0e0);
      background: var(--issue-bg-hover, #fff);
    }
    .issue-btn:active {
      transform: translateY(1px);
    }
    .issue-btn.active {
      border-color: var(--issue-border, #e0e0e0);
      box-shadow: 0 0 0 2px var(--issue-ring, rgba(128, 0, 32, 0.15));
    }
    .issue-explanation-header {
      font-weight: 700;
      font-size: var(--fs-sm);
      margin-bottom: 6px;
      padding: 0 12px;
      color: rgba(0, 0, 0, .75);
      text-transform: none;
    }
    .issue-explanation {
      margin-bottom: 16px;
      padding: 12px;
      background: #f8f9fa;
      border-radius: 6px;
      font-size: var(--fs-sm);
      color: var(--text);
    }
    .examples-empty-state {
      margin: 0 0 16px;
      padding: 12px;
      background: #f8f9fa;
      border: 1px solid rgba(0, 0, 0, 0.08);
      border-radius: 8px;
      font-size: var(--fs-sm);
      color: rgba(0, 0, 0, 0.75);
    }
    .mci-tooltip {
      pointer-events: none;
      z-index: 80;
      width: min(380px, calc(100vw - 24px));
      max-width: min(380px, calc(100vw - 24px));
    }
    .mci-tooltip .mci-tooltip-header {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }
    .mci-tooltip .mci-count {
      font-weight: 600;
      margin-bottom: 6px;
    }
    .mci-tooltip .mci-explanation {
      font-size: var(--fs-sm);
      color: rgba(0, 0, 0, .75);
      line-height: 1.45;
    }
    .mci-tooltip .mci-hint {
      margin-top: 10px;
      font-size: var(--fs-xs);
      font-weight: 700;
      color: rgba(90, 15, 28, 0.75);
    }
    .examples-nav {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin: 6px 0 12px;
      padding: 0 4px;
    }
    .examples-nav-text {
      font-size: var(--fs-xs);
      font-weight: 600;
      color: var(--muted);
    }
    .next-example-btn {
      padding: 6px 12px;
      font-size: var(--fs-xs);
      white-space: nowrap;
    }
    .examples-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .example-item {
      margin-bottom: 20px;
      padding: 16px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }
    .example-guidance {
      font-size: var(--fs-sm);
      font-weight: 600;
      color: #5a0f1c;
      margin-bottom: 8px;
      padding: 12px;
      background: rgba(169, 13, 34, 0.08);
      border: 1px solid rgba(169, 13, 34, 0.18);
      border-left: 4px solid rgba(169, 13, 34, 0.65);
      border-radius: 6px;
    }
    .example-guidance-label {
      font-weight: 700;
      font-size: var(--fs-xs);
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: rgba(90, 15, 28, 0.75);
      margin-bottom: 6px;
    }
    .example-guidance-text {
      font-weight: 600;
      font-size: var(--fs-sm);
      color: var(--text);
    }
    .example-meta {
      font-size: var(--fs-xs);
      color: var(--muted);
      margin: -2px 0 10px;
      font-weight: 600;
    }
    .example-student {
      font-size: var(--fs-xs);
      color: var(--muted);
      margin-bottom: 12px;
    }
    .example-rewrite {
      width: 100%;
      min-height: 80px;
      max-height: 220px;
      padding: 8px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      font-size: var(--fs-body);
      font-family: inherit;
      margin-bottom: 8px;
      resize: vertical;
      overflow-y: hidden;
    }
    .example-actions {
      display: flex;
      gap: 8px;
    }
    .power-verbs-helper {
      margin: 6px 0 10px;
    }
    .power-verbs-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 8px;
    }
    .power-verbs-title {
      font-size: var(--fs-sm);
      font-weight: 600;
      color: rgba(0, 0, 0, 0.75);
    }
    .power-verbs-actions {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .power-verbs-feedback {
      font-size: var(--fs-xs);
      color: rgba(0, 0, 0, 0.6);
      min-height: 14px;
    }
    .power-verbs-iconbtn{
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,.14);
      background: #fff;
      color: rgba(0,0,0,.55);
      font-size: 16px;
      font-weight: 900;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .power-verbs-iconbtn:hover{ background: rgba(0,0,0,.03); }
    .power-verbs-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .power-verbs-suggestions-row{
      display: flex;
      align-items: flex-start;
      gap: 10px;
      margin-top: 8px;
    }
    .power-verbs-suggestions-list{
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .power-verbs-shuffle-btn{
      width: 48px;
      height: 48px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,.14);
      background: #fff;
      color: rgba(0,0,0,.55);
      font-size: 26px;
      font-weight: 900;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .power-verbs-shuffle-btn:hover{ background: rgba(0,0,0,.03); }
    .approved-rewrites-wrap {
      margin-top: 16px;
      padding: 14px;
      border-radius: 10px;
      border: 1px solid rgba(53, 133, 53, 0.35);
      background: rgba(231, 245, 231, 0.45);
    }
    .approved-rewrites-title {
      margin: 10px 0 8px;
      font-size: var(--fs-sm);
      font-weight: 700;
      color: #2d5a2d;
    }
    .approved-rewrites-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .approved-rewrites-toggle {
      border: 1px solid rgba(53, 133, 53, 0.35);
      background: rgba(241, 251, 241, 0.9);
      color: #2d5a2d;
      font-size: var(--fs-xs);
      font-weight: 700;
      border-radius: 999px;
      padding: 6px 12px;
      cursor: pointer;
    }
    .approved-rewrites-toggle:hover {
      background: rgba(224, 244, 224, 0.95);
    }
    .approved-rewrites-wrap[data-collapsed="true"] .approved-rewrites-list {
      display: none;
    }
    .approved-rewrites-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .approved-rewrite-card {
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #a8d5a8;
      background: #f1fbf1;
    }
    .approved-rewrite-label {
      font-size: var(--fs-xs);
      font-weight: 700;
      color: #2d5a2d;
      margin-bottom: 6px;
    }
    .approved-rewrite-text {
      font-size: var(--fs-sm);
      color: var(--text);
      margin-bottom: 8px;
      white-space: pre-wrap;
    }
    .approved-rewrite-actions {
      display: flex;
      gap: 8px;
    }
    .example-btn {
      padding: 7px 12px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      background: #fff;
      font-size: var(--fs-xs);
      cursor: pointer;
    }
    .example-btn:hover {
      background: #f0f0f0;
    }
    .example-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .example-btn.remove-issue-btn {
      border-color: rgba(128, 0, 32, 0.35);
      color: #7a1c1c;
      background: #fff;
    }
    .example-btn.remove-issue-btn:hover {
      background: #fbeaea;
    }
    .apply-to-preview-btn {
      background: #f8f9fa;
      border-color: rgba(0,0,0,.14);
      color: rgba(0,0,0,.75);
    }
    .apply-to-preview-btn.apply-attention,
    #applyAllToPreviewBtn.apply-attention {
      border-color: rgba(128, 0, 32, 0.75);
      outline: 2px solid rgba(128, 0, 32, 0.55);
      box-shadow:
        0 0 0 4px rgba(128, 0, 32, 0.18),
        0 0 14px rgba(128, 0, 32, 0.32);
      animation: applyPulse 1.4s ease-in-out infinite;
    }
    @keyframes applyPulse {
      0% {
        box-shadow:
          0 0 0 0 rgba(128, 0, 32, 0.22),
          0 0 10px rgba(128, 0, 32, 0.28);
      }
      60% {
        box-shadow:
          0 0 0 8px rgba(128, 0, 32, 0),
          0 0 16px rgba(128, 0, 32, 0.18);
      }
      100% {
        box-shadow:
          0 0 0 0 rgba(128, 0, 32, 0),
          0 0 12px rgba(128, 0, 32, 0.24);
      }
    }
    .apply-all-btn {
      margin-top: 12px;
      width: 100%;
    }
    .apply-to-preview-btn:not(:disabled):hover {
      background: #e9ecef;
    }
    .example-applied {
      opacity: 0.7;
      background: #f0f0f0;
    }
    .example-item.example-approved {
      background: #e7f5e7;
      border-color: #a8d5a8;
    }
    .example-dismissed {
      background: #f9f2f2;
      border-color: #e7cfcf;
    }
    .hidden-select {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      width: 0;
      height: 0;
    }
    .rewrite-status {
      margin-top: 8px;
      padding: 8px;
      border-radius: 6px;
      font-size: var(--fs-xs);
      display: none;
    }
    .rewrite-status.visible {
      display: block;
    }
    .rewrite-status.ok {
      background: #e7f5e7;
      color: #2d5a2d;
      border: 1px solid #a8d5a8;
    }
    .rewrite-status.bad {
      background: #ffe7e7;
      color: #5a2d2d;
      border: 1px solid #d5a8a8;
    }
    .rewrite-status.checking {
      background: #eef3f8;
      color: #1f3b5b;
      border: 1px solid #c6d7ea;
    }
    .rewrite-status.checking::after {
      content: "...";
      display: inline-block;
      width: 0;
      overflow: hidden;
      vertical-align: bottom;
      animation: rewriteDots 1s steps(4, end) infinite;
    }
    @keyframes rewriteDots {
      to { width: 1.25em; }
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <img src="/assets/logo.svg" alt="Vysti" />
    </div>
  
    <nav></nav>
  
    <div class="actions">
      <button class="topbar-btn" id="progressBtn" type="button">Progress</button>
      <button class="topbar-btn" id="switchModeBtn" type="button">Teacher</button>
      <button class="iconbtn repeat-tutorial-trigger" id="repeatTutorialBtn" type="button" aria-label="Repeat tutorial" data-tip="Repeat the tutorial">?</button>
      <button class="topbar-btn" id="logoutBtn" type="button">Sign Out</button>
    </div>
  </header>

  <main class="page student-page">
    <form id="studentForm" class="marker-grid" style="display:none;">
      <section class="card form-card">
        <label>
          <span class="label-row mode-select-label-row">
            <span class="visually-hidden">Assignment type</span>
          </span>
          <select id="mode" aria-label="Assignment type">
            <option value="textual_analysis">Analytic essay</option>
            <option value="peel_paragraph">Mini-essay paragraph</option>
            <option value="reader_response">Reader response</option>
            <option value="argumentation">Argumentation</option>
          </select>
        </label>

        <!-- Mode explainer card (single, dynamic) -->
        <div class="mode-card" id="modeCard">
          <div class="mode-card-header">
            <span class="mode-badge" id="modeBadge">Analytic essay</span>
            <span class="mode-tag" id="modeTag"></span>
          </div>

          <div class="mode-desc" id="modeDesc">
            A formal and academic essay of analysis with all Vysti Rules running.
          </div>

          <button type="button" class="mode-more" id="modeMoreBtn" aria-expanded="false">
            Want more details?
          </button>

          <div class="mode-details" id="modeDetails" hidden>
            <ul id="modeDetailsList"></ul>
          </div>
        </div>

        <div class="assignment-tracker-block">
          <div class="assignment-tracker-title">
            <span class="label-row">
              Assignment Tracker
            </span>
          </div>
          <label class="visually-hidden" for="assignmentName">Assignment name (optional)</label>
          <input type="text" id="assignmentName" placeholder="Assignment 01" aria-label="Assignment name (optional)" />
        </div>

        <button class="primary-btn" id="checkBtn" type="submit" disabled>Mark my essay</button>
      </section>

      <section class="card upload-card">
        <label>Upload</label>
        
        <div id="dropZone" class="drop-zone" tabindex="0" role="button" aria-label="Upload .docx file">
          <img class="dz-icon" src="/assets/cloud-upload.svg" alt="" aria-hidden="true" />
          <div class="dz-title">Drag & drop .docx file here</div>
          <div class="dz-sub">or click to browse</div>
          
          <input
            type="file"
            id="fileInput"
            name="file"
            accept=".docx"
            hidden
          />
        </div>

        <ul id="fileList" class="file-list"></ul>
        <button type="button" id="clearFileBtn" class="secondary-btn" style="display:none;">Clear file</button>
      </section>

      <section class="card rules-card" id="resultsCard" style="display:none;">
        <div id="statusArea" class="status-area" role="status" aria-live="polite"></div>

        <button id="downloadBtn" class="secondary-btn" type="button" style="display:none; margin-top:12px;">
          Download marked essay
        </button>

        <div id="mostCommonIssuesWrap" style="margin-top: 20px; display:none;">
          <div class="rules-title">Most Common Issues</div>
          <div id="mciScrollViewport" class="mci-scroll-viewport">
            <div id="mciScrollInner" class="mci-scroll-inner">
              <canvas id="mostCommonIssuesChart"></canvas>
            </div>
          </div>
        </div>
      </section>
    </form>

    <section class="card revision-practice-card" id="revisionPracticeCard" style="display:none;">
      <h2 class="revision-practice-title">Revision examples</h2>
      <div class="issue-select-wrapper">
        <!-- New UI -->
        <div id="issueButtonsWrap" class="issue-buttons-wrap"></div>

        <!-- Keep old selects for existing JS, but hide them -->
        <div class="issue-selects-hidden" style="display:none;">
          <label>
            Select a section
            <select id="sectionSelect"></select>
          </label>
          <label>
            Select an issue to practice
            <select id="issueSelect"></select>
          </label>
        </div>
      </div>
      <div id="issueExplanationBlock" style="display:none;">
        <div class="issue-explanation-header">Explanation of the Issue</div>
        <div id="issueExplanation" class="issue-explanation"></div>
      </div>
      <div id="allApprovedBanner" class="examples-empty-state" style="display:none;">
        All examples for this issue are approved. Apply them to the Preview to update your progress, then click another bar to revise a different issue.
      </div>
      <div id="examplesEmptyState" class="examples-empty-state" style="display:none;"></div>
      <div id="exampleNavRow" class="examples-nav" style="display:none;">
        <div id="exampleNavText" class="examples-nav-text">Issue 0 of 0</div>
        <button type="button" class="secondary-btn next-example-btn" id="nextExampleBtn">Next â†’</button>
      </div>
      <ul id="examplesList" class="examples-list"></ul>
      <div id="approvedRewritesWrap" class="approved-rewrites-wrap" style="display:none;" data-collapsed="true">
        <button type="button" class="secondary-btn apply-all-btn apply-to-preview-btn" id="applyAllToPreviewBtn" style="display:none;" disabled>Apply all rewrites to Preview</button>
        <div class="approved-rewrites-header">
          <div class="approved-rewrites-title">Approved rewrites</div>
          <button type="button" class="approved-rewrites-toggle" id="approvedRewritesToggle" aria-expanded="false">Show approved rewrites</button>
        </div>
        <ul id="approvedRewritesList" class="approved-rewrites-list"></ul>
      </div>
      <button type="button" class="secondary-btn" id="downloadRevisionNotesBtn" style="margin-top: 16px; display:none;">Download revision notes</button>
    </section>

    <section class="card marked-preview-card" id="markedPreviewCard" style="display:none;">
      <div class="preview-header">
        <h2 class="preview-title">Preview</h2>

        <div class="preview-header-right">
          <div id="statsPanel" class="preview-header-stats" style="display:none;">
            <div class="preview-header-stats-row">
              <div class="student-stat preview-stat">
                <div class="student-stat-label">Word count</div>
                <div id="wordCountStat" class="student-stat-value">â€”</div>
              </div>

              <div class="student-stat preview-stat">
                <div class="student-stat-label">Total issues</div>
                <div id="totalIssuesStat" class="student-stat-value">â€”</div>
              </div>
            </div>
          </div>

          <div class="preview-tools">
            <label class="preview-zoom" for="previewZoom">
              <span>Zoom</span>
              <select id="previewZoom">
                <option value="0.8">80%</option>
                <option value="0.9">90%</option>
                <option value="1">100%</option>
                <option value="1.1">110%</option>
                <option value="1.25">125%</option>
                <option value="1.5" selected>150%</option>
              </select>
            </label>
            <button type="button" class="preview-pill-btn" id="previewPowerVerbsBtn" aria-label="Open Power Verbs">
              <span class="preview-pill-icon" aria-hidden="true">ðŸ“˜</span>
              Power Verbs
            </button>
          </div>
        </div>
      </div>
      <div class="preview-metrics-wrap">
        <div class="student-metrics-grid metrics-inline" id="metricsGrid">
          <div class="metric-card" id="metricPower">
            <div class="metric-head">
              <div class="metric-title">
                Power
                <button class="metric-info metric-info-btn" type="button" data-metric="power" aria-label="Power info">i</button>
              </div>
              <div class="metric-score" id="powerScoreText">â€”</div>
            </div>
            <div class="metric-meter">
              <div class="metric-meter-fill" id="powerMeterFill"></div>
            </div>
            <div class="metric-sub" id="powerSubText"></div>
          </div>

          <div class="metric-card" id="metricVariety">
            <div class="metric-head">
              <div class="metric-title">
                Variety
                <button class="metric-info metric-info-btn" type="button" data-metric="variety" aria-label="Variety info">i</button>
              </div>
              <div class="metric-score" id="varietyScoreText">â€”</div>
            </div>
            <div class="metric-meter">
              <div class="metric-meter-fill" id="varietyMeterFill"></div>
            </div>
            <div class="metric-sub" id="varietySubText"></div>
          </div>

          <div class="metric-card" id="metricCohesion">
            <div class="metric-head">
              <div class="metric-title">
                Cohesion
                <button class="metric-info metric-info-btn" type="button" data-metric="cohesion" aria-label="Cohesion info">i</button>
              </div>
              <div class="metric-score" id="cohesionScoreText">â€”</div>
            </div>
            <div class="metric-meter">
              <div class="metric-meter-fill" id="cohesionMeterFill"></div>
            </div>
            <div class="metric-sub" id="cohesionSubText"></div>
          </div>

          <div class="metric-card" id="metricPrecision">
            <div class="metric-head">
              <div class="metric-title">
                Precision
                <button class="metric-info metric-info-btn" type="button" data-metric="precision" aria-label="Precision info">i</button>
              </div>
              <div class="metric-score" id="precisionScoreText">â€”</div>
            </div>
            <div class="metric-meter">
              <div class="metric-meter-fill" id="precisionMeterFill"></div>
            </div>
            <div class="metric-sub" id="precisionSubText"></div>
          </div>
        </div>
      </div>
      <div id="markedPreview" class="marked-preview-container"></div>

      <!-- Recheck moved here: centered under Preview + styled like primary button -->
      <div class="preview-actions">
        <button type="button" class="primary-btn" id="recheckDocumentBtn" style="display:none;" disabled>Recheck my essay</button>
      </div>
    </section>
    <footer class="marker-footer" aria-label="Site footer">
      <div class="footer-copy">Â© 2025 Vysti Research. All rights reserved.</div>
      <img class="footer-logo" src="/assets/logo_black.png" alt="Vysti" />
    </footer>
  </main>

  <div id="dismissIssueOverlay" class="modal-overlay hidden">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="dismissIssueTitle">
      <div id="dismissIssueTitle" class="modal-title">Dismiss issue</div>
      <div class="modal-body">
        <div class="modal-question">Why are you dismissing this issue?</div>
        <label><input type="radio" name="dismissReason" value="no_issue"> There is no issue</label>
        <label><input type="radio" name="dismissReason" value="unable_to_repair"> Unable to repair issue</label>
        <label><input type="radio" name="dismissReason" value="unclear_guidance"> Unclear student guidance for issue</label>
        <label><input type="radio" name="dismissReason" value="other"> Other</label>
        <textarea id="dismissOtherText" maxlength="280" class="hidden" placeholder="Briefly explain..."></textarea>
        <div id="dismissCharCount" class="hidden">0/280</div>
        <div id="dismissError" class="modal-error hidden"></div>
      </div>
      <div class="modal-actions">
        <button id="dismissCancelBtn" class="secondary-btn">Cancel</button>
        <button id="dismissConfirmBtn" class="primary-btn">Dismiss issue</button>
      </div>
    </div>
  </div>

  <div id="brandConfirmOverlay" class="brand-confirm-overlay" hidden>
    <div class="brand-confirm-popover" role="dialog" aria-modal="true" aria-labelledby="brandConfirmTitle">
      <button class="brand-confirm-close" type="button" aria-label="Close dialog">Ã—</button>
      <div id="brandConfirmTitle" class="brand-confirm-title">Confirm</div>
      <div id="brandConfirmBody" class="brand-confirm-body"></div>
      <div class="brand-confirm-actions">
        <button id="brandConfirmCancel" class="brand-confirm-cancel" type="button">Cancel</button>
        <button id="brandConfirmOk" class="brand-confirm-ok" type="button">Remove</button>
      </div>
    </div>
  </div>

  <div id="metricInfoPopover" class="tour-popover metric-popover hidden" role="dialog" aria-modal="false">
    <button id="metricInfoClose" class="tour-close" type="button" aria-label="Close">Ã—</button>
    <div id="metricInfoTitle" class="tour-title"></div>
    <div id="metricInfoBody" class="tour-body"></div>
  </div>

  <script>
    const DEBUG_METRICS = false;
    const DEBUG_REVISION_BARS = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";

    // ===== Bucket definitions =====
    const LABEL_BUCKETS = [
      {
        id: "thesis_org",
        name: "Thesis & Organization",
        matchers: [
          /thesis/i,
          /topic sentence/i,
          /organization/i,
          /transition/i,
          /boundary statement/i,
          /introduction/i,
          /conclusion/i,
          /paragraph/i,
          /structure/i
        ]
      },
      {
        id: "evidence_integration",
        name: "Evidence & Integration",
        matchers: [
          /quote/i,
          /quotation/i,
          /evidence/i,
          /citation/i,
          /\bcite\b/i,
          /works cited/i,
          /power verbs/i,
          /support/i
        ]
      },
      {
        id: "voice_audience",
        name: "Voice & Audience",
        matchers: [
          /personal pronoun/i,
          /\bI\b/i,
          /\bwe\b/i,
          /\byou\b/i,
          /reader/i,
          /audience/i
        ]
      },
      {
        id: "style_clarity",
        name: "Style & Clarity",
        matchers: [
          /contraction/i,
          /\bwhich\b/i,
          /\bfact\b/i,
          /\bprove\b/i,
          /weak verb/i,
          /article/i,
          /vague/i,
          /people/i,
          /human/i,
          /word choice/i,
          /avoid using the word/i,
          /more than once in a sentence/i
        ]
      },
      {
        id: "grammar_mechanics",
        name: "Grammar & Mechanics",
        matchers: [
          /subject[- ]verb/i,
          /agreement/i,
          /tense/i,
          /comma/i,
          /punctuation/i,
          /spelling/i,
          /apostrophe/i
        ]
      },
      {
        id: "formatting",
        name: "Formatting & Conventions",
        matchers: [
          /MLA/i,
          /header/i,
          /format/i,
          /title/i,
          /author/i
        ]
      },
      { id: "other", name: "Other", matchers: [] }
    ];

    const BUCKET_OVERRIDES = {
      "Avoid quotations in the conclusion": "evidence_integration",
      "Avoid quotations in the introduction": "evidence_integration",
      "Clarify pronouns and antecedents": "grammar_mechanics",
      "Avoid weak verbs": "evidence_integration"
    };

    // Shared bucket color palette (same order as LABEL_BUCKETS)
    // Thesis maroon, Evidence blue, Voice green, Style yellow, Grammar purple, Formatting red, Other teal
    const BUCKET_COLORS = [
      "rgba(169, 13, 34, 1)",    // maroon - Thesis & Organization
      "rgba(52, 152, 219, 1)",   // blue - Evidence & Integration
      "rgba(46, 204, 113, 1)",   // green - Voice & Audience
      "rgba(241, 196, 15, 1)",   // yellow - Style & Clarity
      "rgba(155, 89, 182, 1)",   // purple - Grammar & Mechanics
      "rgba(231, 76, 60, 1)",    // red - Formatting & Conventions
      "rgba(26, 188, 156, 1)",   // teal - Other
    ];

    // Helper function to get bucket color by bucketId
    // Returns color with specified alpha (default 1.0 for full opacity)
    function getBucketColor(bucketId, alpha = 1.0) {
      const bucketIndex = LABEL_BUCKETS.findIndex(b => b.id === bucketId);
      if (bucketIndex === -1) {
        // Fallback to "other" color if bucket not found
        const otherIndex = LABEL_BUCKETS.findIndex(b => b.id === "other");
        const baseColor = BUCKET_COLORS[otherIndex >= 0 ? otherIndex : BUCKET_COLORS.length - 1];
        return baseColor.replace("1)", `${alpha})`);
      }
      const baseColor = BUCKET_COLORS[bucketIndex];
      return baseColor.replace("1)", `${alpha})`);
    }

    function getBucketIdForLabel(label) {
      if (!label) return "other";
      if (BUCKET_OVERRIDES[label]) return BUCKET_OVERRIDES[label];
      for (const b of LABEL_BUCKETS) {
        if (b.id === "other") continue;
        if (b.matchers.some(rx => rx.test(label))) return b.id;
      }
      return "other";
    }

    // ===== Supabase auth setup =====
    const SUPABASE_URL = "https://divdfodsdtfbdwoqvsfy.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRpdmRmb2RzZHRmYmR3b3F2c2Z5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU0MjU1OTksImV4cCI6MjA4MTAwMTU5OX0.fnm_9qX5DqdR0j6y-2mRRkwr8Icm1uRNPbUo6lqzock";

    const { createClient } = supabase;
    const supa = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const form = document.getElementById("studentForm");
    const fileInput = document.getElementById("fileInput");
    const checkBtn = document.getElementById("checkBtn");
    const clearFileBtn = document.getElementById("clearFileBtn");
    const statusArea = document.getElementById("statusArea");
    const resultsCard = document.getElementById("resultsCard");
    const downloadBtn = document.getElementById("downloadBtn");
    const fileList = document.getElementById("fileList");
    const dropZone = document.getElementById("dropZone");
    const markedPreviewCard = document.getElementById("markedPreviewCard");
    const markedPreview = document.getElementById("markedPreview");
    const previewZoom = document.getElementById("previewZoom");
    const previewPowerVerbsBtn = document.getElementById("previewPowerVerbsBtn");
    const revisionPracticeCard = document.getElementById("revisionPracticeCard");
    const sectionSelect = document.getElementById("sectionSelect");
    const issueSelect = document.getElementById("issueSelect");
    const issueButtonsWrap = document.getElementById("issueButtonsWrap");
    const issueExplanationBlock = document.getElementById("issueExplanationBlock");
    const issueExplanation = document.getElementById("issueExplanation");
    const exampleNavRow = document.getElementById("exampleNavRow");
    const exampleNavText = document.getElementById("exampleNavText");
    const nextExampleBtn = document.getElementById("nextExampleBtn");
    const examplesList = document.getElementById("examplesList");
    const allApprovedBanner = document.getElementById("allApprovedBanner");
    const examplesEmptyState = document.getElementById("examplesEmptyState");
    const applyAllToPreviewBtn = document.getElementById("applyAllToPreviewBtn");
    const approvedRewritesWrap = document.getElementById("approvedRewritesWrap");
    const approvedRewritesList = document.getElementById("approvedRewritesList");
    const approvedRewritesToggle = document.getElementById("approvedRewritesToggle");
    const recheckDocumentBtn = document.getElementById("recheckDocumentBtn");
    const downloadRevisionNotesBtn = document.getElementById("downloadRevisionNotesBtn");
    const mostCommonIssuesWrap = document.getElementById("mostCommonIssuesWrap");
    const mciScrollViewport = document.getElementById("mciScrollViewport");
    const mciScrollInner = document.getElementById("mciScrollInner");
    const mostCommonIssuesChartEl = document.getElementById("mostCommonIssuesChart");
    const brandConfirmOverlay = document.getElementById("brandConfirmOverlay");
    const dismissIssueOverlay = document.getElementById("dismissIssueOverlay");
    const dismissOtherText = document.getElementById("dismissOtherText");
    const dismissCharCount = document.getElementById("dismissCharCount");
    const dismissError = document.getElementById("dismissError");
    const dismissCancelBtn = document.getElementById("dismissCancelBtn");
    const dismissConfirmBtn = document.getElementById("dismissConfirmBtn");

    function openPowerVerbsFromPreview() {
      if (!previewPowerVerbsBtn) return;

      const labelForPower = POWER_VERBS_LABEL || "Avoid weak verbs";
      handlePowerVerbsIssueChange(labelForPower);

      openPowerVerbsPopover(previewPowerVerbsBtn, null);
    }

    if (previewPowerVerbsBtn) {
      previewPowerVerbsBtn.addEventListener("click", openPowerVerbsFromPreview);
    }

    if (brandConfirmOverlay) {
      brandConfirmOverlay.hidden = true;
      brandConfirmOverlay.setAttribute("hidden", "");
    }
    if (dismissIssueOverlay) {
      dismissIssueOverlay.classList.add("hidden");
    }

    if (approvedRewritesToggle) {
      approvedRewritesToggle.addEventListener("click", () => {
        setApprovedRewritesCollapsed(!approvedRewritesCollapsed);
        updateApprovedRewritesToggle(approvedRewritesList ? approvedRewritesList.children.length : 0);
      });
    }

    let mostCommonIssuesChart = null;
    const modeSelect = document.getElementById("mode");
    const assignmentNameInput = document.getElementById("assignmentName");
    const statsPanel = document.getElementById("statsPanel");
    const wordCountStat = document.getElementById("wordCountStat");
    const totalIssuesStat = document.getElementById("totalIssuesStat");
    const topIssueRow = document.getElementById("topIssueRow");
    const topIssueStat = document.getElementById("topIssueStat");
    const techniquesStatWrap = document.getElementById("techniquesStatWrap");
    const techniquesStatList = document.getElementById("techniquesStatList");
    const metricsGrid = document.getElementById("metricsGrid");
    const metricPowerCard = document.getElementById("metricPower");
    const metricVarietyCard = document.getElementById("metricVariety");
    const metricCohesionCard = document.getElementById("metricCohesion");
    const metricPrecisionCard = document.getElementById("metricPrecision");
    const powerScoreText = document.getElementById("powerScoreText");
    const powerMeterFill = document.getElementById("powerMeterFill");
    const powerSubText = document.getElementById("powerSubText");
    const varietyScoreText = document.getElementById("varietyScoreText");
    const varietyMeterFill = document.getElementById("varietyMeterFill");
    const varietySubText = document.getElementById("varietySubText");
    const cohesionScoreText = document.getElementById("cohesionScoreText");
    const cohesionMeterFill = document.getElementById("cohesionMeterFill");
    const cohesionSubText = document.getElementById("cohesionSubText");
    const precisionScoreText = document.getElementById("precisionScoreText");
    const precisionMeterFill = document.getElementById("precisionMeterFill");
    const precisionSubText = document.getElementById("precisionSubText");
    const metricInfoPopover = document.getElementById("metricInfoPopover");
    const metricInfoClose = document.getElementById("metricInfoClose");
    const metricInfoTitle = document.getElementById("metricInfoTitle");
    const metricInfoBody = document.getElementById("metricInfoBody");

    let selectedFile = null;
    const buttonLoadingTimers = new Map();
    let downloadUrl = null;
    let markedBlob = null;
    let currentMarkEvent = null;
    let lastRevisionSectionData = null;
    let currentWordCount = null;
    let currentTechniques = [];
    let detectedWork = null;
    let hasStartedRevising = false;
    let liveLabelCounts = {};
    let dismissedIssues = [];
    let lastStudentMetrics = null;
    let cohesionIssueCache = { paragraph: [], sentence: [], weak: [] };
    let cohesionJumpIndex = { paragraph: 0, sentence: 0, weak: 0 };
    let lastCohesionSource = "";

    let previewWordCountTimer = null;

    function updateWordCountFromPreviewDebounced(delayMs = 350) {
      if (!markedPreview) return;

      if (previewWordCountTimer) {
        clearTimeout(previewWordCountTimer);
        previewWordCountTimer = null;
      }

      previewWordCountTimer = setTimeout(() => {
        const previewText = extractPreviewText();
        if (!previewText) return;

        const wc = wordCountFromText(previewText);
        if (Number.isFinite(wc)) {
          currentWordCount = wc;
          updateStatsPanel(liveLabelCounts);
        }
      }, delayMs);
    }

    const appliedExampleKeys = new Set();
    const approvedExampleKeys = new Set();
    let currentLabel = null;
    let currentExamplesAll = [];
    let currentIndex = 0;
    let currentGuidance = "";
    let currentLabelText = "";
    const draftRewriteByKey = new Map();
    const approvedRewriteByKey = new Map();
    const exampleDataByKey = new Map();
    const examplesByIssueId = new Map();
    const approvedRewrites = [];
    let currentExampleKey = null;
    let approvedRewritesCollapsed = true;
    const issueIdByLabel = new Map();
    const labelByIssueId = new Map();
    const PREVIEW_ONLY_LABELS = new Set([
      "No quotations in topic sentence"
    ]);
    const POWER_VERBS_LABEL = "Avoid weak verbs";
    const POWER_VERBS_INITIAL_COUNT = 5;
    const POWER_VERBS_PAGE_COUNT = 5;
    const POWER_VERBS_STORAGE_PREFIX = "vysti_power_verbs_2025";

    let powerVerbsList = null;
    let powerVerbDefinitionMap = new Map();
    let powerVerbsLoadPromise = null;
    let powerVerbFormsSet = null;
    let activePowerVerbsHelper = null;
    const powerVerbsState = {
      label: null,
      initialVerbs: [],
      pageHistory: [],
      pageIndex: 0,
      recentlyShown: []
    };
    const powerVerbsPopover = {
      el: null,
      grid: null,
      feedback: null,
      nextBtn: null,
      prevBtn: null,
      closeBtn: null,
      anchor: null,
      textarea: null,
      isOpen: false,
      onDocumentClick: null,
      onKeyDown: null,
      onReposition: null
    };

    function hideMarkButtonShowRecheck() {
      if (checkBtn) checkBtn.style.display = "none";
      if (recheckDocumentBtn) recheckDocumentBtn.style.display = "block";
    }

    function showMarkButtonHideRecheck() {
      if (checkBtn) checkBtn.style.display = "block";
      if (recheckDocumentBtn) recheckDocumentBtn.style.display = "none";
    }

    function normLabel(s) {
      return String(s || "").trim().toLowerCase();
    }

    function getLocalRunKey() {
      // Prefer mark_event_id so each re-mark run is a fresh namespace
      const markId = currentMarkEvent?.id;
      if (markId !== null && markId !== undefined && String(markId).trim() !== "") {
        return `mark_${markId}`;
      }
      // Fallbacks (should be rare)
      return `file_${selectedFile?.name || "nofile"}`;
    }

    function resetIssueIdMaps() {
      issueIdByLabel.clear();
      labelByIssueId.clear();
    }

    function normalizeIssueId(label) {
      const slug = String(label || "")
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
      return slug || "issue";
    }

    function registerIssueId(label, idCandidate = "") {
      const cleanLabel = String(label || "").trim();
      if (!cleanLabel) return "";
      if (issueIdByLabel.has(cleanLabel)) return issueIdByLabel.get(cleanLabel);
      let base = String(idCandidate || "").trim();
      if (!base) base = normalizeIssueId(cleanLabel);
      let issueId = base;
      let counter = 1;
      while (labelByIssueId.has(issueId) && labelByIssueId.get(issueId) != cleanLabel) {
        issueId = `${base}-${counter}`;
        counter += 1;
      }
      issueIdByLabel.set(cleanLabel, issueId);
      labelByIssueId.set(issueId, cleanLabel);
      return issueId;
    }

    function syncIssueIdMaps(issues, labelCounts) {
      resetIssueIdMaps();
      (issues || []).forEach((issue) => {
        if (!issue || !issue.label) return;
        const issueId = issue.id || issue.issue_id || issue.issueId || "";
        registerIssueId(issue.label, issueId);
      });
      Object.keys(labelCounts || {}).forEach((label) => {
        registerIssueId(label);
      });
    }

    function getIssueIdForLabel(label) {
      return registerIssueId(label);
    }

    function getLabelForIssueId(issueId) {
      return labelByIssueId.get(issueId) || "";
    }

    function auditRevisionIssueBindings({ issueIds = [], labels = [], source = "" } = {}) {
      if (!DEBUG_REVISION_BARS) return;
      const missingIds = [];
      issueIds.forEach((id, idx) => {
        if (!id) {
          missingIds.push({ index: idx, label: labels[idx] || "" });
          return;
        }
        if (!getLabelForIssueId(id)) {
          console.warn("No label mapped for issueId:", id, "source:", source);
        }
      });
      if (missingIds.length) {
        console.warn("Missing issueIds for revision issues:", missingIds, "source:", source);
      }
      if (source === "buttons" && issueButtonsWrap) {
        const btns = issueButtonsWrap.querySelectorAll(".issue-btn");
        btns.forEach((btn) => {
          if (!btn.dataset.issueId) {
            console.warn("Issue button missing issueId:", btn.textContent || "(no label)");
          }
        });
      }
    }

    function isPreviewOnlyLabel(label) {
      const target = normLabel(label);
      for (const lbl of PREVIEW_ONLY_LABELS) {
        if (normLabel(lbl) === target) return true;
      }
      return false;
    }

    function isAvoidWeakVerbsLabel(label) {
      const l = normLabel(label);
      return (
        l === normLabel("Avoid weak verbs") ||
        l === normLabel("Refer to the Power Verbs list") ||
        l === normLabel("Refer to the Power Verbs List")
      );
    }

    function getPowerVerbsStorageKey(label) {
      return `${POWER_VERBS_STORAGE_PREFIX}__${getLocalRunKey()}__${normLabel(label || "")}`;
    }

    function normalizePowerVerbs(data) {
      const list = Array.isArray(data) ? data : [];
      const verbs = [];
      const seen = new Set();
      powerVerbDefinitionMap = new Map();

      list.forEach((item) => {
        const value = typeof item === "string" ? item : item?.verb;
        if (!value) return;

        const trimmed = String(value).trim();
        if (!trimmed) return;

        const key = trimmed.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);

        const defRaw = (typeof item === "object")
          ? (item?.definition ?? item?.def ?? item?.meaning ?? "")
          : "";

        let def = "";

        if (Array.isArray(defRaw)) {
          def = defRaw.map((x) => String(x || "").trim()).filter(Boolean).join(" ");
        } else {
          def = String(defRaw || "").trim();
        }

        if (def.length > 140) {
          const cut = def.search(/[.!?]\s/);
          if (cut > 0 && cut < 220) {
            def = def.slice(0, cut + 1).trim();
          } else {
            def = def.split(/\n{1,}|\s{2,}/)[0].trim();
          }
        }

        if (def.length > 260) def = def.slice(0, 257).trim() + "â€¦";

        if (defRaw && typeof defRaw === "string" && defRaw.length > 260) {
          console.warn("Power verb definition unusually long (check JSON):", trimmed, defRaw.slice(0, 120));
        }

        if (def) powerVerbDefinitionMap.set(key, def);
        verbs.push(trimmed);
      });

      return verbs;
    }

    function getPowerVerbDefinition(verb) {
      const key = String(verb || "").trim().toLowerCase();
      return powerVerbDefinitionMap.get(key) || "";
    }

    function generateVerbForms(base) {
      const b = String(base || "").trim().toLowerCase();
      if (!b) return new Set();

      const forms = new Set([b]);

      if (b.endsWith("y") && !/[aeiou]y$/.test(b)) forms.add(b.slice(0, -1) + "ies");
      else if (/(s|x|z|ch|sh|o)$/.test(b)) forms.add(b + "es");
      else forms.add(b + "s");

      if (b.endsWith("e")) forms.add(b + "d");
      else if (b.endsWith("y") && !/[aeiou]y$/.test(b)) forms.add(b.slice(0, -1) + "ied");
      else forms.add(b + "ed");

      if (b.endsWith("ie")) forms.add(b.slice(0, -2) + "ying");
      else if (b.endsWith("e") && !b.endsWith("ee") && !b.endsWith("ye")) forms.add(b.slice(0, -1) + "ing");
      else forms.add(b + "ing");

      return forms;
    }

    function buildPowerVerbFormsSet(powerVerbsListInput) {
      const out = new Set();
      (powerVerbsListInput || []).forEach((v) => {
        generateVerbForms(v).forEach((f) => out.add(f));
      });
      return out;
    }
    function loadPowerVerbsList() {
      // Only treat as "loaded" when we actually have entries.
      if (Array.isArray(powerVerbsList) && powerVerbsList.length > 0) {
        return Promise.resolve(powerVerbsList);
      }
      if (powerVerbsLoadPromise) return powerVerbsLoadPromise;

      const CANDIDATE_URLS = [
        "/power_verbs_2025.json",
        "./power_verbs_2025.json",
        "/assets/power_verbs_2025.json"
      ];

      const tryFetch = async () => {
        let lastErr = null;

        for (const url of CANDIDATE_URLS) {
          try {
            const res = await fetch(url, { cache: "no-store" });
            if (!res.ok) {
              lastErr = new Error(`${url} returned HTTP ${res.status}`);
              continue;
            }
            const data = await res.json();
            const normalized = normalizePowerVerbs(data);
            powerVerbsList = Array.isArray(normalized) ? normalized : [];
            powerVerbFormsSet = buildPowerVerbFormsSet(powerVerbsList);
            return powerVerbsList;
          } catch (e) {
            lastErr = e;
          }
        }

        console.warn("Failed to load power verbs from all candidate URLs:", lastErr);

        // Allow retry on next click (do NOT cache empty forever)
        powerVerbsList = [];
        powerVerbsLoadPromise = null;
        return powerVerbsList;
      };

      powerVerbsLoadPromise = tryFetch();

      return powerVerbsLoadPromise;
    }

    function sampleUnique(list, count, excludeSet = null) {
      const pool = excludeSet
        ? list.filter((item) => !excludeSet.has(item))
        : list.slice();
      if (pool.length <= count) return pool.slice();
      for (let i = pool.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }
      return pool.slice(0, count);
    }

    function getUsedPowerVerbKeysInPreview() {
      const raw = extractPreviewText ? (extractPreviewText() || "") : "";
      const norm = normalizeForMatch(raw).toLowerCase();
      const tokens = new Set(tokenizeWords(norm));

      const used = new Set();
      (powerVerbsList || []).forEach((verb) => {
        const v = String(verb || "").trim();
        if (!v) return;
        const k = v.toLowerCase();

        if (k.includes(" ")) {
          const phrase = k.replace(/\s+/g, " ");
          if (norm.includes(phrase)) used.add(k);
        } else if (tokens.has(k)) {
          used.add(k);
        }
      });

      return used;
    }

    function samplePowerVerbs(count, extraExcludeLowerSet = null) {
      const used = getUsedPowerVerbKeysInPreview();
      const exclude = new Set([...(extraExcludeLowerSet || [])]);

      used.forEach((k) => exclude.add(k));

      let pool = (powerVerbsList || []).filter((v) => !exclude.has(String(v).toLowerCase()));

      if (pool.length < count) {
        const fallbackExclude = extraExcludeLowerSet || new Set();
        pool = (powerVerbsList || []).filter(
          (v) => !fallbackExclude.has(String(v).toLowerCase())
        );
      }

      return sampleUnique(pool, count);
    }

    function loadStoredPowerVerbs(label) {
      const key = getPowerVerbsStorageKey(label);
      try {
        const raw = localStorage.getItem(key);
        const parsed = raw ? JSON.parse(raw) : [];
        return Array.isArray(parsed) ? parsed.filter(Boolean) : [];
      } catch (error) {
        console.warn("Failed to load stored power verbs:", error);
        return [];
      }
    }

    function storePowerVerbs(label, verbs) {
      const key = getPowerVerbsStorageKey(label);
      try {
        localStorage.setItem(key, JSON.stringify(verbs || []));
      } catch (error) {
        console.warn("Failed to store power verbs:", error);
      }
    }

    function ensureInitialPowerVerbs(label) {
      if (!isAvoidWeakVerbsLabel(label)) return;
      if (powerVerbsState.initialVerbs.length) return;
      const stored = loadStoredPowerVerbs(label);
      if (stored.length) {
        const used = getUsedPowerVerbKeysInPreview();
        const filtered = stored.filter((verb) => !used.has(String(verb).toLowerCase()));
        if (filtered.length) {
          powerVerbsState.initialVerbs = filtered.slice(0, POWER_VERBS_INITIAL_COUNT);
          return;
        }
      }
      if (!powerVerbsList || !powerVerbsList.length) return;
      const verbs = samplePowerVerbs(POWER_VERBS_INITIAL_COUNT);
      powerVerbsState.initialVerbs = verbs;
      storePowerVerbs(label, verbs);
    }

    function showPowerVerbFeedback(targetEl, message) {
      if (!targetEl) return;
      targetEl.textContent = message;
      if (targetEl._timer) clearTimeout(targetEl._timer);
      targetEl._timer = setTimeout(() => {
        if (targetEl) targetEl.textContent = "";
      }, 1800);
    }

    function insertVerbIntoTextarea(textarea, verb) {
      if (!textarea || document.activeElement !== textarea) return false;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      if (typeof start !== "number" || typeof end !== "number") return false;
      const before = textarea.value.slice(0, start);
      const after = textarea.value.slice(end);
      const needsSpaceBefore = before && !/\s$/.test(before);
      const needsSpaceAfter = after && !/^\s/.test(after);
      const insertText = `${needsSpaceBefore ? " " : ""}${verb}${needsSpaceAfter ? " " : ""}`;
      textarea.value = before + insertText + after;
      const cursor = before.length + insertText.length;
      textarea.setSelectionRange(cursor, cursor);
      textarea.dispatchEvent(new Event("input", { bubbles: true }));
      return true;
    }

    function replaceSelectionInTextarea(textarea, text) {
      if (!textarea) return false;
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      if (typeof start !== "number" || typeof end !== "number") return false;
      if (start === end) return false;

      const before = textarea.value.slice(0, start);
      const after = textarea.value.slice(end);
      textarea.value = before + text + after;

      const cursor = before.length + text.length;
      textarea.setSelectionRange(cursor, cursor);
      textarea.dispatchEvent(new Event("input", { bubbles: true }));
      return true;
    }

    function handlePowerVerbClick(verb, { feedbackEl, textarea } = {}) {
      const didInsert = insertVerbIntoTextarea(textarea, verb);
      const copy = navigator.clipboard?.writeText
        ? navigator.clipboard.writeText(verb)
        : Promise.reject(new Error("Clipboard unavailable"));
      copy
        .then(() => showPowerVerbFeedback(feedbackEl, "Copied!"))
        .catch(() => {
          if (didInsert) {
            showPowerVerbFeedback(feedbackEl, "Inserted!");
          } else {
            showPowerVerbFeedback(feedbackEl, "Copy failed");
          }
        });
    }

    function renderPowerVerbButtons(container, verbs, { feedbackEl, textarea } = {}) {
      if (!container) return;
      container.innerHTML = "";
      if (!verbs || !verbs.length) {
        container.textContent = "Loading suggestions...";
        return;
      }
      verbs.forEach((verb) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "example-btn power-verb-pill";
        btn.textContent = verb;
        btn.addEventListener("click", () => handlePowerVerbClick(verb, { feedbackEl, textarea }));
        container.appendChild(btn);
      });
    }

    function setCopiedBadge(el) {
      if (!el) return;
      el.classList.add("is-visible");
      if (el._timer) clearTimeout(el._timer);
      el._timer = setTimeout(() => el.classList.remove("is-visible"), 1400);
    }

    function selectionIsInsidePreview() {
      const sel = window.getSelection?.();
      if (!sel || sel.rangeCount === 0) return false;
      const range = sel.getRangeAt(0);
      if (!range || range.collapsed) return false;
      const node = range.commonAncestorContainer;
      const el = node.nodeType === 1 ? node : node.parentElement;
      return !!(el && markedPreview && markedPreview.contains(el));
    }

    function replaceSelectionInPreview(text) {
      if (!selectionIsInsidePreview()) return false;
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0) return false;
      const range = sel.getRangeAt(0);
      range.deleteContents();
      range.insertNode(document.createTextNode(text));

      sel.removeAllRanges();
      sel.addRange(range);

      if (markedPreview) markedPreview.normalize();
      return true;
    }

    function createPowerVerbCard(verb, onClick) {
      const card = document.createElement("button");
      card.type = "button";
      card.className = "power-verb-card";
      card.setAttribute("aria-label", `Use power verb: ${verb}`);

      const header = document.createElement("div");
      header.className = "power-verb-card-header";

      const title = document.createElement("div");
      title.className = "power-verb-card-verb";
      title.textContent = verb;

      const copied = document.createElement("div");
      copied.className = "power-verb-card-copied";
      copied.textContent = "Copied";

      header.appendChild(title);
      header.appendChild(copied);

      const def = document.createElement("div");
      def.className = "power-verb-card-def";
      def.textContent = getPowerVerbDefinition(verb) || "Definition coming soon.";
      def.title = def.textContent;

      card.appendChild(header);
      card.appendChild(def);

      card.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(verb);
        } catch (e) {
          console.warn("Clipboard failed:", e);
        }
        setCopiedBadge(copied);
        if (typeof onClick === "function") onClick(verb);
      });

      return card;
    }

    function renderPowerVerbCardList(container, verbs, onClick) {
      if (!container) return;
      container.innerHTML = "";

      (verbs || []).forEach((verb) => {
        container.appendChild(createPowerVerbCard(verb, onClick));
      });
    }

    function createPowerVerbsPage() {
      if (!powerVerbsList || !powerVerbsList.length) return [];

      const recentLower = new Set(
        (powerVerbsState.recentlyShown || []).map((v) => String(v).toLowerCase())
      );
      const page = samplePowerVerbs(POWER_VERBS_PAGE_COUNT, recentLower);

      powerVerbsState.recentlyShown = [...powerVerbsState.recentlyShown, ...page].slice(-40);
      return page;
    }

    function updatePowerVerbsPopoverNav() {
      if (!powerVerbsPopover.prevBtn || !powerVerbsPopover.nextBtn) return;
      powerVerbsPopover.prevBtn.style.display = powerVerbsState.pageIndex > 0 ? "inline-flex" : "none";
    }

    function renderPowerVerbsPopoverPage() {
      if (!powerVerbsPopover.grid) return;
      const page = powerVerbsState.pageHistory[powerVerbsState.pageIndex] || [];
      renderPowerVerbCardList(powerVerbsPopover.grid, page, (verb) => {
        const didReplace = replaceSelectionInPreview(verb);
        if (didReplace) {
          if (typeof refreshStudentMetrics === "function") refreshStudentMetrics();
          if (typeof updateWordCountFromPreviewDebounced === "function") {
            updateWordCountFromPreviewDebounced(0);
          }
        }
      });
      updatePowerVerbsPopoverNav();
    }

    function goToPowerVerbsPage(index) {
      if (index < 0) return;
      if (index >= powerVerbsState.pageHistory.length) {
        powerVerbsState.pageHistory.push(createPowerVerbsPage());
      }
      powerVerbsState.pageIndex = index;
      renderPowerVerbsPopoverPage();
    }

    function positionPowerVerbsPopover() {
      if (!powerVerbsPopover.el || !powerVerbsPopover.anchor) return;
      const gap = 8;
      const padding = 12;
      const anchorRect = powerVerbsPopover.anchor.getBoundingClientRect();

      powerVerbsPopover.el.style.display = "flex";
      powerVerbsPopover.el.style.visibility = "hidden";
      const popRect = powerVerbsPopover.el.getBoundingClientRect();
      const fitsBelow = anchorRect.bottom + gap + popRect.height <= window.innerHeight;

      let top = fitsBelow
        ? anchorRect.bottom + gap
        : anchorRect.top - popRect.height - gap;
      top = Math.max(padding, Math.min(top, window.innerHeight - popRect.height - padding));

      let left = anchorRect.right - popRect.width;
      left = Math.max(padding, Math.min(left, window.innerWidth - popRect.width - padding));

      powerVerbsPopover.el.style.top = `${Math.round(top)}px`;
      powerVerbsPopover.el.style.left = `${Math.round(left)}px`;
      powerVerbsPopover.el.style.visibility = "visible";
    }

    function attachPowerVerbsPopoverListeners() {
      if (powerVerbsPopover.onDocumentClick) return;
      powerVerbsPopover.onDocumentClick = (event) => {
        const target = event.target;
        if (powerVerbsPopover.el?.contains(target)) return;
        if (powerVerbsPopover.anchor?.contains(target)) return;
        closePowerVerbsPopover();
      };
      powerVerbsPopover.onKeyDown = (event) => {
        if (event.key === "Escape") closePowerVerbsPopover();
      };
      powerVerbsPopover.onReposition = () => {
        if (powerVerbsPopover.isOpen) positionPowerVerbsPopover();
      };
      document.addEventListener("mousedown", powerVerbsPopover.onDocumentClick, true);
      document.addEventListener("touchstart", powerVerbsPopover.onDocumentClick, true);
      document.addEventListener("keydown", powerVerbsPopover.onKeyDown, true);
      window.addEventListener("resize", powerVerbsPopover.onReposition);
      window.addEventListener("scroll", powerVerbsPopover.onReposition, true);
    }

    function detachPowerVerbsPopoverListeners() {
      if (!powerVerbsPopover.onDocumentClick) return;
      document.removeEventListener("mousedown", powerVerbsPopover.onDocumentClick, true);
      document.removeEventListener("touchstart", powerVerbsPopover.onDocumentClick, true);
      document.removeEventListener("keydown", powerVerbsPopover.onKeyDown, true);
      window.removeEventListener("resize", powerVerbsPopover.onReposition);
      window.removeEventListener("scroll", powerVerbsPopover.onReposition, true);
      powerVerbsPopover.onDocumentClick = null;
      powerVerbsPopover.onKeyDown = null;
      powerVerbsPopover.onReposition = null;
    }

    function ensurePowerVerbsPopover() {
      if (powerVerbsPopover.el) return;
      const popover = document.createElement("div");
      popover.className = "tour-popover power-verbs-popover";
      popover.style.display = "none";

      const header = document.createElement("div");
      header.className = "power-verbs-popover-header";

      const title = document.createElement("div");
      title.className = "power-verbs-popover-title";
      title.textContent = "Power Verbs";

      const closeBtn = document.createElement("button");
      closeBtn.type = "button";
      closeBtn.className = "power-verbs-popover-close";
      closeBtn.setAttribute("aria-label", "Close");
      closeBtn.textContent = "Ã—";
      closeBtn.addEventListener("click", () => closePowerVerbsPopover());

      header.appendChild(title);
      header.appendChild(closeBtn);

      const feedback = document.createElement("div");
      feedback.className = "power-verbs-feedback";
      feedback.setAttribute("aria-live", "polite");

      const grid = document.createElement("div");
      grid.className = "power-verbs-popover-grid";

      const footer = document.createElement("div");
      footer.className = "power-verbs-popover-footer";

      const prevBtn = document.createElement("button");
      prevBtn.type = "button";
      prevBtn.className = "example-btn";
      prevBtn.textContent = "â† Prev";
      prevBtn.style.display = "none";
      prevBtn.addEventListener("click", () => {
        goToPowerVerbsPage(powerVerbsState.pageIndex - 1);
      });

      const nextBtn = document.createElement("button");
      nextBtn.type = "button";
      nextBtn.className = "example-btn";
      nextBtn.textContent = "Next â†’";
      nextBtn.addEventListener("click", () => {
        goToPowerVerbsPage(powerVerbsState.pageIndex + 1);
      });

      footer.appendChild(prevBtn);
      footer.appendChild(nextBtn);

      popover.appendChild(header);
      popover.appendChild(feedback);
      popover.appendChild(grid);
      popover.appendChild(footer);

      document.body.appendChild(popover);

      powerVerbsPopover.el = popover;
      powerVerbsPopover.grid = grid;
      powerVerbsPopover.feedback = feedback;
      powerVerbsPopover.nextBtn = nextBtn;
      powerVerbsPopover.prevBtn = prevBtn;
      powerVerbsPopover.closeBtn = closeBtn;
    }

    function openPowerVerbsPopover(anchorEl, textarea) {
      ensurePowerVerbsPopover();
      powerVerbsPopover.anchor = anchorEl;
      powerVerbsPopover.textarea = textarea;
      powerVerbsPopover.isOpen = true;
      powerVerbsPopover.el.style.display = "flex";
      attachPowerVerbsPopoverListeners();

      loadPowerVerbsList().then(() => {
        // If verbs still not loaded, show a clear message in the grid
        if (!Array.isArray(powerVerbsList) || powerVerbsList.length === 0) {
          if (powerVerbsPopover.grid) {
            powerVerbsPopover.grid.innerHTML = "<div style='color: rgba(0,0,0,.6); font-weight:600;'>Power verbs list failed to load. Check power_verbs_2025.json path.</div>";
          }
          if (powerVerbsPopover.prevBtn) powerVerbsPopover.prevBtn.style.display = "none";
          return;
        }

        // Ensure we have a non-empty first page
        const currentPage = powerVerbsState.pageHistory[powerVerbsState.pageIndex] || [];
        const firstPage = powerVerbsState.pageHistory[0] || [];
        if (!powerVerbsState.pageHistory.length || currentPage.length === 0 || firstPage.length === 0) {
          powerVerbsState.pageHistory = [createPowerVerbsPage()];
          powerVerbsState.pageIndex = 0;
        }

        renderPowerVerbsPopoverPage();
        requestAnimationFrame(positionPowerVerbsPopover);
      });
    }

    function closePowerVerbsPopover() {
      if (!powerVerbsPopover.el || !powerVerbsPopover.isOpen) return;
      powerVerbsPopover.el.style.display = "none";
      powerVerbsPopover.isOpen = false;
      powerVerbsPopover.anchor = null;
      detachPowerVerbsPopoverListeners();
    }

    function refreshPowerVerbsHelper() {
      if (!activePowerVerbsHelper || !activePowerVerbsHelper.isConnected) return;
      const list = activePowerVerbsHelper.querySelector("[data-power-verbs-list]");
      const textarea = activePowerVerbsHelper._textarea;
      ensureInitialPowerVerbs(powerVerbsState.label || currentLabelText || currentLabel || "");
      renderPowerVerbCardList(list, powerVerbsState.initialVerbs, (verb) => {
        const didReplace = replaceSelectionInTextarea(textarea, verb);
        if (didReplace) {
          if (typeof refreshStudentMetrics === "function") refreshStudentMetrics();
          if (typeof updateWordCountFromPreviewDebounced === "function") {
            updateWordCountFromPreviewDebounced(0);
          }
        }
      });
    }

    function buildPowerVerbsHelper(label, rewriteTextarea) {
      if (!isAvoidWeakVerbsLabel(label)) return null;
      const helper = document.createElement("div");
      helper.className = "power-verbs-helper";
      helper._textarea = rewriteTextarea;

      const header = document.createElement("div");
      header.className = "power-verbs-header";

      const title = document.createElement("div");
      title.className = "power-verbs-title";
      title.textContent = "Do any of these work?";

      header.appendChild(title);

      const suggestionsRow = document.createElement("div");
      suggestionsRow.className = "power-verbs-suggestions-row";

      const list = document.createElement("div");
      list.className = "power-verbs-suggestions-list";
      list.dataset.powerVerbsList = "1";

      const shuffleBtn = document.createElement("button");
      shuffleBtn.type = "button";
      shuffleBtn.className = "power-verbs-shuffle-btn";
      shuffleBtn.setAttribute("aria-label", "Shuffle power verb suggestions");
      shuffleBtn.title = "Shuffle choices";
      shuffleBtn.textContent = "âŸ³";

      function refreshSuggestions() {
        const verbs = samplePowerVerbs(POWER_VERBS_INITIAL_COUNT);
        powerVerbsState.initialVerbs = verbs;
        storePowerVerbs(label, verbs);

        renderPowerVerbCardList(list, verbs, (verb) => {
          const didReplace = replaceSelectionInTextarea(rewriteTextarea, verb);
          if (didReplace) {
            if (typeof refreshStudentMetrics === "function") refreshStudentMetrics();
            if (typeof updateWordCountFromPreviewDebounced === "function") {
              updateWordCountFromPreviewDebounced(0);
            }
          }
        });
      }

      shuffleBtn.addEventListener("click", refreshSuggestions);

      suggestionsRow.appendChild(list);
      suggestionsRow.appendChild(shuffleBtn);

      helper.appendChild(header);
      helper.appendChild(suggestionsRow);

      activePowerVerbsHelper = helper;

      refreshSuggestions();

      if (!powerVerbsState.initialVerbs.length) {
        loadPowerVerbsList().then(() => {
          if (helper.isConnected) {
            refreshSuggestions();
          }
        });
      }

      return helper;
    }

    function handlePowerVerbsIssueChange(label) {
      if (!isAvoidWeakVerbsLabel(label)) {
        powerVerbsState.label = null;
        powerVerbsState.initialVerbs = [];
        powerVerbsState.pageHistory = [];
        powerVerbsState.pageIndex = 0;
        powerVerbsState.recentlyShown = [];
        closePowerVerbsPopover();
        return;
      }
      if (powerVerbsState.label !== label) {
        powerVerbsState.label = label;
        powerVerbsState.initialVerbs = [];
        powerVerbsState.pageHistory = [];
        powerVerbsState.pageIndex = 0;
        powerVerbsState.recentlyShown = [];
        closePowerVerbsPopover();
      }
      loadPowerVerbsList().then(() => {
        if (!isAvoidWeakVerbsLabel(powerVerbsState.label)) return;
        ensureInitialPowerVerbs(powerVerbsState.label);
        refreshPowerVerbsHelper();
      });
    }

    function getPreviewOnlyMessage(label, fallbackMessage) {
      if (isPreviewOnlyLabel(label)) {
        return "Looks like you need to revise your topic sentence. Repair this issue in the Preview";
      }
      return fallbackMessage;
    }

    function currentDismissStorageKey() {
      return `vysti_dismissed__${getLocalRunKey()}`;
    }

    function loadDismissedIssuesFromStorage() {
      const key = currentDismissStorageKey();
      try {
        const raw = localStorage.getItem(key);
        if (!raw) {
          dismissedIssues = [];
          return;
        }
        const parsed = JSON.parse(raw);
        dismissedIssues = Array.isArray(parsed) ? parsed : [];
      } catch (error) {
        console.warn("Failed to load dismissed issues:", error);
        dismissedIssues = [];
      }
    }

    function saveDismissedIssuesToStorage() {
      const key = currentDismissStorageKey();
      try {
        localStorage.setItem(key, JSON.stringify(dismissedIssues || []));
      } catch (error) {
        console.warn("Failed to save dismissed issues:", error);
      }
    }

    function getAppliedStorageKey(label, exampleKey) {
      if (!exampleKey) return "";
      const safeLabel = String(label || "nolabel").trim();
      const labelKey = normalizeIssueId(safeLabel);
      return `vysti_applied__${getLocalRunKey()}__${labelKey}__${exampleKey}`;
    }

    function loadAppliedFlag(label, exampleKey) {
      const key = getAppliedStorageKey(label, exampleKey);
      if (!key) return false;
      try {
        return localStorage.getItem(key) === "1";
      } catch (error) {
        console.warn("Failed to load applied flag:", error);
        return false;
      }
    }

    function saveAppliedFlag(label, exampleKey, value) {
      const key = getAppliedStorageKey(label, exampleKey);
      if (!key) return;
      try {
        if (value) {
          localStorage.setItem(key, "1");
        } else {
          localStorage.removeItem(key);
        }
      } catch (error) {
        console.warn("Failed to save applied flag:", error);
      }
    }

    function normalizeLabelForMatch(label) {
      return normalizeForMatch(String(label || "")).toLowerCase();
    }

    function canonicalLabel(label) {
      return normalizeLabelForMatch(label);
    }

    function isDismissedIssueInstance(label, sentence) {
      if (!label || !sentence || !selectedFile) return false;
      const labelMatch = normalizeLabelForMatch(label);
      const sentenceMatch = normalizeForMatch(sentence);
      return dismissedIssues.some((record) => {
        if (record?.file_name !== selectedFile.name) return false;
        return (
          normalizeLabelForMatch(record?.label) === labelMatch &&
          normalizeForMatch(record?.sentence) === sentenceMatch
        );
      });
    }

    loadDismissedIssuesFromStorage();

    function updateIssueMetadataForLabel(label) {
      const issues = currentMarkEvent?.issues || [];
      const issueData = issues.find((iss) => normLabel(iss?.label) === normLabel(label));
      if (issueData && issueData.explanation) {
        issueExplanation.textContent = issueData.explanation;
        if (issueExplanationBlock) issueExplanationBlock.style.display = "block";
      } else if (issueExplanationBlock) {
        issueExplanationBlock.style.display = "none";
      }
      currentGuidance = issueData?.student_guidance || "";
      currentLabelText = (issueData?.label || label || "").trim();
      return issueData || null;
    }

    function getExampleKeyFromParts(paragraphIndex, sentence) {
      const safePara = String(paragraphIndex ?? 0);
      const safeSentence = String(sentence || "").trim();
      return `${safePara}::${safeSentence}`;
    }

    function getExampleKey(ex) {
      if (!ex) return "";
      const sentence = ex.original_sentence || ex.sentence || "";
      return getExampleKeyFromParts(ex.paragraph_index ?? 0, sentence);
    }

    // Loading indicator style for the main "Mark my essay" button.
    // - true: "Processing |" (blinking cursor)
    // - false: "Processing..." (animated dots)
    const USE_CURSOR_PROMPT_LOADING = true;

    function startButtonLoading(btn, fallbackLabel) {
      if (!btn) return;
      if (!btn.dataset.baseLabel) {
        const label = (btn.textContent || fallbackLabel || "").trim();
        if (label) btn.dataset.baseLabel = label;
      }

      // visually + accessibility
      btn.classList.add("is-loading");
      btn.classList.remove("loading-cursor");
      btn.setAttribute("aria-busy", "true");
      btn.disabled = true;

      // Cursor prompt mode (preferred)
      if (USE_CURSOR_PROMPT_LOADING) {
        // No interval needed; CSS handles the blink.
        btn.classList.add("loading-cursor");
        btn.textContent = "Processing";
        return;
      }

      let dots = 0;
      const tick = () => {
        dots = (dots + 1) % 4; // 0..3
        const suffix = ".".repeat(dots);
        btn.textContent = `Processing${suffix}`;
      };

      tick();
      const timer = window.setInterval(tick, 450);
      buttonLoadingTimers.set(btn, timer);
    }

    function stopButtonLoading(btn, enableWhenDone) {
      if (!btn) return;

      const timer = buttonLoadingTimers.get(btn);
      if (timer) {
        window.clearInterval(timer);
        buttonLoadingTimers.delete(btn);
      }

      btn.classList.remove("is-loading");
      btn.classList.remove("loading-cursor");
      btn.removeAttribute("aria-busy");

      if (btn.dataset.baseLabel) btn.textContent = btn.dataset.baseLabel;

      const shouldEnable = typeof enableWhenDone === "function"
        ? enableWhenDone()
        : !!enableWhenDone;
      btn.disabled = !shouldEnable;
    }

    function applyPreviewZoom() {
      if (!markedPreview || !previewZoom) return;
      markedPreview.style.zoom = previewZoom.value || "1";
    }

    if (previewZoom) {
      previewZoom.addEventListener("change", applyPreviewZoom);
    }

    if (markedPreview) {
      markedPreview.addEventListener("input", () => {
        hasStartedRevising = true;
        updateWordCountFromPreviewDebounced(350);
      }, true);
    }

    function buildMarkFormData({ includeSummaryTable = false } = {}) {
      if (!selectedFile) return null;

      const mode = document.getElementById("mode").value;
      const assignmentName = document.getElementById("assignmentName").value.trim();

      const formData = new FormData();
      formData.append("file", selectedFile);
      formData.append("mode", mode);
      formData.append("include_summary_table", includeSummaryTable ? "true" : "false");
      // Student mode: never highlight thesis devices/strategies
      formData.append("highlight_thesis_devices", "false");
      formData.append("student_mode", "true");

      if (assignmentName) {
        formData.append("assignment_name", assignmentName);
      }

      if (detectedWork && detectedWork.confidence === "high") {
        formData.append("author", detectedWork.author);
        formData.append("title", detectedWork.title);
        formData.append("text_is_minor_work", detectedWork.isMinor ? "true" : "false");
      }

      return formData;
    }

    // ===== Mode explainer card =====
    const MODE_RULE_DEFAULTS = {
      textual_analysis: {
        description: "A formal and academic essay of analysis with all Vysti Rules running.",
        details: [
          "No first-person allowed or personal pronouns",
          "First sentence should state the author, genre, title, and summary.",
          "Requires a closed thesis statement.",
          "Requires quoted evidence in body paragraphs.",
          "Strict requirements on organization, evidence, and language.",
          "Aqua-blue highlights repetitive 'and', weak verbs, and unclarified antecedents",
          "Red strikethroughs forbidden terms."
        ]
      },
      peel_paragraph: {
        description: "One focused analytical paragraph following the Vysti Rules.",
        details: [
          "The first sentence should state the author, genre, title, and summary.",
          "The first sentence should include devices and/or strategies like a closed thesis",
          "No first-person allowed or personal pronouns",
          "Requires quoted evidence in the body of the paragraph.",
          "Strict requirements on organization, evidence, and language.",
          "Aqua-blue highlights repetitive 'and', weak verbs, and unclarified antecedents",
          "Red strikethroughs forbidden terms."
        ]
      },
      reader_response: {
        description: "More personal voice allowed, but still needs argument + evidence.",
        details: [
          "Allows first-person and personal pronouns",
          "Allows contractions and 'which'",
          "First sentence should state the author, genre, title, and summary.",
          "Requires a closed thesis statement.",
          "Requires quoted evidence in body paragraphs.",
          "Strict requirements on organization, evidence, and language.",
          "Aqua-blue highlights repetitive 'and', weak verbs, and unclarified antecedents",
          "Red strikethroughs forbidden terms."
        ]
      },
      argumentation: {
        description: "Argumentation is more open mode beyond textual analysis.",
        details: [
          "Allows for past tense.",
          "Allows first-person and personal pronouns",
          "Aqua-blue highlights repetitive 'and', weak verbs, and unclarified antecedents",
          "Red strikethroughs forbidden terms.",
        ]
      }
    };

    // Mode explainer elements
    const modeBadge = document.getElementById("modeBadge");
    const modeTagEl = document.getElementById("modeTag");
    const modeDesc = document.getElementById("modeDesc");
    const modeMoreBtn = document.getElementById("modeMoreBtn");
    const modeDetails = document.getElementById("modeDetails");
    const modeDetailsList = document.getElementById("modeDetailsList");

    function setModeExplainer(mode) {
      const cfg = MODE_RULE_DEFAULTS[mode] || MODE_RULE_DEFAULTS.textual_analysis;
      const label = modeSelect.options[modeSelect.selectedIndex]?.textContent || mode;

      if (modeBadge) modeBadge.textContent = label;
      if (modeTagEl) modeTagEl.textContent = cfg.tag || "";
      if (modeDesc) modeDesc.textContent = cfg.description || "";

      if (modeDetailsList) {
        modeDetailsList.innerHTML = "";
        (cfg.details || []).forEach((item) => {
          const li = document.createElement("li");
          li.textContent = item;
          modeDetailsList.appendChild(li);
        });
      }

      const hasDetails = Array.isArray(cfg.details) && cfg.details.length > 0;
      if (modeMoreBtn) modeMoreBtn.hidden = !hasDetails;

      if (modeMoreBtn && modeDetails) {
        modeMoreBtn.setAttribute("aria-expanded", "false");
        modeDetails.hidden = true;
        modeMoreBtn.textContent = "Want more details?";
      }
    }

    // Expand / collapse once
    if (modeMoreBtn && modeDetails) {
      modeMoreBtn.addEventListener("click", () => {
        const expanded = modeMoreBtn.getAttribute("aria-expanded") === "true";
        modeMoreBtn.setAttribute("aria-expanded", String(!expanded));
        modeDetails.hidden = expanded;
        modeMoreBtn.textContent = expanded ? "Want more details?" : "Hide details";
      });
    }

    // Initialize mode explainer
    if (modeSelect) {
      setModeExplainer(modeSelect.value);
      modeSelect.addEventListener("change", () => {
        setModeExplainer(modeSelect.value);
        updateStatsPanel(liveLabelCounts);
        if (lastStudentMetrics) {
          renderMetrics(lastStudentMetrics);
        }
      });
    }

    // ===== Student helpers tour flags =====
    const FORCE_STUDENT_HELPERS = false;
    const TOUR_HIDE_KEY = "vysti_student_tour_hide";
    const TOUR_DONE_KEY = "vysti_student_tour_completed";
    const STUDENT_HELPERS_DISABLED_KEY = "vysti_student_helpers_disabled";

    function shouldShowStudentHelpers() {
      if (FORCE_STUDENT_HELPERS) return true;
      const disabled = localStorage.getItem(STUDENT_HELPERS_DISABLED_KEY);
      const completed = localStorage.getItem(TOUR_DONE_KEY);
      const legacyHidden = localStorage.getItem(TOUR_HIDE_KEY);
      return !disabled && !completed && !legacyHidden;
    }

    // ===== Auth + role guard =====
    let studentHelpersStartedThisLoad = false;
    async function refreshAuthUI() {
      const { data } = await supa.auth.getSession();
      const session = data.session;

      if (!session) {
        window.location.replace("/signin.html");
        return;
      }

      // Set role to student on successful auth guard
      localStorage.setItem("vysti_role", "student");

      // Logged in as student
      form.style.display = "grid";

      if (!studentHelpersStartedThisLoad && shouldShowStudentHelpers()) {
        studentHelpersStartedThisLoad = true;

        // Make sure layout is ready before positioning the helper window arrows
        requestAnimationFrame(() => {
          setTimeout(() => {
            startTour({ force: FORCE_STUDENT_HELPERS });
          }, 50);
        });
      }
    }

    // Initial auth check
    refreshAuthUI();
    supa.auth.onAuthStateChange((_event, _session) => {
      refreshAuthUI();
    });

    // ===== Progress handler =====
    const progressBtn = document.getElementById("progressBtn");
    if (progressBtn) {
      progressBtn.addEventListener("click", () => {
        window.location.href = "/student_progress.html";
      });
    }

    // ===== Switch mode handler =====
    const switchModeBtn = document.getElementById("switchModeBtn");
    if (switchModeBtn) {
      switchModeBtn.addEventListener("click", () => {
        localStorage.setItem("vysti_role", "teacher");
        window.location.href = "/index.html";
      });
    }

    // ===== Logout handler =====
    const logoutBtn = document.getElementById("logoutBtn");
    logoutBtn.addEventListener("click", async () => {
      await supa.auth.signOut();
      localStorage.removeItem("vysti_role");
      window.location.replace("/signin.html");
    });

    const repeatTutorialBtn = document.getElementById("repeatTutorialBtn");
    if (repeatTutorialBtn) {
      repeatTutorialBtn.addEventListener("click", () => {
        clearStudentHelperSuppression();
        if (tourState.active) {
          closeTour("dismissed");
        }
        startTourForCurrentState({ force: true });
      });
    }

    let repeatTutorialPopover = null;
    let repeatTutorialPopoverVisible = false;

    function ensureRepeatTutorialPopover() {
      if (repeatTutorialPopover) return repeatTutorialPopover;
      repeatTutorialPopover = document.createElement("div");
      repeatTutorialPopover.className = "repeat-tutorial-popover";
      repeatTutorialPopover.setAttribute("role", "tooltip");
      repeatTutorialPopover.style.display = "none";
      document.body.appendChild(repeatTutorialPopover);
      return repeatTutorialPopover;
    }

    function positionRepeatTutorialPopover() {
      if (!repeatTutorialBtn || !repeatTutorialPopover) return;
      const pad = 12;
      const rect = repeatTutorialBtn.getBoundingClientRect();

      repeatTutorialPopover.style.position = "fixed";

      let left = rect.right - repeatTutorialPopover.offsetWidth;
      let top = rect.bottom + 8;

      left = Math.max(pad, Math.min(left, window.innerWidth - repeatTutorialPopover.offsetWidth - pad));

      if (top + repeatTutorialPopover.offsetHeight > window.innerHeight - pad) {
        top = rect.top - repeatTutorialPopover.offsetHeight - 8;
      }
      top = Math.max(pad, Math.min(top, window.innerHeight - repeatTutorialPopover.offsetHeight - pad));

      repeatTutorialPopover.style.left = `${Math.round(left)}px`;
      repeatTutorialPopover.style.top = `${Math.round(top)}px`;
    }

    function showRepeatTutorialPopover() {
      if (!repeatTutorialBtn) return;
      const popover = ensureRepeatTutorialPopover();
      popover.textContent = repeatTutorialBtn.dataset.tip || "Repeat the tutorial";
      popover.style.display = "block";
      popover.style.visibility = "hidden";
      positionRepeatTutorialPopover();
      popover.style.visibility = "visible";
      repeatTutorialPopoverVisible = true;
    }

    function hideRepeatTutorialPopover() {
      if (!repeatTutorialPopover) return;
      repeatTutorialPopover.style.display = "none";
      repeatTutorialPopoverVisible = false;
    }

    function handleRepeatTutorialPopoverPosition() {
      if (!repeatTutorialPopoverVisible) return;
      positionRepeatTutorialPopover();
    }

    if (repeatTutorialBtn) {
      repeatTutorialBtn.addEventListener("mouseenter", showRepeatTutorialPopover);
      repeatTutorialBtn.addEventListener("focus", showRepeatTutorialPopover);
      repeatTutorialBtn.addEventListener("mouseleave", hideRepeatTutorialPopover);
      repeatTutorialBtn.addEventListener("blur", hideRepeatTutorialPopover);
      window.addEventListener("resize", handleRepeatTutorialPopoverPosition, { passive: true });
      window.addEventListener("scroll", handleRepeatTutorialPopoverPosition, true);
    }

    function handleAssignmentNameFocus() {
      if (!assignmentNameInput) return;
      if (!assignmentNameInput.value.trim()) {
        assignmentNameInput.value = "Assignment 01";
        requestAnimationFrame(() => assignmentNameInput.select());
      }
    }

    if (assignmentNameInput) {
      assignmentNameInput.addEventListener("focus", handleAssignmentNameFocus);
      assignmentNameInput.addEventListener("click", handleAssignmentNameFocus);
    }

    // ===== File handling (single file only) =====
    function updateFileUI() {
      fileList.innerHTML = "";
      clearFileBtn.style.display = "none";
      
      if (selectedFile) {
        const li = document.createElement("li");
        li.textContent = selectedFile.name;
        fileList.appendChild(li);
        clearFileBtn.style.display = "block";
        checkBtn.disabled = false;
      } else {
        checkBtn.disabled = true;
      }
    }

    function totalIssuesFromLabelCounts(labelCounts) {
      if (!labelCounts || typeof labelCounts !== "object") return 0;
      return Object.values(labelCounts).reduce((sum, v) => sum + (Number(v) || 0), 0);
    }

    function updateStatsPanel(labelCounts) {
      if (!statsPanel) return;
      const counts = labelCounts && typeof labelCounts === "object" ? labelCounts : {};
      const totalIssues = totalIssuesFromLabelCounts(counts);

      if (wordCountStat) {
        wordCountStat.textContent = (currentWordCount === null || currentWordCount === undefined)
          ? "â€”"
          : String(currentWordCount);
      }
      if (totalIssuesStat) {
        totalIssuesStat.textContent = String(totalIssues);
      }

      const entries = Object.entries(counts)
        .filter(([label, count]) => label && (Number(count) || 0) > 0)
        .sort((a, b) => {
          const diff = (Number(b[1]) || 0) - (Number(a[1]) || 0);
          if (diff !== 0) return diff;
          return String(a[0]).localeCompare(String(b[0]));
        });

      if (topIssueRow && topIssueStat) {
        if (entries.length > 0) {
          const [label, count] = entries[0];
          topIssueStat.textContent = `${label} (${count})`;
          topIssueRow.style.display = "flex";
        } else {
          topIssueRow.style.display = "none";
          topIssueStat.textContent = "";
        }
      }

      if (!techniquesStatWrap || !techniquesStatList) return;
      const mode = modeSelect ? modeSelect.value : "";
      if (mode === "argumentation") {
        techniquesStatWrap.style.display = "none";
        techniquesStatList.textContent = "";
        return;
      }

      if (!Array.isArray(currentTechniques) || currentTechniques.length === 0) {
        techniquesStatWrap.style.display = "none";
        techniquesStatList.textContent = "";
        return;
      }

      const sorted = currentTechniques
        .filter((item) => item && item.name && (Number(item.count) || 0) > 0)
        .slice()
        .sort((a, b) => {
          const countDiff = (Number(b?.count) || 0) - (Number(a?.count) || 0);
          if (countDiff !== 0) return countDiff;
          const nameA = String(a?.name || "");
          const nameB = String(b?.name || "");
          return nameA.localeCompare(nameB);
        });

      if (sorted.length === 0) {
        techniquesStatWrap.style.display = "none";
        techniquesStatList.textContent = "";
        return;
      }

      const maxItems = 6;
      techniquesStatList.innerHTML = "";
      sorted.slice(0, maxItems).forEach((item) => {
        const row = document.createElement("div");
        row.textContent = `${item.name} (${item.count})`;
        techniquesStatList.appendChild(row);
      });
      const remaining = sorted.length - maxItems;
      if (remaining > 0) {
        const moreRow = document.createElement("div");
        moreRow.textContent = `+ ${remaining} more`;
        techniquesStatList.appendChild(moreRow);
      }
      techniquesStatWrap.style.display = "block";
    }

    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    function clamp01(x) {
      const n = Number(x);
      if (!Number.isFinite(n)) return 0;
      return Math.max(0, Math.min(1, n));
    }

    function renderSuccess(subEl, message) {
      if (!subEl) return;
      subEl.innerHTML = "";
      const row = document.createElement("div");
      row.className = "metric-success";
      row.innerHTML = `<span class="star">â˜…</span><span>${message}</span>`;
      subEl.appendChild(row);
    }

    function renderPowerDots(subEl, powerMetric) {
      if (!subEl) return;
      if (!powerMetric || typeof powerMetric.score !== "number") {
        subEl.textContent = "";
        return;
      }

      if (powerMetric.score === 100) {
        renderSuccess(subEl, "Verbs at full strength.");
        return;
      }

      const d = powerMetric.details || {};
      const weakCount = Number(d.weakCount) || 0;
      const powerCount = Number(d.powerCount) || 0;
      const powerTarget = Number(d.powerTarget) || 0;

      subEl.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.className = "power-quests";

      if (weakCount > 0) {
        const row = document.createElement("div");
        row.className = "quest-row";

        const pill = document.createElement("button");
        pill.type = "button";
        pill.className = "quest-pill weak quest-pill-btn";
        pill.textContent = "Weak verbs remaining";
        pill.title = "Click to revise weak verbs";
        pill.addEventListener("click", () => {
          const issueId = getIssueIdForLabel("Avoid weak verbs");
          openRevisionExampleFromIssueId(issueId, "Avoid weak verbs");
        });

        const dots = document.createElement("div");
        dots.className = "quest-dots";

        const maxDots = 10;
        const showDots = Math.min(weakCount, maxDots);
        for (let i = 0; i < showDots; i += 1) {
          const dot = document.createElement("span");
          dot.className = "quest-dot bad";
          dots.appendChild(dot);
        }
        if (weakCount > maxDots) {
          const more = document.createElement("span");
          more.className = "quest-more";
          more.textContent = `+${weakCount - maxDots}`;
          dots.appendChild(more);
        }

        row.appendChild(pill);
        row.appendChild(dots);
        wrap.appendChild(row);
      }

      if (powerTarget > 0 && powerCount < powerTarget) {
        const row = document.createElement("div");
        row.className = "quest-row";

        const pill = document.createElement("button");
        pill.type = "button";
        pill.className = "quest-pill power quest-pill-btn";
        pill.textContent = "Power verbs needed";
        pill.title = "Jump to a verb to upgrade";
        pill.addEventListener("click", () => {
          // Ensure preview is in view
          scrollToPreviewHeader();

          // Try to highlight the next best upgrade target
          void jumpToNextVerbToUpgradeInPreview();
        });

        const dots = document.createElement("div");
        dots.className = "quest-dots";

        const maxDots = Math.min(powerTarget, 10);
        const filled = Math.min(powerCount, maxDots);
        for (let i = 0; i < maxDots; i += 1) {
          const dot = document.createElement("span");
          dot.className = `quest-dot ${i < filled ? "good" : "empty"}`;
          dots.appendChild(dot);
        }
        if (powerTarget > 10) {
          const more = document.createElement("span");
          more.className = "quest-more";
          more.textContent = `+${powerTarget - 10}`;
          dots.appendChild(more);
        }

        row.appendChild(pill);
        row.appendChild(dots);
        wrap.appendChild(row);
      }

      subEl.appendChild(wrap);
    }

    function updateCohesionIssueCache(details, sourceText) {
      const paragraphIssues = Array.isArray(details?.issues?.paragraphBoundaryMisses)
        ? details.issues.paragraphBoundaryMisses
        : [];
      const sentenceIssues = Array.isArray(details?.issues?.sentenceBoundaryMisses)
        ? details.issues.sentenceBoundaryMisses
        : [];
      const weakIssues = Array.isArray(details?.issues?.weakTransitions)
        ? details.issues.weakTransitions
        : [];

      const nextSource = String(sourceText || "");
      if (nextSource && nextSource !== lastCohesionSource) {
        cohesionJumpIndex = { paragraph: 0, sentence: 0, weak: 0 };
        lastCohesionSource = nextSource;
      } else if (!nextSource && lastCohesionSource) {
        lastCohesionSource = "";
      }

      cohesionIssueCache = {
        paragraph: paragraphIssues,
        sentence: sentenceIssues,
        weak: weakIssues
      };

      ["paragraph", "sentence", "weak"].forEach((key) => {
        if (cohesionJumpIndex[key] >= cohesionIssueCache[key].length) {
          cohesionJumpIndex[key] = 0;
        }
      });
    }

    function jumpToNextCohesionIssue(kind) {
      const list = cohesionIssueCache?.[kind] || [];
      if (!list.length) return false;
      const idx = cohesionJumpIndex[kind] % list.length;
      const issue = list[idx];
      cohesionJumpIndex[kind] = (idx + 1) % list.length;
      if (!issue?.sentence) return false;

      scrollToPreviewHeader();
      const result = highlightAndScrollToExample(issue, null, { scroll: true });
      if (result?.hits?.length) {
        result.hits.forEach((span) => span.classList.add("vysti-cursor-highlight"));
      }
      return result?.ok;
    }

    function renderCohesionQuests(subEl, cohesionMetric) {
      if (!subEl) return;
      if (!cohesionMetric || typeof cohesionMetric.score !== "number") {
        subEl.textContent = "";
        return;
      }

      const details = cohesionMetric.details || {};
      const issues = details.issues || {};
      const paragraphCount = Array.isArray(issues.paragraphBoundaryMisses)
        ? issues.paragraphBoundaryMisses.length
        : 0;
      const sentenceCount = Array.isArray(issues.sentenceBoundaryMisses)
        ? issues.sentenceBoundaryMisses.length
        : 0;
      const weakCount = Array.isArray(issues.weakTransitions)
        ? issues.weakTransitions.length
        : 0;

      subEl.innerHTML = "";
      const subLine = document.createElement("div");
      subLine.textContent = cohesionMetric.sub || "";
      subEl.appendChild(subLine);

      const wrap = document.createElement("div");
      wrap.className = "power-quests";

      const row = document.createElement("div");
      row.className = "quest-row pill-row";

      const makePill = (label, count, key) => {
        const pill = document.createElement("button");
        pill.type = "button";
        pill.className = "quest-pill quest-pill-btn";
        pill.textContent = `${label} (${count})`;
        if (count === 0) {
          pill.disabled = true;
          pill.title = "No issues found";
        } else {
          pill.title = "Click to jump to the next sentence";
          pill.addEventListener("click", () => {
            jumpToNextCohesionIssue(key);
          });
        }
        return pill;
      };

      row.appendChild(makePill("Between paragraphs", paragraphCount, "paragraph"));
      row.appendChild(makePill("Between sentences", sentenceCount, "sentence"));
      row.appendChild(makePill("Weak transitions", weakCount, "weak"));

      wrap.appendChild(row);
      subEl.appendChild(wrap);
    }

    function renderPowerDotsPopover(containerEl, powerMetric) {
      if (!containerEl) return;
      containerEl.innerHTML = "";

      if (!powerMetric || typeof powerMetric.score !== "number") return;

      const d = powerMetric.details || {};
      const weakCount = Number(d.weakCount) || 0;
      const powerCount = Number(d.powerCount) || 0;
      const powerTarget = Number(d.powerTarget) || 0;

      const wrap = document.createElement("div");
      wrap.className = "power-quests";

      if (weakCount > 0) {
        const row = document.createElement("div");
        row.className = "quest-row";

        const pill = document.createElement("button");
        pill.type = "button";
        pill.className = "quest-pill weak quest-pill-btn";
        pill.textContent = "Weak verbs remaining";
        pill.title = "Click to revise weak verbs";
        pill.addEventListener("click", () => {
          const issueId = getIssueIdForLabel("Avoid weak verbs");
          openRevisionExampleFromIssueId(issueId, "Avoid weak verbs");
        });

        const dots = document.createElement("div");
        dots.className = "quest-dots";

        const maxDots = 10;
        const showDots = Math.min(weakCount, maxDots);
        for (let i = 0; i < showDots; i += 1) {
          const dot = document.createElement("span");
          dot.className = "quest-dot bad";
          dots.appendChild(dot);
        }
        if (weakCount > maxDots) {
          const more = document.createElement("span");
          more.className = "quest-more";
          more.textContent = `+${weakCount - maxDots}`;
          dots.appendChild(more);
        }

        row.appendChild(pill);
        row.appendChild(dots);
        wrap.appendChild(row);
      }

      if (powerTarget > 0) {
        const row = document.createElement("div");
        row.className = "quest-row";

        const pill = document.createElement("div");
        pill.className = "quest-pill power";
        pill.textContent = "Power verbs completed";

        const dots = document.createElement("div");
        dots.className = "quest-dots";

        const maxDots = Math.min(powerTarget, 10);
        const filled = Math.min(powerCount, maxDots);
        for (let i = 0; i < maxDots; i += 1) {
          const dot = document.createElement("span");
          dot.className = `quest-dot ${i < filled ? "good" : "empty"}`;
          dots.appendChild(dot);
        }
        if (powerTarget > 10) {
          const more = document.createElement("span");
          more.className = "quest-more";
          more.textContent = `+${powerTarget - 10}`;
          dots.appendChild(more);
        }

        row.appendChild(pill);
        row.appendChild(dots);
        wrap.appendChild(row);
      }

      containerEl.appendChild(wrap);
    }

    function stripQuotedText(s) {
      return String(s || "").replace(/"[^"]*"/g, " ");
    }

    function tokenizeWords(s) {
      return String(s || "").toLowerCase().match(/[a-z']+/g) || [];
    }

    function isTheUseOf(tokens, i) {
      if (!tokens || i <= 0 || i >= tokens.length - 1) return false;
      return tokens[i] === "use" && tokens[i - 1] === "the" && tokens[i + 1] === "of";
    }

    function countRegexMatches(text, regex) {
      const matches = String(text || "").match(regex);
      return matches ? matches.length : 0;
    }

    function splitSentencesSimple(s) {
      return String(s || "")
        .replace(/\s+/g, " ")
        .split(/(?<=[.!?])\s+/)
        .map((x) => x.trim())
        .filter(Boolean);
    }

    function splitParagraphsSimple(s) {
      const text = String(s || "").replace(/\r\n/g, "\n");
      const hasBlankLine = /\n\s*\n/.test(text);
      const parts = hasBlankLine
        ? text.split(/\n\s*\n+/)
        : text.split(/\n+/);
      return parts.map((p) => p.trim()).filter(Boolean);
    }

    const WEAK_VERB_GROUPS = {
      show: ["show","shows","showed","showing"],
      use:  ["use","uses","used","using"],
      make: ["make","makes","made","making"],
      do:   ["do","does","did","doing"],
      get:  ["get","gets","got","getting"],
      have: ["have","has","had","having"]
    };

    const WEAK_VERB_FORM_TO_BASE = (() => {
      const m = new Map();
      Object.entries(WEAK_VERB_GROUPS).forEach(([base, forms]) => {
        forms.forEach((f) => m.set(f, base));
      });
      return m;
    })();

    const WEAK_VERBS = new Set(Array.from(WEAK_VERB_FORM_TO_BASE.keys()));

    const PRONOUN_STARTERS = new Set([
      "this","it","they","he","she","we","i","you"
    ]);

    const SENTENCE_STARTER_SKIPS = new Set([
      "however","moreover","furthermore","additionally","therefore","thus",
      "consequently","nevertheless","nonetheless","meanwhile"
    ]);

    const TRANSITIONS = [
      // Clarification / restatement
      "to put it simply",
      "to put it another way",
      "to put it differently",
      "to say it another way",
      "in other words",
      "that is to say",
      "that is",
      "to be clear",
      "to clarify",
      "simply put",
      "put differently",
      "put another way",
      "stated differently",
      "in simple terms",
      "in essence",
      "to rephrase",
      "to restate",
      "in a word",
      "more precisely",

      // Contrast / concession
      "on the other hand",
      "on the one hand",
      "by contrast",
      "in contrast",
      "in comparison",
      "conversely",
      "on the contrary",
      "even so",
      "all the same",
      "that said",
      "having said that",
      "in spite of this",
      "despite this",
      "nevertheless",
      "nonetheless",
      "however",
      "still",
      "yet",
      "instead",
      "rather",
      "otherwise",
      "alternatively",

      // Addition
      "in addition",
      "in addition to this",
      "additionally",
      "furthermore",
      "moreover",
      "also",
      "likewise",
      "similarly",
      "by the same token",
      "in the same way",
      "what's more",
      "another key point",
      "besides this",
      "not only that",

      // Cause / effect
      "as a result",
      "as a consequence",
      "in consequence",
      "for this reason",
      "for that reason",
      "because of this",
      "accordingly",
      "consequently",
      "therefore",
      "thus",
      "hence",

      // Example / specificity
      "for example",
      "for instance",
      "to illustrate",
      "to demonstrate",
      "specifically",
      "in particular",
      "more specifically",
      "namely",

      // Emphasis
      "as a matter of fact",
      "in fact",
      "indeed",
      "of course",
      "certainly",
      "to be sure",
      "most importantly",
      "more importantly",
      "above all",
      "notably",

      // Sequence / time
      "to begin with",
      "to start with",
      "at first",
      "first of all",
      "first",
      "second",
      "third",
      "next",
      "then",
      "afterward",
      "afterwards",
      "later",
      "meanwhile",
      "subsequently",
      "eventually",
      "in the end",
      "finally",
      "ultimately",

      // Summary
      "in summary",
      "to summarize",
      "to sum up",
      "in short",
      "in brief",
      "overall"
    ].sort((a, b) => {
      const ta = a.split(" ").length;
      const tb = b.split(" ").length;
      if (tb !== ta) return tb - ta;
      return b.length - a.length;
    });

    const COHESION_STOP_WORDS = new Set([
      "the","a","an","and","or","but","if","then","so","because","since","as",
      "while","when","after","before","though","although","however","therefore",
      "thus","moreover","furthermore","additionally","also","likewise","similarly","from","into","onto",
      "with","within","without","of","to","in","on","at","by","for","about",
      "over","under","between","through","during","is","are","was","were","be",
      "been","being","am","have","has","had","do","does","did","doing","that",
      "this","these","those","it","its","their","they","them","he","she","his",
      "her","we","our","us","you","your","i","me","my","mine","yours","ours",
      "theirs","not","no","yes","can","could","would","should","may","might",
      "must","will","just","very","really","more","most","less","least","such",
      "than","too","each","every","some","any","all","both","either","neither",
      "nor","own","same","other","another","there","here","then","now","who",
      "whom","which","what","where","why","how","up","down","out","off","again",
      "further","once","ever","never","across","around","behind","beyond","near",
      "among","amongst","via",
      // Single-word transitions (should not count as boundary tokens)
      "accordingly","alternatively","afterward","afterwards","above","all",
      "besides","certainly","consequently","conversely","despite","eventually",
      "finally","first","hence","indeed","instead","later","meanwhile","namely",
      "nevertheless","next","nonetheless","notably","otherwise","overall","rather",
      "second","specifically","still","subsequently","third","ultimately","yet"
    ]);

    const COHESION_LOW_SIGNAL_WORDS = [
      "essay","text","story","novel","poem","poetry","author","writer","reader",
      "audience","character","quote","quotation","example","evidence","paragraph",
      "sentence","chapter"
    ];

    const COHESION_ENABLE_SEMANTIC_GROUPS = true;
    // Curated, noun-heavy concept groups (avoid generic nouns that inflate scores).
    const COHESION_CONCEPT_GROUPS = [
      {
        id: "CHANGE_MAGNITUDE",
        words: ["growth","increase","rise","expansion","decline","decrease","reduction","fall","drop"]
      },
      {
        id: "SUPPORT_CONTRAST",
        words: ["support","reinforcement","bolster","aid","undermine","erosion","weakening","subversion"]
      },
      {
        id: "CAUSE_EFFECT",
        words: ["cause","reason","basis","effect","result","consequence","outcome"]
      },
      {
        id: "CONFLICT",
        words: ["conflict","tension","clash","opposition","contrast"]
      }
    ];

    const SUBJECTIVE_TERMS = [
      "successfully",
      "successful",
      "powerful"
    ];

    const METRIC_INFO = {
      power: {
        title: "Power",
        body: "Power measures how specific your verb choices are (avoiding weak verbs like show/use).",
        tips: [
          "Swap show/use for precise verbs (illustrates, highlights, underscores).",
          "Avoid repeating the same verb across sentences.",
          "Aim for verbs that express analysis, not reporting."
        ]
      },
      variety: {
        title: "Variety",
        body: "Variety measures how repetitive your sentence openings are (pronoun/noun starts vs. varied starters).",
        tips: [
          "Start some sentences with a clause (Although/While/When...).",
          "Start with a prepositional phrase (In/Across/Through...).",
          "Avoid too many This/It/They starts in a row."
        ]
      },
      cohesion: {
        title: "Cohesion",
        body: "Cohesion measures how well ideas connect within paragraphs (sentence boundaries) and across paragraph breaks (paragraph boundaries). You earn the most points from boundary statementsâ€”repeating key content words or word families (desert â†’ desertion). Repeating author names, titles, or character names does NOT count. Transitions add only a small bonus within paragraphs; paragraph-start transitions are tracked but not rewarded.",
        tips: [
          "Carry a thesis noun into each paragraphâ€™s topic sentence.",
          "Repeat a key noun/verb/adjective or its word family (race â†’ racial).",
          "Use occasional within-paragraph transitions, but avoid repeats."
        ]
      },
      precision: {
        title: "Precision",
        body: "Precision measures removable wordiness (phrases that often weaken academic style).",
        tips: [
          "Cut filler like \"the use of\", \"the author\", and \"in conclusion\".",
          "Reduce extra \"and\" chains; split into clearer sentences.",
          "Avoid \"reader/audience\" unless the text directly supports it."
        ]
      }
    };

    function getSentenceStarterWord(sentence) {
      const tokens = tokenizeWords(sentence);
      if (tokens.length === 0) return "";
      let idx = 0;
      while (idx < tokens.length && SENTENCE_STARTER_SKIPS.has(tokens[idx])) {
        idx += 1;
      }
      return tokens[idx] || tokens[0] || "";
    }

    function porterStem(word) {
      let w = String(word || "").toLowerCase();
      if (w.length < 3) return w;

      const isConsonantAt = (str, i) => {
        const ch = str[i];
        if ("aeiou".includes(ch)) return false;
        if (ch === "y") return i === 0 ? true : !isConsonantAt(str, i - 1);
        return true;
      };

      const measure = (str) => {
        let count = 0;
        let i = 0;
        while (i < str.length) {
          while (i < str.length && isConsonantAt(str, i)) i += 1;
          if (i >= str.length) break;
          while (i < str.length && !isConsonantAt(str, i)) i += 1;
          count += 1;
        }
        return count;
      };

      const containsVowel = (str) => {
        for (let i = 0; i < str.length; i += 1) {
          if (!isConsonantAt(str, i)) return true;
        }
        return false;
      };

      const endsWithDoubleConsonant = (str) => {
        const len = str.length;
        if (len < 2) return false;
        return str[len - 1] === str[len - 2] && isConsonantAt(str, len - 1);
      };

      const cvc = (str) => {
        const len = str.length;
        if (len < 3) return false;
        if (!isConsonantAt(str, len - 1) || isConsonantAt(str, len - 2) || !isConsonantAt(str, len - 3)) {
          return false;
        }
        const ch = str[len - 1];
        return !["w", "x", "y"].includes(ch);
      };

      const replaceSuffix = (str, suffix, replacement) => (
        str.endsWith(suffix) ? str.slice(0, -suffix.length) + replacement : str
      );

      // Step 1a
      if (w.endsWith("sses")) w = w.slice(0, -2);
      else if (w.endsWith("ies")) w = w.slice(0, -2);
      else if (w.endsWith("ss")) w = w;
      else if (w.endsWith("s")) w = w.slice(0, -1);

      // Step 1b
      if (w.endsWith("eed")) {
        const base = w.slice(0, -3);
        if (measure(base) > 0) w = base + "ee";
      } else if (w.endsWith("ed")) {
        const base = w.slice(0, -2);
        if (containsVowel(base)) {
          w = base;
          if (w.endsWith("at") || w.endsWith("bl") || w.endsWith("iz")) w += "e";
          else if (endsWithDoubleConsonant(w) && !"lsz".includes(w[w.length - 1])) w = w.slice(0, -1);
          else if (measure(w) === 1 && cvc(w)) w += "e";
        }
      } else if (w.endsWith("ing")) {
        const base = w.slice(0, -3);
        if (containsVowel(base)) {
          w = base;
          if (w.endsWith("at") || w.endsWith("bl") || w.endsWith("iz")) w += "e";
          else if (endsWithDoubleConsonant(w) && !"lsz".includes(w[w.length - 1])) w = w.slice(0, -1);
          else if (measure(w) === 1 && cvc(w)) w += "e";
        }
      }

      // Step 1c
      if (w.endsWith("y")) {
        const base = w.slice(0, -1);
        if (containsVowel(base)) w = base + "i";
      }

      // Step 2
      const step2 = {
        ational: "ate",
        tional: "tion",
        enci: "ence",
        anci: "ance",
        izer: "ize",
        abli: "able",
        alli: "al",
        entli: "ent",
        eli: "e",
        ousli: "ous",
        ization: "ize",
        ation: "ate",
        ator: "ate",
        alism: "al",
        iveness: "ive",
        fulness: "ful",
        ousness: "ous",
        aliti: "al",
        iviti: "ive",
        biliti: "ble",
        logi: "log"
      };
      for (const [suffix, replacement] of Object.entries(step2)) {
        if (w.endsWith(suffix)) {
          const base = w.slice(0, -suffix.length);
          if (measure(base) > 0) w = base + replacement;
          break;
        }
      }

      // Step 3
      const step3 = {
        icate: "ic",
        ative: "",
        alize: "al",
        iciti: "ic",
        ical: "ic",
        ful: "",
        ness: ""
      };
      for (const [suffix, replacement] of Object.entries(step3)) {
        if (w.endsWith(suffix)) {
          const base = w.slice(0, -suffix.length);
          if (measure(base) > 0) w = base + replacement;
          break;
        }
      }

      // Step 4
      const step4 = [
        "al","ance","ence","er","ic","able","ible","ant","ement","ment","ent",
        "ion","ou","ism","ate","iti","ous","ive","ize"
      ];
      for (const suffix of step4) {
        if (!w.endsWith(suffix)) continue;
        const base = w.slice(0, -suffix.length);
        if (suffix === "ion" && !["s", "t"].includes(base.slice(-1))) break;
        if (measure(base) > 1) w = base;
        break;
      }

      // Step 5a
      if (w.endsWith("e")) {
        const base = w.slice(0, -1);
        if (measure(base) > 1 || (measure(base) === 1 && !cvc(base))) w = base;
      }

      // Step 5b
      if (measure(w) > 1 && endsWithDoubleConsonant(w) && w.endsWith("l")) {
        w = w.slice(0, -1);
      }

      return w;
    }

    function cohesionGroupKey(id) {
      return `__g__:${id}`;
    }

    const COHESION_GROUP_LOOKUP = (() => {
      const map = new Map();
      if (!COHESION_ENABLE_SEMANTIC_GROUPS) return map;
      (COHESION_CONCEPT_GROUPS || []).forEach((group) => {
        const groupId = group?.id;
        if (!groupId) return;
        const gk = cohesionGroupKey(groupId);
        (group.words || []).forEach((w) => {
          const raw = String(w || "").toLowerCase().trim();
          if (!raw) return;
          map.set(raw, gk);
          map.set(porterStem(raw), gk);
        });
      });
      return map;
    })();

    const DEBUG_COHESION = false;

    function normalizeCohesionToken(token) {
      const raw = String(token || "").toLowerCase();
      if (!raw) return "";
      let clean = raw.replace(/'s$/g, "").replace(/'/g, "");
      if (!clean) return "";
      const stem = porterStem(clean);
      if (COHESION_ENABLE_SEMANTIC_GROUPS) {
        const groupKey = COHESION_GROUP_LOOKUP.get(clean) || COHESION_GROUP_LOOKUP.get(stem);
        if (groupKey) return groupKey;
      }
      return stem;
    }

    function buildProperNounStopSet(text) {
      const tokens = String(text || "").match(/[A-Za-z][A-Za-z']*/g) || [];
      const flags = new Map();

      for (const token of tokens) {
        if (!token || token.length < 3) continue;
        const lower = token.toLowerCase();
        if (COHESION_STOP_WORDS.has(lower)) continue;

        const entry = flags.get(lower) || { lowerStart: false, upperStart: false };
        if (/^[a-z]/.test(token)) entry.lowerStart = true;
        if (/^[A-Z]/.test(token)) entry.upperStart = true;
        flags.set(lower, entry);
      }

      const stopSet = new Set();
      for (const [token, entry] of flags.entries()) {
        if (entry.upperStart && !entry.lowerStart) {
          stopSet.add(token);
        }
      }
      return stopSet;
    }

    function getCohesionKeyTokens(sentence, properNounStopSet, ignoredNormalized) {
      const tokens = tokenizeWords(sentence) || [];
      const results = [];
      for (const token of tokens) {
        const raw = String(token || "").toLowerCase();
        if (!raw) continue;
        if (properNounStopSet && properNounStopSet.has(raw)) continue;
        if (COHESION_STOP_WORDS.has(raw)) continue;
        const normalized = normalizeCohesionToken(raw);
        if (!normalized) continue;
        if (ignoredNormalized && ignoredNormalized.has(normalized)) continue;
        if (normalized.startsWith("__g__:")) {
          results.push(normalized);
          continue;
        }
        if (normalized.length < 3) continue;
        if (COHESION_STOP_WORDS.has(normalized)) continue;
        results.push(normalized);
      }
      return results;
    }

    if (DEBUG_COHESION) {
      console.assert(porterStem("desertion") === "desert");
      console.assert(porterStem("abandonment") === "abandon");
      console.assert(!getCohesionKeyTokens("Moreover, this is true.").some((t) => t.includes("moreov")));
      console.assert(
        normalizeCohesionToken("growth") === normalizeCohesionToken("decline"),
        "growth and decline should map to the same semantic group"
      );
      console.assert(splitParagraphsSimple("A\nB").length === 2, "single newline should split paragraphs");
      console.assert(splitParagraphsSimple("A\n\nB").length === 2, "blank line should split paragraphs");
      console.assert(
        detectTransitionStart("To put it simply, this is true.") === "to put it simply",
        "should detect multi-word transition: to put it simply"
      );
      console.assert(
        detectTransitionStart("In other words, this is true.") === "in other words",
        "should detect in other words"
      );
      console.assert(
        detectTransitionStart("As a matter of fact, this is true.") === "as a matter of fact",
        "should detect as a matter of fact"
      );
    }

    function detectTransitionStart(sentence) {
      const tokens = tokenizeWords(sentence || "");
      if (tokens.length === 0) return "";
      const windowTokens = tokens.slice(0, 7);
      if (windowTokens.length === 0) return "";
      for (const phrase of TRANSITIONS) {
        const phraseTokens = phrase.split(" ");
        if (phraseTokens.length > windowTokens.length) continue;
        let matches = true;
        for (let i = 0; i < phraseTokens.length; i += 1) {
          if (windowTokens[i] !== phraseTokens[i]) {
            matches = false;
            break;
          }
        }
        if (matches) return phrase;
      }
      return "";
    }


    function computeCohesionParagraphAware(text) {
      const cleanText = String(text || "");
      const paragraphs = splitParagraphsSimple(cleanText);
      const paraSentences = paragraphs
        .map((p) => splitSentencesSimple(p))
        .filter((arr) => arr && arr.length);
      const paragraphCount = paraSentences.length;

      const properNounStopSet = buildProperNounStopSet(cleanText);
      const ignoredNormalized = new Set(
        [...COHESION_LOW_SIGNAL_WORDS]
          .map((t) => normalizeCohesionToken(t))
          .filter(Boolean)
      );

      const sentenceTokenSets = paraSentences.map((sentences) =>
        sentences.map((s) =>
          new Set(getCohesionKeyTokens(s, properNounStopSet, ignoredNormalized))
        )
      );

      const sentenceBoundaryMisses = [];
      const paragraphBoundaryMisses = [];
      const weakIssueMap = new Map();

      const addWeakIssue = (sentence, paragraphIndex, reason) => {
        if (!sentence) return;
        const key = `${paragraphIndex}|${sentence}`;
        const existing = weakIssueMap.get(key) || { sentence, paragraph_index: paragraphIndex, reasons: [] };
        if (!existing.reasons.includes(reason)) existing.reasons.push(reason);
        weakIssueMap.set(key, existing);
      };

      let sentenceBoundaryDenom = 0;
      let sentenceBoundaryHits = 0;

      for (let p = 0; p < sentenceTokenSets.length; p += 1) {
        const sentenceSets = sentenceTokenSets[p];
        const sentCount = sentenceSets.length;
        sentenceBoundaryDenom += Math.max(0, sentCount - 1);
        for (let i = 0; i < sentCount - 1; i += 1) {
          const a = sentenceSets[i];
          const b = sentenceSets[i + 1];
          let hitToken = "";
          for (const tok of a) {
            if (b.has(tok)) {
              hitToken = tok;
              break;
            }
          }
          if (hitToken) {
            sentenceBoundaryHits += 1;
          } else {
            sentenceBoundaryMisses.push({
              sentence: paraSentences[p][i + 1],
              paragraph_index: p,
              reason: "No shared key terms with previous sentence."
            });
          }
        }
      }

      const paragraphBoundaryDenom = Math.max(0, paragraphCount - 1);
      let paragraphBoundaryHits = 0;

      for (let i = 0; i < paragraphCount - 1; i += 1) {
        const prevLastSet = sentenceTokenSets[i][sentenceTokenSets[i].length - 1];
        const nextFirstSet = sentenceTokenSets[i + 1][0];
        let hitToken = "";
        for (const tok of prevLastSet) {
          if (nextFirstSet.has(tok)) {
            hitToken = tok;
            break;
          }
        }
        if (hitToken) {
          paragraphBoundaryHits += 1;
        } else {
          paragraphBoundaryMisses.push({
            sentence: paraSentences[i + 1][0],
            paragraph_index: i + 1,
            reason: "No shared key terms across paragraph break."
          });
        }
      }

      const withinTransitionCounts = new Map();
      const allTransitionOccurrences = [];
      let withinTransitionStarts = 0;
      let paragraphStartTransitionStarts = 0;

      for (let p = 0; p < paraSentences.length; p += 1) {
        const sentences = paraSentences[p];
        for (let s = 0; s < sentences.length; s += 1) {
          const tr = detectTransitionStart(sentences[s]);
          if (!tr) continue;
          const isParagraphStart = s === 0;
          if (isParagraphStart) {
            paragraphStartTransitionStarts += 1;
          } else {
            withinTransitionStarts += 1;
            const known = withinTransitionCounts.get(tr) || 0;
            withinTransitionCounts.set(tr, known + 1);
          }
          allTransitionOccurrences.push({
            phrase: tr,
            sentence: sentences[s],
            paragraph_index: p,
            isParagraphStart
          });
        }
      }

      const withinUniqueTransitions = withinTransitionCounts.size;

      const phraseCounts = new Map();
      allTransitionOccurrences.forEach((occ) => {
        const count = phraseCounts.get(occ.phrase) || 0;
        if (count >= 1) {
          addWeakIssue(occ.sentence, occ.paragraph_index, `Repeated transition: ${occ.phrase}`);
        }
        phraseCounts.set(occ.phrase, count + 1);
        if (occ.isParagraphStart) {
          addWeakIssue(occ.sentence, occ.paragraph_index, "Paragraph starts with transition");
        }
      });

      const sentenceBoundaryRate = sentenceBoundaryDenom
        ? (sentenceBoundaryHits / sentenceBoundaryDenom)
        : null;
      const paragraphBoundaryRate = paragraphBoundaryDenom
        ? (paragraphBoundaryHits / paragraphBoundaryDenom)
        : null;

      let sentenceWeight = sentenceBoundaryRate === null ? 0 : 0.4;
      let paragraphWeight = paragraphBoundaryRate === null ? 0 : 0.6;

      if (sentenceWeight === 0 && paragraphWeight === 0) {
        sentenceWeight = 1;
        paragraphWeight = 0;
      }

      const boundaryScore = (sentenceWeight + paragraphWeight) === 0
        ? 100
        : 100 * (
          (sentenceBoundaryRate || 0) * sentenceWeight
          + (paragraphBoundaryRate || 0) * paragraphWeight
        ) / (sentenceWeight + paragraphWeight);

      const varietyFactor = withinTransitionStarts
        ? (withinUniqueTransitions / withinTransitionStarts)
        : 0;
      const baseTransitionBonus = 8 * clamp01(
        paragraphCount ? (withinTransitionStarts / paragraphCount) : 0
      );
      const repeatsWithin = Math.max(0, withinTransitionStarts - withinUniqueTransitions);
      const repetitionPenalty = 8 * clamp01(
        withinTransitionStarts ? (repeatsWithin / withinTransitionStarts) : 0
      );
      let transitionBonus = baseTransitionBonus * varietyFactor - repetitionPenalty;
      transitionBonus = clamp(transitionBonus, 0, 8);

      const cohesionScore = clamp(Math.round(boundaryScore + transitionBonus), 0, 100);

      const cohesionSub =
        `Sentence boundaries: ${sentenceBoundaryHits}/${sentenceBoundaryDenom} â€¢ `
        + `Paragraph boundaries: ${paragraphBoundaryHits}/${paragraphBoundaryDenom} â€¢ `
        + `Transitions (within): ${withinTransitionStarts} (unique ${withinUniqueTransitions}) â€¢ `
        + `Paragraph-start transitions: ${paragraphStartTransitionStarts}`;

      const weakTransitions = Array.from(weakIssueMap.values())
        .map((entry) => ({
          sentence: entry.sentence,
          paragraph_index: entry.paragraph_index,
          reason: entry.reasons.join("; ")
        }));

      return {
        cohesionScore,
        cohesionSub,
        details: {
          sentenceBoundaryHits,
          sentenceBoundaryDenom,
          paragraphBoundaryHits,
          paragraphBoundaryDenom,
          transitionsWithinCount: withinTransitionStarts,
          transitionsWithinUnique: withinUniqueTransitions,
          paragraphStartTransitionsCount: paragraphStartTransitionStarts,
          issues: {
            sentenceBoundaryMisses,
            paragraphBoundaryMisses,
            weakTransitions
          },
          sourceText: cleanText
        }
      };
    }

    if (DEBUG_COHESION) {
      const sample1 = "He crossed the desert.\n\nThis desertion shocked everyone.";
      const r1 = computeCohesionParagraphAware(sample1);
      console.assert(
        r1.details.paragraphBoundaryHits === 1,
        "desert/desertion should count across paragraphs"
      );

      const sampleProper = "Didion explains the essay.\n\nDidion continues.";
      const rProper = computeCohesionParagraphAware(sampleProper);
      console.assert(
        rProper.details.paragraphBoundaryHits === 0,
        "proper noun repetition alone should not count"
      );

      const sampleProperPlusConcept = "Didion explains identity.\n\nDidion returns to identity.";
      const rProperPlus = computeCohesionParagraphAware(sampleProperPlusConcept);
      console.assert(
        rProperPlus.details.paragraphBoundaryHits === 1,
        "analytical noun should count even with proper noun repetition"
      );

      const sample2 = "One point.\n\nHowever, another point.";
      const r2 = computeCohesionParagraphAware(sample2);
      console.assert(
        r2.details.paragraphStartTransitionsCount === 1,
        "paragraph-start transition should be tracked"
      );

      const sample3 = "One point. However, another point.";
      const r3 = computeCohesionParagraphAware(sample3);
      console.assert(
        r3.details.transitionsWithinCount === 1,
        "within-paragraph transition should count"
      );

      const sampleRepeat = "In other words, one point. In other words, another point.";
      const rRepeat = computeCohesionParagraphAware(sampleRepeat);
      console.assert(
        rRepeat.details.issues.weakTransitions.some((item) => /Repeated transition/i.test(item.reason)),
        "repeated transitions should be flagged as weak"
      );
    }

    function powerVerbTargetForWordCount(wc) {
      const n = Number(wc) || 0;
      if (n < 200) return 0;
      if (n <= 500) return 5;
      if (n <= 800) return 10;
      return 10 + 5 * Math.ceil((n - 800) / 300);
    }

    function computeMetricsFromText(text, mode) {
      const cleanForCohesion = stripQuotedText(
        normalizeTypographyPreserveParagraphs(text || "")
      );
      const cleanForCounts = stripQuotedText(normalizeTypography(text || ""));
      const cleanLower = cleanForCounts.toLowerCase().replace(/\s+/g, " ").trim();
      const words = tokenizeWords(cleanLower);
      const totalWords = words.length;

      const weakByBase = { show: 0, use: 0, make: 0, do: 0, get: 0, have: 0 };
      let weakCount = 0;
      for (let i = 0; i < words.length; i += 1) {
        const w = words[i];
        if (!WEAK_VERBS.has(w)) continue;
        if (isTheUseOf(words, i)) continue;

        weakCount += 1;
        const base = WEAK_VERB_FORM_TO_BASE.get(w);
        if (base && weakByBase[base] !== undefined) weakByBase[base] += 1;
      }

      let powerCount = 0;
      let powerTarget = powerVerbTargetForWordCount(totalWords);
      if (powerVerbFormsSet && powerTarget > 0) {
        const uniq = new Set();
        for (const w of words) {
          if (WEAK_VERBS.has(w)) continue;
          if (powerVerbFormsSet.has(w)) uniq.add(w);
        }
        powerCount = uniq.size;
      }
      const weakRatePer100 = totalWords ? (weakCount / totalWords) * 100 : 0;
      const weakScore = clamp(Math.round(100 - weakRatePer100 * 8), 0, 100);
      const powerVerbScore = powerTarget === 0
        ? 100
        : clamp(Math.round((powerCount / powerTarget) * 100), 0, 100);
      const powerScore = clamp(Math.round(weakScore * 0.6 + powerVerbScore * 0.4), 0, 100);

      const powerSub = "";

      const sentences = splitSentencesSimple(cleanForCohesion);
      let pronounStarts = 0;
      for (const sentence of sentences) {
        const starter = getSentenceStarterWord(sentence);
        if (starter && PRONOUN_STARTERS.has(starter)) {
          pronounStarts += 1;
        }
      }
      const pronounStartRate = sentences.length ? pronounStarts / sentences.length : 0;
      const varietyScore = clamp(Math.round(100 - pronounStartRate * 120), 0, 100);

      const paragraphs = splitParagraphsSimple(cleanForCohesion);
      const cohesionCalc = computeCohesionParagraphAware(cleanForCohesion);
      const cohesionScore = cohesionCalc.cohesionScore;
      const cohesionSub = cohesionCalc.cohesionSub;

      if (DEBUG_METRICS) {
        console.log({
          sentenceCount: sentences.length,
          sentenceBoundaryHits: cohesionCalc.details.sentenceBoundaryHits,
          sentenceBoundaryDenom: cohesionCalc.details.sentenceBoundaryDenom,
          paragraphBoundaryHits: cohesionCalc.details.paragraphBoundaryHits,
          paragraphBoundaryDenom: cohesionCalc.details.paragraphBoundaryDenom,
          withinTransitionStarts: cohesionCalc.details.transitionsWithinCount,
          withinUniqueTransitions: cohesionCalc.details.transitionsWithinUnique,
          paragraphStartTransitionStarts: cohesionCalc.details.paragraphStartTransitionsCount,
          cohesionScore
        });
      }

      const andCount = countRegexMatches(cleanLower, /\band\b/g);
      const whichCount = countRegexMatches(cleanLower, /\bwhich\b/g);
      const readerCount = countRegexMatches(cleanLower, /\breader\b/g);
      const audienceCount = countRegexMatches(cleanLower, /\baudience\b/g);
      const readerAudienceCount = readerCount + audienceCount;
      const useOfCount = countRegexMatches(cleanLower, /\bthe\s+use\s+of\b/g);
      const authorCount = countRegexMatches(cleanLower, /\bthe\s+author\b/g);
      const inConclusionCount = countRegexMatches(cleanLower, /\bin\s+conclusion\b/g);
      let subjectiveCount = 0;
      SUBJECTIVE_TERMS.forEach((term) => {
        const pattern = new RegExp(`\\b${term.replace(/\s+/g, "\\s+")}\\b`, "g");
        subjectiveCount += countRegexMatches(cleanLower, pattern);
      });

      const per100 = (count) => (totalWords ? (count / totalWords) * 100 : 0);
      const precisionPenalty = (per100(andCount) * 4)
        + (per100(whichCount) * 8)
        + (per100(readerAudienceCount) * 10)
        + (per100(useOfCount) * 12)
        + (per100(authorCount) * 12)
        + (per100(inConclusionCount) * 15)
        + (per100(subjectiveCount) * 10);
      const precisionScore = clamp(Math.round(100 - precisionPenalty), 0, 100);

      const clutterItems = [
        { label: "and", count: andCount },
        { label: "which", count: whichCount },
        { label: "reader/audience", count: readerAudienceCount },
        { label: "the use of", count: useOfCount },
        { label: "the author", count: authorCount },
        { label: "in conclusion", count: inConclusionCount },
        { label: "subjective words", count: subjectiveCount }
      ];
      const topClutter = clutterItems
        .filter((item) => item.count > 0)
        .sort((a, b) => {
          const diff = b.count - a.count;
          if (diff !== 0) return diff;
          return a.label.localeCompare(b.label);
        })
        .slice(0, 3)
        .map((item) => `${item.label} (${item.count})`);
      const precisionSub = topClutter.length ? `Top clutter: ${topClutter.join(", ")}` : "Top clutter: none";

      return {
        power: {
          score: powerScore,
          sub: powerSub,
          details: {
            weakCount,
            weakByBase,
            powerCount,
            powerTarget
          }
        },
        variety: {
          score: varietyScore,
          sub: `Pronoun starts: ${pronounStarts}/${sentences.length}`
        },
        cohesion: {
          score: cohesionScore,
          sub: cohesionSub,
          details: cohesionCalc.details
        },
        precision: {
          score: precisionScore,
          sub: precisionSub
        },
        meta: {
          paragraphs: paragraphs.length,
          sentences: sentences.length,
          mode: mode || ""
        }
      };
    }

    function renderSingleMetric(scoreEl, meterEl, subEl, metric) {
      if (!scoreEl || !meterEl || !subEl) return;
      if (!metric || typeof metric.score !== "number") {
        scoreEl.textContent = "â€”";
        meterEl.style.width = "0%";
        scoreEl.classList.remove("perfect");
        meterEl.classList.remove("perfect");
        subEl.textContent = "";
        return;
      }
      const scoreValue = clamp(metric.score, 0, 100);
      const isPerfect = scoreValue === 100;
      scoreEl.textContent = `${scoreValue}/100`;
      meterEl.style.width = `${scoreValue}%`;
      scoreEl.classList.toggle("perfect", isPerfect);
      meterEl.classList.toggle("perfect", isPerfect);
      subEl.textContent = metric.sub || "";
    }

    function renderMetrics(metrics) {
      if (!metricsGrid) return;
      lastStudentMetrics = metrics || null;

      renderSingleMetric(powerScoreText, powerMeterFill, powerSubText, metrics?.power);
      renderPowerDots(powerSubText, metrics?.power);
      renderSingleMetric(varietyScoreText, varietyMeterFill, varietySubText, metrics?.variety);
      if (metrics?.variety?.score === 100) {
        renderSuccess(varietySubText, "Sentence patterns are varied.");
      }
      renderSingleMetric(precisionScoreText, precisionMeterFill, precisionSubText, metrics?.precision);
      if (metrics?.precision?.score === 100) {
        renderSuccess(precisionSubText, "No excess detected.");
      }

      const sentenceCount = metrics?.meta?.sentences || 0;
      const mode = metrics?.meta?.mode || "";
      const hideCohesion = mode === "peel_paragraph";
      if (metricCohesionCard) metricCohesionCard.style.display = hideCohesion ? "none" : "block";

      if (!metrics || hideCohesion) {
        renderSingleMetric(cohesionScoreText, cohesionMeterFill, cohesionSubText, null);
        updateCohesionIssueCache(null, "");
      } else if (sentenceCount < 2) {
        cohesionScoreText.textContent = "â€”";
        cohesionMeterFill.style.width = "0%";
        cohesionScoreText.classList.remove("perfect");
        cohesionMeterFill.classList.remove("perfect");
        cohesionSubText.textContent = "Add sentence links (transitions/boundaries)";
        updateCohesionIssueCache(null, "");
      } else {
        renderSingleMetric(cohesionScoreText, cohesionMeterFill, cohesionSubText, metrics?.cohesion);
        updateCohesionIssueCache(metrics?.cohesion?.details, metrics?.cohesion?.details?.sourceText);
        renderCohesionQuests(cohesionSubText, metrics?.cohesion);
      }
      if (metricPrecisionCard) metricPrecisionCard.style.display = "block";
    }

    function closeMetricPopover() {
      if (!metricInfoPopover) return;
      metricInfoPopover.classList.add("hidden");
    }

    function openMetricPopover(anchorEl, key) {
      if (!metricInfoPopover || !metricInfoTitle || !metricInfoBody || !anchorEl) return;
      const info = METRIC_INFO[key];
      if (!info) return;

      metricInfoTitle.textContent = info.title || "";
      metricInfoBody.innerHTML = "";

      const bodyCopy = document.createElement("div");
      bodyCopy.textContent = info.body || "";
      metricInfoBody.appendChild(bodyCopy);

      const tipsTitle = document.createElement("div");
      tipsTitle.className = "metric-popover-tips-title";
      tipsTitle.textContent = "Tips to improve";
      metricInfoBody.appendChild(tipsTitle);

      const tipsList = document.createElement("ul");
      tipsList.className = "metric-popover-list";
      (info.tips || []).forEach((tip) => {
        const li = document.createElement("li");
        li.textContent = tip;
        tipsList.appendChild(li);
      });
      metricInfoBody.appendChild(tipsList);

      if (key === "power") {
        const divider = document.createElement("div");
        divider.style.marginTop = "12px";
        divider.style.paddingTop = "10px";
        divider.style.borderTop = "1px solid rgba(0,0,0,.10)";
        metricInfoBody.appendChild(divider);

        const progTitle = document.createElement("div");
        progTitle.className = "metric-popover-tips-title";
        progTitle.textContent = "Progress";
        metricInfoBody.appendChild(progTitle);

        const progWrap = document.createElement("div");
        progWrap.style.marginTop = "8px";
        metricInfoBody.appendChild(progWrap);

        renderPowerDotsPopover(progWrap, lastStudentMetrics?.power);
      }

      metricInfoPopover.classList.remove("hidden");
      metricInfoPopover.style.visibility = "hidden";
      metricInfoPopover.style.display = "block";

      const gap = 10;
      const padding = 12;
      const rect = anchorEl.getBoundingClientRect();
      const popRect = metricInfoPopover.getBoundingClientRect();
      const fitsBelow = rect.bottom + gap + popRect.height <= window.innerHeight;

      let top = fitsBelow ? rect.bottom + gap : rect.top - popRect.height - gap;
      top = Math.max(padding, Math.min(top, window.innerHeight - popRect.height - padding));

      let left = rect.left + rect.width / 2 - popRect.width / 2;
      left = Math.max(padding, Math.min(left, window.innerWidth - popRect.width - padding));

      metricInfoPopover.style.top = `${Math.round(top)}px`;
      metricInfoPopover.style.left = `${Math.round(left)}px`;
      metricInfoPopover.style.visibility = "visible";
    }

    document.addEventListener("click", (e) => {
      const btn = e.target.closest(".metric-info-btn");
      if (btn) {
        const key = btn.dataset.metric;
        openMetricPopover(btn, key);
        return;
      }
      if (metricInfoPopover && !metricInfoPopover.classList.contains("hidden")) {
        const clickedInside = e.target.closest("#metricInfoPopover");
        if (!clickedInside) closeMetricPopover();
      }
    });

    if (metricInfoClose) {
      metricInfoClose.addEventListener("click", closeMetricPopover);
    }

    async function getMetricsTextSource() {
      const previewText = extractPreviewText();
      if (previewText) return previewText;
      if (!selectedFile || !mammoth) return "";
      try {
        const arrayBuffer = await selectedFile.arrayBuffer();
        if (mammoth.convertToRawText) {
          const raw = await mammoth.convertToRawText({ arrayBuffer });
          return raw?.value || "";
        }
        if (mammoth.convertToHtml) {
          const htmlResult = await mammoth.convertToHtml({ arrayBuffer });
          return stripTags(htmlResult?.value || "");
        }
      } catch (err) {
        console.warn("Metrics fallback text extraction failed:", err);
      }
      return "";
    }

    async function refreshStudentMetrics() {
      const text = await getMetricsTextSource();
      if (!text) {
        renderMetrics(null);
        return;
      }
      await loadPowerVerbsList();
      if (!powerVerbFormsSet && powerVerbsList) {
        powerVerbFormsSet = buildPowerVerbFormsSet(powerVerbsList);
      }
      const mode = modeSelect ? modeSelect.value : "";
      const metrics = computeMetricsFromText(text, mode);
      renderMetrics(metrics);
    }

    function setApplyAttention(applyBtn) {
      if (!applyBtn) return;
      applyBtn.classList.add("apply-attention");
      if (applyBtn._attentionTimer) clearTimeout(applyBtn._attentionTimer);
      applyBtn._attentionTimer = setTimeout(() => {
        applyBtn.classList.remove("apply-attention");
        applyBtn._attentionTimer = null;
      }, 6000);
    }

    function clearApplyAttention(applyBtn) {
      if (!applyBtn) return;
      applyBtn.classList.remove("apply-attention");
      if (applyBtn._attentionTimer) {
        clearTimeout(applyBtn._attentionTimer);
        applyBtn._attentionTimer = null;
      }
    }

    function upsertApprovedRewrite(entry) {
      if (!entry || !entry.exampleKey) return;
      const existingIndex = approvedRewrites.findIndex(
        (item) => item.exampleKey === entry.exampleKey
      );
      if (existingIndex >= 0) {
        approvedRewrites[existingIndex] = { ...approvedRewrites[existingIndex], ...entry };
      } else {
        approvedRewrites.push(entry);
      }
    }

    function removeApprovedRewriteByKey(exampleKey) {
      if (!exampleKey) return;
      const idx = approvedRewrites.findIndex((item) => item.exampleKey === exampleKey);
      if (idx >= 0) {
        approvedRewrites.splice(idx, 1);
      }
    }

    function setApprovedRewritesCollapsed(collapsed) {
      approvedRewritesCollapsed = !!collapsed;
      if (approvedRewritesWrap) {
        approvedRewritesWrap.dataset.collapsed = approvedRewritesCollapsed ? "true" : "false";
      }
      if (approvedRewritesToggle) {
        approvedRewritesToggle.setAttribute("aria-expanded", String(!approvedRewritesCollapsed));
      }
    }

    function updateApprovedRewritesToggle(visibleCount) {
      if (!approvedRewritesToggle) return;
      const countText = Number.isFinite(visibleCount) ? ` (${visibleCount})` : "";
      approvedRewritesToggle.textContent = `${approvedRewritesCollapsed ? "Show" : "Hide"} approved rewrites${countText}`;
    }

    function renderApprovedRewritesList() {
      if (!approvedRewritesList || !approvedRewritesWrap) return;
      approvedRewritesList.innerHTML = "";

      const approvedForList = approvedRewrites.filter(
        (entry) => entry.exampleKey && entry.exampleKey !== currentExampleKey
      );

      if (!approvedForList.length) {
        approvedRewritesWrap.style.display = "none";
        updateApplyAllUI();
        return;
      }

      approvedRewritesWrap.style.display = "block";
      setApprovedRewritesCollapsed(approvedRewritesCollapsed);
      updateApprovedRewritesToggle(approvedForList.length);

      approvedForList.forEach((entry) => {
        const li = document.createElement("li");
        li.className = "approved-rewrite-card";
        li.dataset.exampleKey = entry.exampleKey;
        li.dataset.approvedRewrite = entry.rewriteText || "";
        li.dataset.label = entry.label || "";
        li._exampleData = entry.examplePayload || null;

        const labelDiv = document.createElement("div");
        labelDiv.className = "approved-rewrite-label";
        labelDiv.textContent = entry.label || "Issue";

        const textDiv = document.createElement("div");
        textDiv.className = "approved-rewrite-text";
        textDiv.textContent = entry.rewriteText || "";

        const statusDiv = document.createElement("div");
        statusDiv.className = "rewrite-status";

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "approved-rewrite-actions";

        const applyBtn = document.createElement("button");
        applyBtn.className = "example-btn apply-to-preview-btn";
        applyBtn.textContent = "Apply to Preview";
        applyBtn.onclick = () => {
          const applied = applyRewriteToPreviewByKey({
            exampleKey: entry.exampleKey,
            rewriteText: entry.rewriteText,
            exampleData: entry.examplePayload,
            statusDiv,
            applyBtn,
            exampleRow: li
          });
          if (applied) {
            renderCurrentExample();
            updateApplyAllUI();
          }
        };

        actionsDiv.appendChild(applyBtn);
        li.appendChild(labelDiv);
        li.appendChild(textDiv);
        li.appendChild(statusDiv);
        li.appendChild(actionsDiv);
        approvedRewritesList.appendChild(li);
      });
      updateApplyAllUI();
    }

    function updateApplyAllUI(totalApprovedCount = approvedRewrites.length) {
      if (!applyAllToPreviewBtn) return;
      const approvedCount = totalApprovedCount;
      if (approvedCount >= 2) {
        applyAllToPreviewBtn.style.display = "block";
        applyAllToPreviewBtn.disabled = false;
        applyAllToPreviewBtn.classList.add("apply-attention");
      } else {
        applyAllToPreviewBtn.style.display = "none";
        applyAllToPreviewBtn.disabled = true;
        applyAllToPreviewBtn.classList.remove("apply-attention");
      }
    }

    function resetRevisionPracticeUI() {
      if (revisionPracticeCard) revisionPracticeCard.style.display = "none";
      if (issueExplanationBlock) issueExplanationBlock.style.display = "none";
      if (examplesList) examplesList.innerHTML = "";
      if (allApprovedBanner) allApprovedBanner.style.display = "none";
      if (examplesEmptyState) examplesEmptyState.style.display = "none";
      if (approvedRewritesList) approvedRewritesList.innerHTML = "";
      if (approvedRewritesWrap) approvedRewritesWrap.style.display = "none";
      approvedRewrites.length = 0;
      currentExampleKey = null;
      approvedRewritesCollapsed = true;
      setApprovedRewritesCollapsed(true);
      approvedRewriteByKey.clear();
      approvedExampleKeys.clear();
      draftRewriteByKey.clear();
      exampleDataByKey.clear();
      examplesByIssueId.clear();
      if (applyAllToPreviewBtn) {
        applyAllToPreviewBtn.style.display = "none";
        applyAllToPreviewBtn.disabled = true;
        applyAllToPreviewBtn.classList.remove("apply-attention");
      }
      if (downloadRevisionNotesBtn) downloadRevisionNotesBtn.style.display = "none";
      if (exampleNavRow) exampleNavRow.style.display = "none";
      if (exampleNavText) exampleNavText.textContent = "";
    }

    function revokeApprovedRewrite({ exampleKey, exampleRow, applyBtn, statusDiv }) {
      if (!exampleKey) return;
      approvedRewriteByKey.delete(exampleKey);
      approvedExampleKeys.delete(exampleKey);
      setExampleApprovalState(exampleKey, false);
      removeApprovedRewriteByKey(exampleKey);
      renderApprovedRewritesList();
      if (exampleRow) {
        exampleRow.classList.remove("example-approved", "example-applied");
        delete exampleRow.dataset.applied;
        delete exampleRow.dataset.approvedRewrite;
      }
      if (applyBtn) {
        applyBtn.disabled = true;
        clearApplyAttention(applyBtn);
      }
      if (statusDiv) {
        statusDiv.textContent = "Rewrite changed â€” approval cleared.";
        statusDiv.className = "rewrite-status visible bad";
      }
      if (examplesList && exampleRow) {
        examplesList.innerHTML = "";
        examplesList.appendChild(exampleRow);
      }
      updateApplyAllUI();
      updateAllApprovedBanner(currentExamplesAll);
    }

    function hideExamplesEmptyState() {
      if (examplesEmptyState) examplesEmptyState.style.display = "none";
    }

    function showExamplesEmptyState(message) {
      if (examplesList) examplesList.innerHTML = "";
      if (!examplesEmptyState) return;
      examplesEmptyState.textContent = message;
      examplesEmptyState.style.display = "block";
    }

    function isExampleApproved(example) {
      if (!example) return false;
      if (example.approved === true) return true;
      const key = getExampleKey(example);
      return key ? approvedExampleKeys.has(key) : false;
    }

    function isExampleApplied(example) {
      if (!example) return false;
      if (example.applied_to_preview === true) return true;
      const key = getExampleKey(example);
      return key ? appliedExampleKeys.has(key) : false;
    }

    function setExampleApprovalState(exampleKey, approved) {
      if (!exampleKey) return;
      currentExamplesAll.forEach((ex) => {
        if (getExampleKey(ex) === exampleKey) {
          ex.approved = !!approved;
        }
      });
    }

    function setExampleAppliedState(exampleKey, applied, label) {
      if (!exampleKey) return;
      const appliedValue = !!applied;
      currentExamplesAll.forEach((ex) => {
        if (getExampleKey(ex) === exampleKey) {
          ex.applied_to_preview = appliedValue;
        }
      });
      const exampleData = exampleDataByKey.get(exampleKey);
      if (exampleData) {
        exampleData.applied_to_preview = appliedValue;
      }
      saveAppliedFlag(label || currentLabel || "", exampleKey, appliedValue);
    }

    function updateAllApprovedBanner(examples) {
      if (!allApprovedBanner) return;
      const list = Array.isArray(examples) ? examples : [];
      const hasExamples = list.length > 0;
      const allApproved = hasExamples && list.every((ex) => isExampleApproved(ex));
      const allApplied = hasExamples && list.every((ex) => isExampleApplied(ex));
      allApprovedBanner.style.display = allApproved && !allApplied ? "block" : "none";
    }

    function escapeRegExp(str) {
      return String(str).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function extractQuotedTerms(text) {
      const t = String(text || "");
      const out = [];
      const patterns = [
        /'([^']+)'/g,
        /"([^"]+)"/g,
        /[â€˜']([^â€™']+)[â€™']/g,
        /[â€œ"]([^â€"]+)[â€"]/g
      ];

      for (const re of patterns) {
        let m;
        while ((m = re.exec(t)) !== null) {
          const term = (m[1] || "").trim();
          if (term) out.push(term);
        }
      }
      return Array.from(new Set(out));
    }

    function findFoundTerms(sentence, labelText) {
      const s = String(sentence || "");
      const candidates = extractQuotedTerms(labelText);

      // If label has no quoted terms but this is the weak-verbs issue,
      // infer the "FOUND" term(s) directly from the sentence.
      if (candidates.length === 0 && isAvoidWeakVerbsLabel(labelText)) {
        const hits = [];
        const seen = new Set();
        const tokens = tokenizeWords(sentence);

        for (const w of tokens) {
          if (WEAK_VERBS.has(w) && !seen.has(w)) {
            seen.add(w);
            hits.push(w);
          }
        }
        return hits; // e.g., ["showed"] or ["use", "make"]
      }

      const found = [];
      const seen = new Set();

      for (const term of candidates) {
        if (!term) continue;

        let matchText = null;

        // If it's a simple word, prefer word-boundary match
        if (/^[A-Za-z0-9_]+$/.test(term)) {
          const re = new RegExp(`\\b${escapeRegExp(term)}\\b`, "i");
          const m = re.exec(s);
          if (m) matchText = m[0];
        } else {
          // Otherwise do a case-insensitive substring match
          const idx = s.toLowerCase().indexOf(term.toLowerCase());
          if (idx !== -1) matchText = s.slice(idx, idx + term.length);
        }

        if (matchText) {
          const key = matchText.toLowerCase();
          if (!seen.has(key)) {
            seen.add(key);
            found.push(matchText);
          }
        }
      }

      return found;
    }

    function formatFound(foundTerms) {
      if (!foundTerms || foundTerms.length === 0) return "that word/phrase";
      const quoted = foundTerms.map(w => `'${w}'`);
      if (quoted.length === 1) return quoted[0];
      if (quoted.length === 2) return `${quoted[0]} or ${quoted[1]}`;
      return `${quoted.slice(0, -1).join(", ")}, or ${quoted[quoted.length - 1]}`;
    }

    function resolveStudentGuidance(template, sentence, labelText) {
      const tmpl = String(template || "");
      if (!tmpl.includes("{FOUND}")) return tmpl;
      const foundTerms = findFoundTerms(sentence, labelText);
      const replacement = formatFound(foundTerms);
      return tmpl.split("{FOUND}").join(replacement);
    }

    function getRotationExamples() {
      return (currentExamplesAll || []).filter((ex) => {
        const key = getExampleKey(ex);
        if (!key) return false;
        if (appliedExampleKeys.has(key)) return false;
        if (isDismissedIssueInstance(ex?.label || currentLabel || "", ex?.sentence || "")) return false;
        return !approvedExampleKeys.has(key);
      });
    }

    function updateExampleNav(totalCount) {
      if (!exampleNavRow || !exampleNavText || !nextExampleBtn) return;
      if (!totalCount || totalCount <= 0) {
        exampleNavRow.style.display = "none";
        return;
      }
      exampleNavRow.style.display = "flex";
      exampleNavText.textContent = "";
      exampleNavText.style.display = "none";
      nextExampleBtn.disabled = totalCount <= 1;
    }

    function autosizeTextarea(el, maxHeight = 220) {
      if (!el) return;
      el.style.height = "auto";
      const nextHeight = Math.min(el.scrollHeight, maxHeight);
      el.style.height = `${nextHeight}px`;
      el.style.overflowY = el.scrollHeight > maxHeight ? "auto" : "hidden";
    }

    function renderCurrentExample() {
      if (!examplesList) return;

      const rotationExamples = getRotationExamples();
      updateAllApprovedBanner(currentExamplesAll);
      if (!rotationExamples.length) {
        const hasExamples = Array.isArray(currentExamplesAll) && currentExamplesAll.length > 0;
        const allApproved = hasExamples && currentExamplesAll.every((ex) => isExampleApproved(ex));
        const allApplied = hasExamples && currentExamplesAll.every((ex) => isExampleApplied(ex));
        if (allApproved && !allApplied) {
          hideExamplesEmptyState();
        } else {
          showExamplesEmptyState(
            getPreviewOnlyMessage(
              currentLabel || "",
              "No more examples for this issue. Click another bar to practice a different issue."
            )
          );
        }
        updateExampleNav(0);
        currentExampleKey = null;
        renderApprovedRewritesList();
        updateApplyAllUI();
        return;
      }

      hideExamplesEmptyState();
      currentIndex = ((currentIndex % rotationExamples.length) + rotationExamples.length) % rotationExamples.length;
      const ex = rotationExamples[currentIndex];
      const exampleKey = getExampleKey(ex);
      currentExampleKey = exampleKey || null;

      examplesList.innerHTML = "";
      activePowerVerbsHelper = null;

      const li = document.createElement("li");
      li.className = "example-item";
      li.dataset.label = currentLabel || ex?.label || "";
      if (exampleKey) li.dataset.exampleKey = exampleKey;

      const guidanceDiv = document.createElement("div");
      guidanceDiv.className = "example-guidance";
      if (currentGuidance) {
        const guidanceLabel = document.createElement("div");
        guidanceLabel.className = "example-guidance-label";
        guidanceLabel.textContent = "Student guidance";
        const guidanceText = document.createElement("div");
        guidanceText.className = "example-guidance-text";
        guidanceText.textContent = resolveStudentGuidance(
          currentGuidance,
          ex.sentence || "",
          currentLabelText || currentLabel || ""
        );
        guidanceDiv.appendChild(guidanceLabel);
        guidanceDiv.appendChild(guidanceText);
      } else {
        guidanceDiv.style.display = "none";
      }

      const exampleMetaDiv = document.createElement("div");
      exampleMetaDiv.className = "example-meta";
      exampleMetaDiv.textContent = `Issue ${currentIndex + 1} of ${rotationExamples.length}`;

      const rewriteTextarea = document.createElement("textarea");
      rewriteTextarea.className = "example-rewrite";
      rewriteTextarea.placeholder = "Edit directly here...";
      const originalSentence = ex.sentence || "";
      li.dataset.originalSentence = originalSentence;
      li.dataset.paragraphIndex = String(ex.paragraph_index ?? "");
      li._exampleData = ex;

      const approvedRewrite = approvedRewriteByKey.get(exampleKey);
      const draftRewrite = draftRewriteByKey.get(exampleKey);
      rewriteTextarea.value = approvedRewrite || draftRewrite || originalSentence;
      autosizeTextarea(rewriteTextarea);

      rewriteTextarea.addEventListener("focus", () => {
        cursorHighlightExampleInPreview(ex);
      });
      rewriteTextarea.addEventListener("input", () => {
        cursorHighlightExampleInPreview(ex);
        autosizeTextarea(rewriteTextarea);
        if (exampleKey) {
          draftRewriteByKey.set(exampleKey, rewriteTextarea.value);
        }
        if (exampleKey && (approvedExampleKeys.has(exampleKey) || li.dataset.approvedRewrite)) {
          const applyBtn = li.querySelector(".apply-to-preview-btn");
          revokeApprovedRewrite({
            exampleKey,
            exampleRow: li,
            applyBtn,
            statusDiv: rewriteStatusDiv
          });
        }
      });

      const powerVerbsHelper = buildPowerVerbsHelper(currentLabelText || currentLabel || "", rewriteTextarea);

      const rewriteStatusDiv = document.createElement("div");
      rewriteStatusDiv.className = "rewrite-status";

      const actionsDiv = document.createElement("div");
      actionsDiv.className = "example-actions";

      const resetExampleBtn = document.createElement("button");
      resetExampleBtn.className = "example-btn";
      resetExampleBtn.textContent = "Reset example";
      resetExampleBtn.onclick = () => {
        rewriteTextarea.value = originalSentence;
        autosizeTextarea(rewriteTextarea);
        if (exampleKey) {
          draftRewriteByKey.set(exampleKey, originalSentence);
        }
      };

      const copyRewriteBtn = document.createElement("button");
      copyRewriteBtn.className = "example-btn";
      copyRewriteBtn.textContent = "Copy your rewrite";
      copyRewriteBtn.onclick = () => {
        navigator.clipboard.writeText(rewriteTextarea.value).then(() => {
          copyRewriteBtn.textContent = "Copied!";
          setTimeout(() => copyRewriteBtn.textContent = "Copy your rewrite", 2000);
        });
      };

      const findInPreviewBtn = document.createElement("button");
      findInPreviewBtn.className = "example-btn";
      findInPreviewBtn.textContent = "Find in preview";
      findInPreviewBtn.onclick = () => {
        if (markedPreviewCard.style.display === "none" || !markedPreview || !markedPreview.innerText.trim()) {
          rewriteStatusDiv.textContent = "Click \"Mark my essay\" to load the preview first.";
          rewriteStatusDiv.className = "rewrite-status visible";
          rewriteStatusDiv.classList.remove("ok", "bad");
          return;
        }
        highlightAndScrollToExample(ex, rewriteStatusDiv);
      };

      const checkRewriteBtn = document.createElement("button");
      checkRewriteBtn.className = "example-btn";
      checkRewriteBtn.textContent = "Check rewrite";
      checkRewriteBtn.onclick = async () => {
        await checkRewrite(currentLabel || ex?.label || "", ex, rewriteTextarea, rewriteStatusDiv, checkRewriteBtn);
      };

      const applyToPreviewBtn = document.createElement("button");
      applyToPreviewBtn.className = "example-btn apply-to-preview-btn";
      applyToPreviewBtn.textContent = "Apply to Preview";
      applyToPreviewBtn.disabled = true;
      applyToPreviewBtn.onclick = () => {
        const rewriteText = approvedRewriteByKey.get(exampleKey);
        const applied = applyRewriteToPreviewByKey({
          exampleKey,
          rewriteText,
          exampleData: ex,
          statusDiv: rewriteStatusDiv,
          applyBtn: applyToPreviewBtn,
          exampleRow: li
        });
        if (applied) {
          renderCurrentExample();
          updateApplyAllUI();
        }
      };

      const dismissIssueBtn = document.createElement("button");
      dismissIssueBtn.className = "example-btn example-action remove-issue-btn";
      dismissIssueBtn.textContent = "Dismiss issue";
      dismissIssueBtn.onclick = async () => {
        await dismissIssue(currentLabel || ex?.label || "", ex, rewriteStatusDiv, dismissIssueBtn);
      };

      actionsDiv.appendChild(resetExampleBtn);
      actionsDiv.appendChild(copyRewriteBtn);
      actionsDiv.appendChild(findInPreviewBtn);
      actionsDiv.appendChild(checkRewriteBtn);
      actionsDiv.appendChild(applyToPreviewBtn);
      actionsDiv.appendChild(dismissIssueBtn);

      // Keyboard shortcut: Ctrl+Enter (Windows) / Cmd+Enter (Mac)
      rewriteTextarea.addEventListener("keydown", async (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
          e.preventDefault();
          await checkRewrite(currentLabel || ex?.label || "", ex, rewriteTextarea, rewriteStatusDiv, checkRewriteBtn);
        }
      });

      if (exampleKey && approvedExampleKeys.has(exampleKey) && approvedRewrite) {
        applyToPreviewBtn.disabled = false;
        setApplyAttention(applyToPreviewBtn);
      }

      li.appendChild(guidanceDiv);
      li.appendChild(exampleMetaDiv);
      li.appendChild(rewriteTextarea);
      if (powerVerbsHelper) li.appendChild(powerVerbsHelper);
      li.appendChild(rewriteStatusDiv);
      li.appendChild(actionsDiv);

      examplesList.appendChild(li);
      updateExampleNav(rotationExamples.length);
      updateApplyAllUI();
      renderApprovedRewritesList();
      updateAllApprovedBanner(currentExamplesAll);
    }

    function refreshIssueCountUI() {
      if (!lastRevisionSectionData || !issueSelect) return;

      lastRevisionSectionData.labelCounts = { ...liveLabelCounts };
      renderIssueButtonsFromSectionData(
        lastRevisionSectionData,
        lastRevisionSectionData.sectionOrder
      );

      const currentIssueId = currentLabel ? getIssueIdForLabel(currentLabel) : "";
      const sortedLabels = Object.entries(liveLabelCounts)
        .filter(([, count]) => (count || 0) > 0)
        .sort((a, b) => (b[1] || 0) - (a[1] || 0))
        .map(([label]) => String(label || "").trim())
        .filter(Boolean);

      issueSelect.innerHTML = '<option value="">Select an issue...</option>';
      sortedLabels.forEach((label) => {
        const option = document.createElement("option");
        const issueId = getIssueIdForLabel(label);
        option.value = issueId;
        option.dataset.issueLabel = label;
        const count = liveLabelCounts[label] || 0;
        option.textContent = `${label} (${count})`;
        issueSelect.appendChild(option);
      });

      if (currentIssueId && liveLabelCounts[currentLabel]) {
        issueSelect.value = currentIssueId;
      }
    }

    function clearFile() {
      // Safety: stop any in-progress button loader
      stopButtonLoading(checkBtn, () => !!selectedFile);
      showMarkButtonHideRecheck();
      if (resultsCard) resultsCard.style.display = "none";
      if (form) form.classList.remove("has-results");
      selectedFile = null;
      hasStartedRevising = false;
      fileInput.value = "";
      downloadUrl = null;
      markedBlob = null;
      downloadBtn.style.display = "none";
      statusArea.textContent = "";
      statusArea.className = "status-area";
      liveLabelCounts = {};
      resetIssueIdMaps();
      appliedExampleKeys.clear();
      approvedExampleKeys.clear();
      currentLabel = null;
      currentExamplesAll = [];
      currentIndex = 0;
      currentGuidance = "";
      currentLabelText = "";
      draftRewriteByKey.clear();
      approvedRewriteByKey.clear();
      exampleDataByKey.clear();
      examplesByIssueId.clear();
      approvedRewrites.length = 0;
      markedPreviewCard.style.display = "none";
      markedPreview.innerHTML = "";
      resetRevisionPracticeUI();
      issueSelect.innerHTML = '<option value="">Select an issue...</option>';
      if (issueButtonsWrap) issueButtonsWrap.innerHTML = "";
      if (recheckDocumentBtn) recheckDocumentBtn.disabled = true;
      currentMarkEvent = null;
      currentWordCount = null;
      currentTechniques = [];
      detectedWork = null;
      if (statsPanel) statsPanel.style.display = "none";
      if (wordCountStat) wordCountStat.textContent = "â€”";
      if (totalIssuesStat) totalIssuesStat.textContent = "â€”";
      if (topIssueRow) topIssueRow.style.display = "none";
      if (topIssueStat) topIssueStat.textContent = "";
      if (techniquesStatWrap) techniquesStatWrap.style.display = "none";
      if (techniquesStatList) techniquesStatList.textContent = "";
      // Hide + reset Most Common Issues chart
      if (mostCommonIssuesWrap) mostCommonIssuesWrap.style.display = "none";
      if (mostCommonIssuesChart) {
        mostCommonIssuesChart.destroy();
        mostCommonIssuesChart = null;
      }
      renderMetrics(null);

      updateFileUI();
    }

    clearFileBtn.addEventListener("click", clearFile);

    // Click drop zone to open file picker
    dropZone.addEventListener("click", () => fileInput.click());

    dropZone.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        fileInput.click();
      }
    });

    // ===== Extract metadata from docx =====
    
    // Helper: Strip HTML tags and get plain text
    function stripTags(html) {
      const tmp = document.createElement("div");
      tmp.innerHTML = html;
      return tmp.textContent || tmp.innerText || "";
    }
    
    // Helper: Normalize typography (curly quotes to straight quotes, non-breaking spaces, whitespace)
    function normalizeTypography(s) {
      return (s || "")
        .replace(/\r\n/g, "\n")
        .replace(/\u00A0/g, " ")
        // smart double quotes + guillemets â†’ "
        .replace(/[\u201C\u201D\u201E\u201F\u00AB\u00BB]/g, '"')
        // smart single quotes/apostrophes â†’ '
        .replace(/[\u2018\u2019\u201A\u201B]/g, "'")
        // primes sometimes appear as quotes
        .replace(/[\u2032\u2035]/g, "'")
        .replace(/[\u2033\u2036]/g, '"')
        // normalize dashes
        .replace(/[\u2013\u2014]/g, "-")
        .replace(/\s+/g, " ")
        .trim();
    }

    function normalizeTypographyPreserveParagraphs(s) {
      let t = (s || "")
        .replace(/\r\n/g, "\n")
        .replace(/\u00A0/g, " ")
        // smart double quotes + guillemets â†’ "
        .replace(/[\u201C\u201D\u201E\u201F\u00AB\u00BB]/g, '"')
        // smart single quotes/apostrophes â†’ '
        .replace(/[\u2018\u2019\u201A\u201B]/g, "'")
        // primes sometimes appear as quotes
        .replace(/[\u2032\u2035]/g, "'")
        .replace(/[\u2033\u2036]/g, '"')
        // normalize dashes
        .replace(/[\u2013\u2014]/g, "-");

      // Collapse horizontal whitespace but preserve newlines
      t = t.replace(/[ \t]+/g, " ");
      // Trim spaces around newlines
      t = t.replace(/[ \t]*\n[ \t]*/g, "\n");
      // Normalize paragraph separators: 3+ newlines -> 2 newlines
      t = t.replace(/\n{3,}/g, "\n\n");
      return t.trim();
    }
    
    // Helper: Normalize punctuation (curly quotes/apostrophes to straight ones, non-breaking spaces)
    function normalizePunct(s) {
      // keep legacy callsites; normalizeTypography already handles quotes/apostrophes
      return normalizeTypography(s);
    }
    
    // Helper: Check if a period is part of an initial or abbreviation
    function isInitialOrAbbrevDot(t, i) {
      if (t[i] !== ".") return false;
      const before = t.slice(0, i + 1);
      const after = t.slice(i + 1);

      // single-letter initial: "F." "M." etc, followed by space + capital
      if (/\b[A-Z]\.$/.test(before) && /^\s+[A-Z]/.test(after)) return true;

      // common abbrevs
      if (/\b(?:Mr|Ms|Mrs|Dr|Prof|Sr|Jr|St)\.$/.test(before) && /^\s+[A-Z]/.test(after)) return true;

      // U.S. / U.K. style
      if (/\b[A-Z]\.[A-Z]\.$/.test(before) && /^\s+[A-Z]/.test(after)) return true;

      return false;
    }

    // Helper: Find the index of the sentence end, accounting for quotes and initials
    function findSentenceEndIndex(text) {
      const t = normalizeTypography(text);
      let inQuotes = false;

      for (let i = 0; i < t.length; i++) {
        const ch = t[i];

        // IMPORTANT: only treat double quotes as quotes. Never treat apostrophe as a quote delimiter.
        if (ch === '"') inQuotes = !inQuotes;
        if (inQuotes) continue;

        if (ch === "." || ch === "!" || ch === "?") {
          if (ch === "." && isInitialOrAbbrevDot(t, i)) continue;
          return i;
        }
      }
      return -1;
    }

    // Helper: Check if text has sentence-ending punctuation
    function hasSentenceEnd(text) {
      return findSentenceEndIndex(text) !== -1;
    }
    
    // Helper: Check if text looks like a student essay-title header format
    function isEssayTitleHeaderLine(text) {
      const s = normalizeTypography(text);
      // "Quotation": Topic in Essay Title
      return /^"[^"]+"\s*:\s*.+/.test(s) && !hasSentenceEnd(s);
    }
    
    // Helper: Check if text looks like a header or title line (not an intro sentence)
    function isLikelyHeaderOrTitle(text) {
      const plainText = normalizeTypography(text);
      
      // First check: Skip student essay-title header format
      if (isEssayTitleHeaderLine(plainText)) {
        return true;
      }
      
      // 1) ANY paragraph without sentence-ending punctuation is likely a header/title
      // (unless it's extremely long, which suggests it's actual content)
      if (!hasSentenceEnd(plainText) && plainText.length <= 220) {
        return true;
      }
      
      // Keep the old check for backward compatibility with very short lines
      if (plainText.length <= 80 && !hasSentenceEnd(plainText)) {
        return true;
      }
      
      // 2) Looks like a date line
      if (/\b\d{1,2}\/\d{1,2}(\/\d{2,4})?\b/.test(plainText)) {
        return true;
      }
      const monthMatch = /\b(january|february|march|april|may|june|july|august|september|october|november|december)\b/i.test(plainText);
      if (monthMatch && /\d/.test(plainText)) {
        return true;
      }
      
      // 3) Looks like a teacher/class line
      if (/\b(Mr\.|Ms\.|Mrs\.|Dr\.|Professor|Prof\.)\b/i.test(plainText)) {
        return true;
      }
      
      // 4) Looks like a student name line (1-4 tokens, all Title Case, no punctuation, no digits)
      const tokens = plainText.split(/\s+/).filter(t => t.length > 0);
      if (tokens.length >= 1 && tokens.length <= 4) {
        const allTitleCase = tokens.every(t => /^[A-Z][a-z]*$/.test(t));
        const noDigits = !/\d/.test(plainText);
        const noSentencePunct = !/[.!?]/.test(plainText);
        if (allTitleCase && noDigits && noSentencePunct) {
          return true;
        }
      }
      
      // 5) Looks like "Homework / Essay / Paper / Assignment" heading
      if (/^(homework|essay|paper|assignment)\b/i.test(plainText)) {
        return true;
      }
      
      return false;
    }
    
    // Helper: Count words in text
    function countWords(text) {
      const words = (text || "").match(/\b[A-Za-z]+\b/g) || [];
      return words.length;
    }
    
    // Helper: Clean title by removing surrounding quotes and trailing punctuation
    function cleanTitle(t) {
      t = normalizeTypography(t);
      t = t.replace(/^[\"']+/, "").replace(/[\"']+$/, "");
      // strip common trailing punctuation that's inside quotes in prose
      t = t.replace(/[,\.;:]+$/g, "");
      return t.trim();
    }
    
    // Helper: Extract first sentence from plain text
    function getFirstSentence(text) {
      const t = normalizeTypography(text);
      const idx = findSentenceEndIndex(t);
      return idx === -1 ? t : t.slice(0, idx + 1).trim();
    }
    
    async function extractMetaFromDocx(file) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        const result = await mammoth.convertToHtml({ arrayBuffer });
        const html = result.value;
        
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        
        // Parse HTML into a list of paragraphs with metadata
        const paras = Array.from(doc.querySelectorAll("p"))
          .map(p => {
            const html = p.innerHTML.trim();
            const plain = stripTags(html).trim();
            return {
              html,
              plain,
              wordCount: countWords(plain)
            };
          })
          .filter(p => p.plain.length > 0);
        
        if (paras.length === 0) return null;
        
        // Find the intro paragraph using priority selection:
        // A) First paragraph that: NOT header/title AND has sentence end AND >= 8 words
        // B) First paragraph that: NOT header/title AND has sentence end AND >= 5 words
        // C) First paragraph that: NOT header/title (but still requires sentence end)
        let introParagraphHtml = null;
        let introParagraphPlain = null;
        
        // Priority A: >= 8 words with sentence end
        for (const para of paras) {
          if (isLikelyHeaderOrTitle(para.plain)) continue;
          if (hasSentenceEnd(para.plain) && para.wordCount >= 8) {
            introParagraphHtml = para.html;
            introParagraphPlain = para.plain;
            break;
          }
        }
        
        // Priority B: >= 5 words with sentence end
        if (!introParagraphHtml) {
          for (const para of paras) {
            if (isLikelyHeaderOrTitle(para.plain)) continue;
            if (hasSentenceEnd(para.plain) && para.wordCount >= 5) {
              introParagraphHtml = para.html;
              introParagraphPlain = para.plain;
              break;
            }
          }
        }
        
        // Priority C: Any non-header paragraph with sentence end
        if (!introParagraphHtml) {
          for (const para of paras) {
            if (isLikelyHeaderOrTitle(para.plain)) continue;
            if (hasSentenceEnd(para.plain)) {
              introParagraphHtml = para.html;
              introParagraphPlain = para.plain;
              break;
            }
          }
        }
        
        if (!introParagraphHtml || !introParagraphPlain) {
          return null;
        }
        
        // IMPORTANT: Split intro paragraph on <br> if present to isolate intro sentence
        // Mammoth sometimes outputs student title + intro sentence in the same <p>
        let introSentenceHtml = introParagraphHtml;
        let selectedSegmentPlain = introParagraphPlain;
        
        // Split into segments by <br>
        const frag = document.createElement("div");
        frag.innerHTML = introParagraphHtml;
        
        const segments = [];
        let buf = [];
        
        // Walk through child nodes and split on <br>
        frag.childNodes.forEach(node => {
          if (node.nodeName === "BR") {
            if (buf.length > 0) {
              segments.push(buf);
              buf = [];
            }
          } else {
            buf.push(node);
          }
        });
        if (buf.length > 0) {
          segments.push(buf);
        }
        
        // If we found segments (meaning there were <br> tags), try to pick the first real sentence
        if (segments.length > 1) {
          let selectedSegment = null;
          
          // Priority 1: First segment with sentence end AND >= 8 words
          for (const buf of segments) {
            const segDiv = document.createElement("div");
            buf.forEach(n => {
              try {
                segDiv.appendChild(n.cloneNode(true));
              } catch (e) {
                // Skip nodes that can't be cloned (e.g., some text nodes)
              }
            });
            const segHtml = segDiv.innerHTML.trim();
            const segPlain = stripTags(segHtml).trim();
            
            // Skip essay title header segments
            if (isEssayTitleHeaderLine(segPlain)) continue;
            if (isLikelyHeaderOrTitle(segPlain)) continue;
            
            const wc = countWords(segPlain);
            
            if (hasSentenceEnd(segPlain) && wc >= 8) {
              selectedSegment = { html: segHtml, plain: segPlain };
              break;
            }
          }
          
          // Priority 2: First segment with sentence end AND >= 5 words
          if (!selectedSegment) {
            for (const buf of segments) {
              const segDiv = document.createElement("div");
              buf.forEach(n => {
                try {
                  segDiv.appendChild(n.cloneNode(true));
                } catch (e) {
                  // Skip nodes that can't be cloned
                }
              });
              const segHtml = segDiv.innerHTML.trim();
              const segPlain = stripTags(segHtml).trim();
              
              // Skip essay title header segments
              if (isEssayTitleHeaderLine(segPlain)) continue;
              if (isLikelyHeaderOrTitle(segPlain)) continue;
              
              const wc = countWords(segPlain);
              
              if (hasSentenceEnd(segPlain) && wc >= 5) {
                selectedSegment = { html: segHtml, plain: segPlain };
                break;
              }
            }
          }
          
          // If we found a selected segment, use it
          if (selectedSegment) {
            introSentenceHtml = selectedSegment.html;
            selectedSegmentPlain = selectedSegment.plain;
          }
          // Otherwise, fallback to whole paragraph (already set above)
        }
        
        // Extract first sentence from the selected segment
        const firstSentencePlain = getFirstSentence(selectedSegmentPlain);
        const firstSentenceNorm = normalizeTypography(firstSentencePlain);
        
        let detectedTitle = null;
        let detectedAuthor = null;
        let isMinor = true;
        
        // Extract title from intro sentence segment ONLY (not from essay title line)
        const frag2 = document.createElement("div");
        frag2.innerHTML = introSentenceHtml;
        
        // Helper: Check if element or any ancestor is italic
        function isItalicAncestor(el) {
          let current = el;
          while (current && current !== frag2) {
            if (current.nodeType === Node.ELEMENT_NODE) {
              const tagName = current.tagName?.toLowerCase();
              if (tagName === "em" || tagName === "i") return true;
              const style = current.style?.fontStyle || window.getComputedStyle(current).fontStyle;
              if (style && style.includes("italic")) return true;
            }
            current = current.parentNode;
          }
          return false;
        }
        
        // Collect italic phrases using TreeWalker
        const italicPhrases = [];
        const walker = document.createTreeWalker(
          frag2,
          NodeFilter.SHOW_TEXT,
          null
        );
        
        let currentPhrase = "";
        let node = walker.nextNode();
        
        while (node) {
          const isItalic = isItalicAncestor(node);
          const text = node.textContent || "";
          
          if (isItalic) {
            // Add text to current phrase
            currentPhrase += text;
          } else {
            // Non-italic node
            if (currentPhrase) {
              // If we have a phrase building, check if this is whitespace between italic nodes
              if (text.trim() === "" && text.length > 0) {
                // Single whitespace-only node between italic nodes - add space and continue
                currentPhrase += " ";
              } else {
                // Non-whitespace or empty - finalize the phrase
                if (currentPhrase.trim()) {
                  italicPhrases.push(currentPhrase);
                }
                currentPhrase = "";
              }
            }
          }
          
          node = walker.nextNode();
        }
        
        // Don't forget the last phrase if we ended in italic text
        if (currentPhrase.trim()) {
          italicPhrases.push(currentPhrase);
        }
        
        // Filter and normalize phrases
        const validPhrases = italicPhrases
          .map(p => normalizeTypography(p).trim())
          .filter(p => {
            if (p.length < 2 || p.length > 160) return false;
            // Not just punctuation/quotes
            if (/^[^\w]+$/.test(p)) return false;
            return true;
          });
        
        // Pick best phrase (prefer longest; tie-breaker: more Title-Cased words)
        if (validPhrases.length > 0) {
          function countTitleCaseWords(s) {
            const words = s.match(/\b[A-Z][a-z]+\b/g) || [];
            return words.length;
          }
          
          validPhrases.sort((a, b) => {
            if (b.length !== a.length) return b.length - a.length;
            return countTitleCaseWords(b) - countTitleCaseWords(a);
          });
          
          detectedTitle = cleanTitle(validPhrases[0]);
          isMinor = false;
        }
        
        // If no italics, check for quoted text (Minor work)
        if (!detectedTitle) {
          const quoted = Array.from(firstSentenceNorm.matchAll(/"([^"]+)"/g))
            .map(m => ({
              text: (m[1] || "").trim(),
              idx: m.index ?? 0
            }))
            .filter(x => x.text && x.text.length >= 2 && x.text.length <= 120);

          if (quoted.length) {
            // Prefer a quote that looks like a work title in context:
            // e.g., "essay "Title"", "article "Title"", "novel "Title"", etc.
            const workWords = /(essay|article|novel|poem|short story|story|play|film|movie|book|chapter|speech|song|album)\b/i;

            const hasNonQuestion = quoted.some(q => !q.text.includes("?"));

            function scoreCandidate(q) {
              const left = firstSentenceNorm.slice(Math.max(0, q.idx - 45), q.idx);
              let score = 0;

              if (workWords.test(left)) score += 10;         // strongest signal
              if (q.idx < firstSentenceNorm.length / 2) score += 2; // earlier is better

              // Questions are often quoted prompts, not titles (but allow if it's the only option)
              if (q.text.includes("?") && hasNonQuestion) score -= 6;

              return score;
            }

            quoted.sort((a, b) => scoreCandidate(b) - scoreCandidate(a) || a.idx - b.idx);

            detectedTitle = cleanTitle(quoted[0].text);
            isMinor = true;
          }
        }
        
        // Extract author from first sentence
        const NAME_STOPWORDS = new Set([
          "In","On","At","From","With","Without","By","For","To","As",
          "When","While","After","Before","During","Since","Because","Although","Though",
          "The","A","An","This","That","These","Those"
        ]);

        function cleanPossessive(tok) {
          return tok.replace(/['']s$/, "");
        }
        
        function isNameToken(tok) {
          if (!tok) return false;
          if (NAME_STOPWORDS.has(tok)) return false;

          // Initial: "F."
          if (/^[A-Z]\.$/.test(tok)) return true;

          // Single capital (rare but allow)
          if (/^[A-Z]$/.test(tok)) return true;

          // Name word: "Richard", "Selzer", "O'Connor", "Mary-Jane"
          if (/^[A-Z][a-z]+(?:[''][A-Z][a-z]+)?(?:-[A-Z][a-z]+(?:[''][A-Z][a-z]+)?)*$/.test(tok)) return true;

          return false;
        }

        function cleanAuthorName(s) {
          s = normalizeTypography(s);
          const parts = s.split(/\s+/).filter(Boolean);
          while (parts.length > 1 && NAME_STOPWORDS.has(parts[0])) parts.shift();
          return parts.join(" ");
        }
        
        function extractProperNounName(sentence, detectedTitle) {
          const toks = (sentence.match(/[A-Za-z'.-]+/g) || []).filter(Boolean);
          const titleKey = (detectedTitle || "").toLowerCase().replace(/[^a-z]+/g, " ").trim();
          const titleWords = new Set(titleKey.split(/\s+/).filter(Boolean));
          
          const candidates = [];
          let run = [];
          
          for (const raw of toks) {
            const tok = cleanPossessive(raw);
            // Skip stopwords at the start of a run
            if (run.length === 0 && NAME_STOPWORDS.has(tok)) continue;
            if (isNameToken(raw)) {
              run.push(tok);
              if (run.length > 6) run.shift();
            } else {
              if (run.length >= 2) candidates.push(run.slice());
              run = [];
            }
          }
          if (run.length >= 2) candidates.push(run.slice());
          
          // Filter out candidates that overlap heavily with title words
          const filtered = candidates
            .map(arr => arr.join(" "))
            .filter(name => {
              const words = name.toLowerCase().split(/\s+/);
              const overlap = words.filter(w => titleWords.has(w)).length;
              return overlap === 0;
            });
          
          if (filtered.length > 0) {
            const result = filtered[0];
            // Remove leading stopword if present
            const parts = result.split(/\s+/);
            if (parts.length > 1 && NAME_STOPWORDS.has(parts[0])) {
              return parts.slice(1).join(" ");
            }
            return result;
          }
          return null;
        }

        // Priority: possessive anywhere (best for "In Richard Selzer's â€¦")
        const NAME_TOKEN = "(?:[A-Z]\\.|[A-Z][a-z]+(?:[''][A-Z][a-z]+)?(?:-[A-Z][a-z]+(?:[''][A-Z][a-z]+)?)*)";
        const NAME_RUN = `${NAME_TOKEN}(?:\\s+${NAME_TOKEN}){0,6}`;

        let possMatches = Array.from(firstSentenceNorm.matchAll(new RegExp(`\\b(${NAME_RUN})['']s\\b`, "g")));
        if (possMatches.length) {
          // choose longest then earliest
          possMatches.sort((a,b) => b[1].split(/\s+/).length - a[1].split(/\s+/).length || (a.index ?? 0) - (b.index ?? 0));
          detectedAuthor = cleanAuthorName(possMatches[0][1]);
        }

        // Next: "by Author"
        if (!detectedAuthor) {
          const by = firstSentenceNorm.match(new RegExp(`\\b[Bb]y\\s+(${NAME_RUN})\\b`));
          if (by) detectedAuthor = cleanAuthorName(by[1]);
        }

        // Fallback: improved proper-noun run extraction
        if (!detectedAuthor) {
          detectedAuthor = extractProperNounName(firstSentenceNorm, detectedTitle);
        }
        
        // Sanity tests (non-breaking)
        try {
          // Test: getFirstSentence should not stop at initials
          const test1 = getFirstSentence("In F. Scott Fitzgerald's novel \"The Great Gatsby,\" ...");
          console.assert(test1.includes("Fitzgerald"), "getFirstSentence should include Fitzgerald and not stop at F.");
          
          // Test: possessive author extraction works for curly apostrophe
          const test2Norm = normalizeTypography("In Richard Selzer's story \"The Knife,\" ...");
          const test2Matches = Array.from(test2Norm.matchAll(new RegExp(`\\b(${NAME_RUN})['']s\\b`, "g")));
          console.assert(test2Matches.length > 0 && test2Matches[0][1].includes("Selzer"), "Possessive author extraction should work for curly apostrophe");
          
          // Test: quoted title extraction works for curly quotes
          const test3Norm = normalizeTypography("In \"The Knife,\" Richard Selzer...");
          const test3Quoted = Array.from(test3Norm.matchAll(/"([^"]+)"/g));
          console.assert(test3Quoted.length > 0, "Quoted title extraction should work for curly quotes after normalization");
        } catch (testError) {
          // Silently ignore test errors to not break production
        }
        
        // Calculate word count: sum wordCount for paragraphs that are NOT header/title
        let wordCount = 0;
        for (const para of paras) {
          if (!isLikelyHeaderOrTitle(para.plain)) {
            wordCount += para.wordCount;
          }
        }
        
        return { title: detectedTitle, author: detectedAuthor, isMinor, wordCount };
      } catch (error) {
        console.error("Error extracting metadata:", error);
        return null;
      }
    }

    // File selection
    fileInput.addEventListener("change", async (e) => {
      const files = e.target.files;
      if (files && files.length > 0) {
        selectedFile = files[0];
        if (statsPanel) statsPanel.style.display = "none";
        loadDismissedIssuesFromStorage();
        updateFileUI();
        showMarkButtonHideRecheck();

        const meta = await extractMetaFromDocx(selectedFile);
        detectedWork = null;
        if (meta?.title && meta?.author) {
          detectedWork = {
            author: meta.author,
            title: meta.title,
            isMinor: !!meta.isMinor,
            confidence: "high"
          };
        } else if (meta?.title || meta?.author) {
          detectedWork = {
            author: meta?.author || "",
            title: meta?.title || "",
            isMinor: !!meta?.isMinor,
            confidence: "low"
          };
        }
        if (meta && meta.wordCount !== undefined) {
          currentWordCount = meta.wordCount;
          updateStatsPanel(liveLabelCounts);
        }
        startPostUploadTour();
      }
    });

    // Global file drag/drop guard:
    // - Prevent browser from opening/navigating to dropped files anywhere on the page.
    // - Only allow our custom handling when the drop target is inside #dropZone.
    // - Use capture phase so we intercept before the browser/default handlers.
    function isFileDragEvent(e) {
      const dt = e.dataTransfer;
      if (!dt) return false;

      // "Files" appears in types during file drag in most browsers
      const types = dt.types ? Array.from(dt.types) : [];
      if (types.includes("Files")) return true;

      // Fallback (some browsers/devtools quirks)
      return !!(dt.files && dt.files.length);
    }

    function isInsideDropZone(target) {
      return dropZone && target instanceof Node && dropZone.contains(target);
    }

    function guardFileDnD(e) {
      // Only interfere with file drags/drops (do not break text dragging inside inputs)
      if (!isFileDragEvent(e)) return;

      // Always cancel default so the browser never opens/navigates to the file
      e.preventDefault();

      // If NOT inside the dropZone, block any other handlers too
      if (!isInsideDropZone(e.target)) {
        e.stopPropagation();

        // Optional UX hint: show "not allowed" cursor on dragover
        if (e.type === "dragover") {
          try { e.dataTransfer.dropEffect = "none"; } catch (_) {}
        }
      }
    }

    // Capture phase + passive:false so preventDefault always works.
    ["dragenter", "dragover", "drop"].forEach((evt) => {
      window.addEventListener(evt, guardFileDnD, { capture: true, passive: false });
    });

    // Drag & drop
    ["dragenter", "dragover"].forEach(evt => {
      dropZone.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.add("dragover");
      });
    });

    ["dragleave", "dragend"].forEach(evt => {
      dropZone.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove("dragover");
      });
    });

    dropZone.addEventListener("drop", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      dropZone.classList.remove("dragover");

      if (e.dataTransfer && e.dataTransfer.files) {
        const files = Array.from(e.dataTransfer.files);
        const docxFiles = files.filter(f => /\.docx$/i.test(f.name));
        if (docxFiles.length > 1) {
          statusArea.textContent = "Please drop only one .docx file.";
          statusArea.className = "status-area error";
          return;
        }
        const docxFile = docxFiles[0];
        if (docxFile) {
          selectedFile = docxFile;
          if (statsPanel) statsPanel.style.display = "none";
          loadDismissedIssuesFromStorage();
          // Update file input programmatically
          const dt = new DataTransfer();
          dt.items.add(docxFile);
          fileInput.files = dt.files;
          updateFileUI();
          showMarkButtonHideRecheck();

          const meta = await extractMetaFromDocx(selectedFile);
          detectedWork = null;
          if (meta?.title && meta?.author) {
            detectedWork = {
              author: meta.author,
              title: meta.title,
              isMinor: !!meta.isMinor,
              confidence: "high"
            };
          } else if (meta?.title || meta?.author) {
            detectedWork = {
              author: meta?.author || "",
              title: meta?.title || "",
              isMinor: !!meta?.isMinor,
              confidence: "low"
            };
          }
          if (meta && meta.wordCount !== undefined) {
            currentWordCount = meta.wordCount;
            updateStatsPanel(liveLabelCounts);
          }
          startPostUploadTour();
        } else {
          statusArea.textContent = "Please upload a .docx file.";
          statusArea.className = "status-area error";
        }
      }
    });

    // ===== Form submission =====
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      resetRevisionPracticeUI();
      if (statsPanel) statsPanel.style.display = "none";

      if (!selectedFile) {
        statusArea.textContent = "Please select a .docx file.";
        statusArea.className = "status-area error";
        if (resultsCard) resultsCard.style.display = "block";
        return;
      }

      // Get session
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        statusArea.textContent = "You must be logged in.";
        statusArea.className = "status-area error";
        if (resultsCard) resultsCard.style.display = "block";
        return;
      }

      const formData = buildMarkFormData({ includeSummaryTable: false });
      if (!formData) {
        statusArea.textContent = "Please select a .docx file.";
        statusArea.className = "status-area error";
        if (resultsCard) resultsCard.style.display = "block";
        return;
      }

      // Update UI (donâ€™t show Uploading... in Results; show it on the button instead)
      if (resultsCard) resultsCard.style.display = "none";
      if (form) form.classList.remove("has-results");
      statusArea.textContent = "";
      statusArea.className = "status-area";
      downloadBtn.style.display = "none";
      if (mostCommonIssuesWrap) mostCommonIssuesWrap.style.display = "none";
      if (mostCommonIssuesChart) {
        mostCommonIssuesChart.destroy();
        mostCommonIssuesChart = null;
      }
      startButtonLoading(checkBtn, "Mark my essay");

      try {
        // Call API
        const API_URL = "https://vysti-rules.onrender.com/mark";
        const response = await fetch(API_URL, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${sessionData.session.access_token}`,
          },
          body: formData,
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(`HTTP ${response.status}: ${text.substring(0, 100)}`);
        }

        const techHeader = response.headers.get("X-Vysti-Techniques");
        if (techHeader) {
          try {
            const parsed = JSON.parse(techHeader);
            currentTechniques = Array.isArray(parsed) ? parsed : [];
          } catch (err) {
            console.warn("Failed to parse techniques header:", err);
            currentTechniques = [];
          }
        } else {
          currentTechniques = [];
        }

        const blob = await response.blob();
        markedBlob = blob;
        downloadUrl = URL.createObjectURL(blob);
        
        const baseName = selectedFile.name.replace(/\.docx$/i, "");
        downloadBtn.onclick = async () => {
          if (!selectedFile || !markedPreview) return;

          const previewText = extractPreviewText();
          if (!previewText) {
            statusArea.textContent = "Could not extract text from preview.";
            statusArea.className = "status-area error";
            if (resultsCard) resultsCard.style.display = "block";
            return;
          }

          startButtonLoading(downloadBtn, "Download marked essay");
          try {
            const { data: sessionData } = await supa.auth.getSession();
            if (!sessionData || !sessionData.session) {
              throw new Error("You must be logged in.");
            }

            const currentMode = modeSelect ? modeSelect.value : "textual_analysis";
            const API_BASE = "https://vysti-rules.onrender.com";
            const markTextPayload = {
              file_name: selectedFile.name,
              text: previewText,
              mode: currentMode,
              highlight_thesis_devices: false,
              include_summary_table: true,
              student_mode: true,
            };
            if (detectedWork && detectedWork.confidence === "high") {
              markTextPayload.titles = [{
                author: detectedWork.author,
                title: detectedWork.title,
                is_minor: detectedWork.isMinor
              }];
            }
            const response = await fetch(`${API_BASE}/mark_text`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${sessionData.session.access_token}`,
              },
              body: JSON.stringify(markTextPayload),
            });

            if (!response.ok) {
              const text = await response.text();
              throw new Error(`HTTP ${response.status}: ${text.substring(0, 100)}`);
            }

            const downloadBlob = await response.blob();
            const tempUrl = URL.createObjectURL(downloadBlob);
            const a = document.createElement("a");
            a.href = tempUrl;
            a.download = `${baseName}_marked.docx`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(tempUrl), 0);
          } catch (error) {
            console.error("Error generating download:", error);
            statusArea.textContent = `Error: ${error.message}`;
            statusArea.className = "status-area error";
            if (resultsCard) resultsCard.style.display = "block";
          } finally {
            stopButtonLoading(downloadBtn, () => true);
          }
        };

        // Render marked essay preview
        try {
          markedPreview.innerHTML = "";
          const buf = await blob.arrayBuffer();
          if (typeof docx !== "undefined" && docx.renderAsync) {
            await docx.renderAsync(buf, markedPreview, null, { inWrapper: true });
            removeRewritePracticeTagsFromPreview(markedPreview);
            // Make preview editable
            markedPreview.contentEditable = "true";
            markedPreview.spellcheck = true;
            markedPreview.classList.add("preview-editable");
            applyPreviewZoom();
            updateStatsPanel(liveLabelCounts);
            await refreshStudentMetrics();
            applyDismissalsToPreviewDOM();
            makePreviewLabelsClickable();
            markedPreviewCard.style.display = "block";
          } else {
            // Fallback: show message if docx-preview not loaded
            markedPreview.innerHTML = "<p>Preview not available. Please download the file to view.</p>";
            markedPreviewCard.style.display = "block";
            updateStatsPanel(liveLabelCounts);
            await refreshStudentMetrics();
          }
        } catch (previewError) {
          console.error("Error rendering preview:", previewError);
          markedPreview.innerHTML = "<p>Error rendering preview. Please download the file to view.</p>";
          markedPreviewCard.style.display = "block";
          updateStatsPanel(liveLabelCounts);
          await refreshStudentMetrics();
        }

        if (recheckDocumentBtn) {
          recheckDocumentBtn.disabled = false;
        }
        hideMarkButtonShowRecheck();

        hasStartedRevising = false;
        statusArea.textContent = "";
        statusArea.className = "status-area success";
        downloadBtn.style.display = "block";
        if (resultsCard) resultsCard.style.display = "block";
        
        // Load revision practice data
        await loadRevisionPractice();

        const totalIssues = totalIssuesFromLabelCounts(liveLabelCounts);
        if (totalIssues === 0) {
          statusArea.textContent = "Document appears to pass all of Vysti's rules. Ready to download.";
          if (mostCommonIssuesWrap) {
            mostCommonIssuesWrap.style.display = "none";
            mostCommonIssuesWrap.dataset.hasData = "false";
          }
          if (revisionPracticeCard) revisionPracticeCard.style.display = "none";
        }

        ensurePostPreviewTourVisibility();
        startPostPreviewTour();

      } catch (error) {
        console.error("Error:", error);
        statusArea.textContent = `Error: ${error.message}`;
        statusArea.className = "status-area error";
        if (resultsCard) resultsCard.style.display = "block";
      } finally {
        stopButtonLoading(checkBtn, () => !!selectedFile);
      }
    });

    // ===== Revision Practice =====
    // Handle section selection (set up once)
    sectionSelect.addEventListener("change", (e) => {
      const selectedSection = e.target.value;
      const sectionData = window.revisionSectionData;
      
      if (!sectionData) {
        return;
      }
      
      // Clear issue selection when section changes
      issueSelect.value = "";
      if (issueExplanationBlock) issueExplanationBlock.style.display = "none";
      examplesList.innerHTML = "";
      if (approvedRewritesList) approvedRewritesList.innerHTML = "";
      if (approvedRewritesWrap) approvedRewritesWrap.style.display = "none";
      downloadRevisionNotesBtn.style.display = "none";
      approvedRewriteByKey.clear();
      approvedExampleKeys.clear();
      updateApplyAllUI();
      
      // Repopulate issueSelect with labels in selected section
      issueSelect.innerHTML = '<option value="">Select an issue...</option>';
      
      let labelsToShow = [];
      if (!selectedSection || selectedSection === "") {
        // Show all labels
        labelsToShow = Object.keys(sectionData.labelCounts);
      } else {
        // Show labels in selected section
        labelsToShow = sectionData.sectionLabels[selectedSection] || [];
      }
      
      // Sort by count desc
      const sortedLabels = labelsToShow
        .map(label => ({
          label,
          count: sectionData.labelCounts[label] || 0
        }))
        .sort((a, b) => b.count - a.count)
        .map(item => item.label);
      
      sortedLabels.forEach(label => {
        const option = document.createElement("option");
        const issueId = getIssueIdForLabel(label);
        option.value = issueId;
        option.dataset.issueLabel = label;
        const count = sectionData.labelCounts[label] || 0;
        option.textContent = `${label} (${count})`;
        issueSelect.appendChild(option);
      });
    });

    function scrollToExamples() {
      if (!revisionPracticeCard) return;
      const header = revisionPracticeCard.querySelector(".revision-practice-title");
      if (!header) return;
      const topbar = document.querySelector(".topbar");
      const offset = (topbar ? topbar.getBoundingClientRect().height : 0) + 12;
      const y = header.getBoundingClientRect().top + window.scrollY - offset;
      window.scrollTo({ top: y, behavior: "smooth" });
    }

    function scrollToPreviewHeader() {
      const header = document.querySelector("#markedPreviewCard .preview-header");
      if (!header) return;
      const topbar = document.querySelector(".topbar");
      const offset = (topbar ? topbar.getBoundingClientRect().height : 0) + 12;
      const y = header.getBoundingClientRect().top + window.scrollY - offset;
      window.scrollTo({ top: y, behavior: "smooth" });
    }

    function canonicalizePreviewLabel(label) {
      const s = String(label || "").trim();
      if (/^avoid weak verbs\b/i.test(s)) return "Avoid weak verbs";
      return s;
    }

    function extractLabelFromArrowText(text) {
      if (!text) return null;
      const m = String(text).trim().match(/^â†’\s*(.+?)\s*$/);
      if (!m) return null;
      const raw = m[1].trim();
      if (!raw) return null;
      return canonicalizePreviewLabel(raw);
    }

    function onPreviewLabelClick(e) {
      const target = e.target instanceof Element ? e.target : e.target.parentElement;
      if (!target) return;
      const sp = target.closest("span");
      if (!sp) return;

      const txt = (sp.textContent || "").trim();
      if (!/^â†’\s*/.test(txt)) return;

      const label = extractLabelFromArrowText(txt);
      if (!label) return;

      e.preventDefault();
      e.stopPropagation();
      const issueId = getIssueIdForLabel(label);
      void openRevisionExampleFromIssueId(issueId, label);
    }

    function makePreviewLabelsClickable() {
      if (!markedPreview) return;

      if (!markedPreview.dataset.vystiLabelClickBound) {
        markedPreview.addEventListener("click", onPreviewLabelClick, true);
        markedPreview.dataset.vystiLabelClickBound = "1";
      }

      const spans = Array.from(markedPreview.querySelectorAll("span"));
      spans.forEach((sp) => {
        const t = (sp.textContent || "").trim();
        if (!t.includes("â†’")) return;
        if (!/^â†’\s*/.test(t)) return;
        if (t.length > 140) return;
        sp.classList.add("vysti-clickable-label");
        sp.setAttribute("title", "Click to revise this issue");
      });
    }

    async function jumpToPreviewForTopicSentenceIssue() {
      if (!markedPreviewCard || markedPreviewCard.style.display === "none") return;
      if (!markedPreview || !markedPreview.innerText.trim()) return;

      const paras = Array.from(markedPreview.querySelectorAll("p"));
      const targetPara = paras.find((p) => (p.textContent || "").includes('"')) || paras[0];
      if (!targetPara) return;

      const txt = (targetPara.textContent || "").trim();
      if (!txt) return;
      const firstSentence = txt.match(/^(.+?[.!?])\s/)?.[1] || txt;

      clearPreviewHighlights();
      const spans =
        highlightExactTextInElement(targetPara, firstSentence) ||
        highlightAnchoredSentenceInElement(
          targetPara,
          firstSentence,
          buildAnchorCandidates(firstSentence)
        );

      if (Array.isArray(spans)) {
        spans.forEach((span) => span.classList.add("vysti-cursor-highlight"));
      }

      scrollToPreviewHeader();
    }

    async function openRevisionExampleFromIssueId(issueId, fallbackLabel = "") {
      const label = getLabelForIssueId(issueId) || fallbackLabel || "";
      if (!label) {
        console.warn("No examples loaded for issueId:", issueId);
        showExamplesEmptyState("No examples found for this issue yet.");
        updateAllApprovedBanner([]);
        return;
      }
      handlePowerVerbsIssueChange(label);
      if (revisionPracticeCard) revisionPracticeCard.style.display = "block";
      if (issueSelect && issueSelect.value !== issueId) {
        issueSelect.value = issueId;
      }
      updateIssueMetadataForLabel(label);
      if (isPreviewOnlyLabel(label)) {
        currentLabel = label;
        currentExamplesAll = [];
        currentIndex = 0;
        if (examplesList) {
          examplesList.innerHTML = "";
          examplesList.style.display = "none";
        }
        if (allApprovedBanner) {
          allApprovedBanner.style.display = "none";
        }
        if (examplesEmptyState) {
          examplesEmptyState.style.display = "block";
          examplesEmptyState.textContent = getPreviewOnlyMessage(label, "");
        }
        if (approvedRewritesList) approvedRewritesList.innerHTML = "";
        if (approvedRewritesWrap) approvedRewritesWrap.style.display = "none";
        if (downloadRevisionNotesBtn) downloadRevisionNotesBtn.style.display = "none";
        if (exampleNavRow) exampleNavRow.style.display = "none";
        if (applyAllToPreviewBtn) {
          applyAllToPreviewBtn.style.display = "none";
          applyAllToPreviewBtn.disabled = true;
          applyAllToPreviewBtn.classList.remove("apply-attention");
        }
        approvedRewrites.length = 0;
        approvedRewriteByKey.clear();
        approvedExampleKeys.clear();
        updateApplyAllUI();
        requestAnimationFrame(() => {
          void jumpToPreviewForTopicSentenceIssue();
        });
        return;
      }
      if (examplesList) examplesList.style.display = "";
      await loadIssueExamples(label);
      requestAnimationFrame(() => scrollToExamples());
    }
    
    // Handle issue selection (set up once)
    issueSelect.addEventListener("change", async (e) => {
      const selectedIssueId = e.target.value;
      const selectedOption = e.target.selectedOptions ? e.target.selectedOptions[0] : null;
      const selectedLabel = (selectedOption && selectedOption.dataset)
        ? selectedOption.dataset.issueLabel
        : getLabelForIssueId(selectedIssueId);
      handlePowerVerbsIssueChange(selectedLabel);
      if (!selectedIssueId) {
        if (issueExplanationBlock) issueExplanationBlock.style.display = "none";
        examplesList.innerHTML = "";
        if (allApprovedBanner) allApprovedBanner.style.display = "none";
        if (approvedRewritesList) approvedRewritesList.innerHTML = "";
        if (approvedRewritesWrap) approvedRewritesWrap.style.display = "none";
        approvedRewrites.length = 0;
        if (applyAllToPreviewBtn) {
          applyAllToPreviewBtn.style.display = "none";
          applyAllToPreviewBtn.disabled = true;
          applyAllToPreviewBtn.classList.remove("apply-attention");
        }
        approvedRewriteByKey.clear();
        approvedExampleKeys.clear();
        if (exampleNavRow) exampleNavRow.style.display = "none";
        currentLabel = null;
        currentExamplesAll = [];
        currentIndex = 0;
        currentGuidance = "";
        currentLabelText = "";
        downloadRevisionNotesBtn.style.display = "none";
        updateApplyAllUI();
        return;
      }

      await openRevisionExampleFromIssueId(selectedIssueId, selectedLabel || "");
    });

    if (applyAllToPreviewBtn) {
      applyAllToPreviewBtn.addEventListener("click", async () => {
        if (!approvedRewrites.length) return;
        const approvedItems = approvedRewrites.slice();
        for (const item of approvedItems) {
          const exampleKey = item.exampleKey || "";
          const rewriteText = item.rewriteText || "";
          const exampleData = item.examplePayload || exampleDataByKey.get(exampleKey) || null;
          applyRewriteToPreviewByKey({
            exampleKey,
            rewriteText,
            exampleData,
            statusDiv: null,
            applyBtn: null,
            exampleRow: null,
            scroll: false
          });
        }
        currentExamplesAll.forEach((ex) => {
          const key = getExampleKey(ex);
          if (key && appliedExampleKeys.has(key)) {
            setExampleAppliedState(key, true, currentLabel || "");
          }
        });
        renderCurrentExample();
        updateApplyAllUI();
        updateAllApprovedBanner(currentExamplesAll);
        await refreshStudentMetrics();
      });
    }

    if (nextExampleBtn) {
      nextExampleBtn.addEventListener("click", () => {
        const rotation = getRotationExamples();
        if (!rotation.length) return;
        currentIndex = (currentIndex + 1) % rotation.length;
        renderCurrentExample();
      });
    }

    let activeIssueBtn = null;

    function renderIssueButtonsFromSectionData(sectionData, sectionOrder) {
      if (!issueButtonsWrap) return;
      issueButtonsWrap.innerHTML = "";
      activeIssueBtn = null;

      if (!sectionData || !sectionData.sectionLabels || !sectionData.labelCounts) {
        return;
      }

      const labelCounts = sectionData.labelCounts || {};
      const sectionLabels = sectionData.sectionLabels || {};

      const order = Array.isArray(sectionOrder) && sectionOrder.length
        ? sectionOrder
        : Object.keys(sectionLabels);

      order.forEach((sectionName) => {
        const labels = (sectionLabels[sectionName] || []).slice();
        if (!labels.length) return;

        // Sort issues within the section by count desc
        labels.sort((a, b) => (labelCounts[b] || 0) - (labelCounts[a] || 0));

        const block = document.createElement("div");
        block.className = "issue-section-block";

        const heading = document.createElement("div");
        heading.className = "issue-section-heading";
        heading.textContent = sectionName;

        const row = document.createElement("div");
        row.className = "issue-button-row";

        labels.forEach((label) => {
          const count = labelCounts[label] || 0;
          if (count <= 0) return;
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "issue-btn";
          btn.classList.add("tt");
          btn.setAttribute("data-tip", "Click to see example");
          const issueId = getIssueIdForLabel(label);
          btn.dataset.issueId = issueId;
          btn.dataset.issueLabel = label;

          btn.textContent = `${label} (${count})`;
          const bucketId = getBucketIdForLabel(label);
          btn.dataset.bucketId = bucketId;
          btn.style.setProperty("--issue-border", getBucketColor(bucketId, 1.0));
          btn.style.setProperty("--issue-bg", getBucketColor(bucketId, 0.12));
          btn.style.setProperty("--issue-bg-hover", getBucketColor(bucketId, 0.18));
          btn.style.setProperty("--issue-ring", getBucketColor(bucketId, 0.22));

          btn.addEventListener("click", () => {
            // Active style
            if (activeIssueBtn) activeIssueBtn.classList.remove("active");
            activeIssueBtn = btn;
            activeIssueBtn.classList.add("active");

            // Ensure issueSelect contains ALL labels so any button can work
            if (sectionSelect) {
              sectionSelect.value = "";
              sectionSelect.dispatchEvent(new Event("change"));
            }

            // Trigger existing issueSelect flow (loads explanation + examples)
            if (issueSelect) {
              issueSelect.value = issueId;
              issueSelect.dispatchEvent(new Event("change"));
            }
          });

          row.appendChild(btn);
        });

        block.appendChild(heading);
        block.appendChild(row);
        issueButtonsWrap.appendChild(block);
      });

      auditRevisionIssueBindings({ source: "buttons" });
    }

    // Wrap text for tooltip display
    function wrapTooltipText(text, maxLineLen = 70) {
      const words = text.split(/\s+/).filter(Boolean);
      const lines = [];
      let line = "";
      for (const w of words) {
        const test = line ? line + " " + w : w;
        if (test.length > maxLineLen) {
          if (line) lines.push(line);
          line = w;
        } else {
          line = test;
        }
      }
      if (line) lines.push(line);
      return lines;
    }

    function firstSentence(text) {
      const t = String(text || "").replace(/\s+/g, " ").trim();
      if (!t) return "";
      const m = t.match(/^(.+?[.!?])(\s|$)/);
      if (m) return m[1].trim();
      return t.length > 180 ? t.slice(0, 177).trim() + "..." : t;
    }

    function positionMostCommonIssuesTooltip(chart, tooltip, tooltipEl) {
      const rect = chart.canvas.getBoundingClientRect();
      const offset = 12;
      const padding = 8;
      let left = rect.left + tooltip.caretX + offset;
      let top = rect.top + tooltip.caretY - offset - tooltipEl.offsetHeight;

      const maxLeft = window.innerWidth - tooltipEl.offsetWidth - padding;
      if (left > maxLeft) left = maxLeft;
      if (left < padding) left = padding;

      if (top < padding) {
        top = rect.top + tooltip.caretY + offset;
      }
      const maxTop = window.innerHeight - tooltipEl.offsetHeight - padding;
      if (top > maxTop) top = maxTop;

      tooltipEl.style.left = `${left}px`;
      tooltipEl.style.top = `${top}px`;
    }

    function getMostCommonIssuesTooltipEl() {
      let tooltipEl = document.getElementById("mostCommonIssuesTooltip");
      if (tooltipEl) return tooltipEl;

      tooltipEl = document.createElement("div");
      tooltipEl.id = "mostCommonIssuesTooltip";
      tooltipEl.className = "mci-tooltip tour-popover";
      tooltipEl.style.opacity = "0";
      tooltipEl.style.position = "fixed";
      tooltipEl.style.pointerEvents = "none";

      tooltipEl.innerHTML = `
        <div class="mci-tooltip-header">
          <div class="tour-title"></div>
        </div>
        <div class="tour-body mci-body">
          <div class="mci-count"></div>
          <div class="mci-explanation"></div>
        </div>
        <div class="mci-hint">Click the bar chart to revise</div>
      `;

      document.body.appendChild(tooltipEl);
      return tooltipEl;
    }

    function externalMostCommonIssuesTooltip(context) {
      const { chart, tooltip } = context;
      const tooltipEl = getMostCommonIssuesTooltipEl();

      if (!tooltip || tooltip.opacity === 0) {
        tooltipEl.style.opacity = "0";
        return;
      }

      const dataPoint = tooltip.dataPoints?.[0];
      if (!dataPoint) {
        tooltipEl.style.opacity = "0";
        return;
      }

      const titleEl = tooltipEl.querySelector(".tour-title");
      const countEl = tooltipEl.querySelector(".mci-count");
      const explanationEl = tooltipEl.querySelector(".mci-explanation");

      const label = dataPoint.label || "";
      const count = dataPoint.formattedValue || "0";
      const explanation = dataPoint.dataset?.explanations?.[dataPoint.dataIndex] || "";

      if (titleEl) titleEl.textContent = label;
      if (countEl) countEl.textContent = `Count: ${count}`;
      if (explanationEl) {
        explanationEl.textContent = explanation;
        explanationEl.style.display = explanation ? "block" : "none";
      }

      tooltipEl.style.opacity = "1";
      positionMostCommonIssuesTooltip(chart, tooltip, tooltipEl);
    }

    function applyDismissalsToLabelCounts(labelCounts) {
      const out = { ...(labelCounts || {}) };
      if (!selectedFile) return out;
      const countsToSubtract = {};
      dismissedIssues
        .filter((record) => record?.file_name === selectedFile.name)
        .forEach((record) => {
          const label = String(record?.label || "").trim();
          if (!label) return;
          countsToSubtract[label] = (countsToSubtract[label] || 0) + 1;
        });

      Object.entries(countsToSubtract).forEach(([label, sub]) => {
        const cur = Number(out[label] || 0);
        const next = Math.max(0, cur - sub);
        if (next === 0) delete out[label];
        else out[label] = next;
      });
      return out;
    }

    function filterDismissedExamples(label, examples) {
      return (examples || []).filter((ex) => {
        return !isDismissedIssueInstance(label || ex?.label || "", ex?.sentence || "");
      });
    }

    function renderMostCommonIssues(labelCounts) {
      if (!mostCommonIssuesWrap || !mostCommonIssuesChartEl) return;

      updateStatsPanel(labelCounts);

      const TOP_N = 30;
      const entries = Object.entries(labelCounts || {})
        .filter(([label, count]) => label && (count || 0) > 0)
        .sort((a, b) => (b[1] || 0) - (a[1] || 0))
        .slice(0, TOP_N);

      if (entries.length === 0) {
        mostCommonIssuesWrap.style.display = "none";
        mostCommonIssuesWrap.dataset.hasData = "false";
        const tooltipEl = document.getElementById("mostCommonIssuesTooltip");
        if (tooltipEl) tooltipEl.style.opacity = "0";
        if (mostCommonIssuesChart) {
          mostCommonIssuesChart.destroy();
          mostCommonIssuesChart = null;
        }
        return;
      }

      const labels = entries.map(([label]) => label);
      const issueIds = labels.map((lbl) => getIssueIdForLabel(lbl));
      const values = entries.map(([, count]) => count || 0);
      const bucketIds = labels.map((lbl) => getBucketIdForLabel(lbl));
      const barBg = bucketIds.map((id) => getBucketColor(id, 0.60));
      const barBorder = bucketIds.map((id) => getBucketColor(id, 1.0));
      const issues = currentMarkEvent?.issues || [];
      const shortExplanationByLabel = {};
      issues.forEach((iss) => {
        const lbl = String(iss?.label || "").trim();
        if (!lbl) return;
        const shortText = iss?.short_explanation
          ? String(iss.short_explanation)
          : firstSentence(iss?.explanation);
        if (shortText && !shortExplanationByLabel[lbl]) {
          shortExplanationByLabel[lbl] = shortText;
        }
      });
      const explanations = labels.map((lbl) => shortExplanationByLabel[lbl] || "");

      mostCommonIssuesWrap.style.display = "block";
      mostCommonIssuesWrap.dataset.hasData = "true";

      if (mostCommonIssuesChart) {
        mostCommonIssuesChart.destroy();
        mostCommonIssuesChart = null;
      }

      const viewport = mciScrollViewport;
      const inner = mciScrollInner;
      if (viewport && currentMarkEvent?.id != null) {
        const markId = String(currentMarkEvent.id);
        if (viewport.dataset.markEventId !== markId) {
          delete viewport.dataset.hasScrolled;
          viewport.dataset.markEventId = markId;
        }
      }
      const viewportWidth = viewport ? viewport.clientWidth : mostCommonIssuesWrap.clientWidth;
      const pxPerBar = 80;
      const canvasWidth = Math.max(viewportWidth, entries.length * pxPerBar);
      mostCommonIssuesChartEl.width = canvasWidth;
      mostCommonIssuesChartEl.style.width = `${canvasWidth}px`;
      mostCommonIssuesChartEl.style.height = "280px";
      if (inner) inner.style.width = `${canvasWidth}px`;

      const shouldResetScroll = viewport && !viewport.dataset.hasScrolled;
      if (viewport && shouldResetScroll) viewport.scrollLeft = 0;
      if (viewport) {
        viewport.addEventListener("scroll", () => {
          viewport.dataset.hasScrolled = "1";
        }, { once: true });
      }

      const ctx = mostCommonIssuesChartEl.getContext("2d");
      mostCommonIssuesChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [{
            data: values,
            backgroundColor: barBg,
            borderColor: barBorder,
            borderWidth: 1,
            explanations: explanations,
            issueIds: issueIds
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              enabled: false,
              external: externalMostCommonIssuesTooltip
            }
          },
          onHover: (event, elements, chart) => {
            const targetChart = chart || mostCommonIssuesChart;
            if (!targetChart?.canvas) return;
            targetChart.canvas.style.cursor = elements?.length ? "pointer" : "default";
          },
          onClick: (event, elements, chart) => {
            const targetChart = chart || mostCommonIssuesChart;
            if (!targetChart) return;
            const hits = targetChart.getElementsAtEventForMode(
              event,
              "nearest",
              { intersect: true },
              true
            );
            if (!hits.length) return;
            const idx = hits[0].index;
            const label = targetChart.data.labels?.[idx];
            const issueId = targetChart.data.datasets?.[0]?.issueIds?.[idx];
            void openRevisionExampleFromIssueId(issueId || "", label || "");
          },
          scales: {
            y: {
              beginAtZero: true,
              ticks: { precision: 0 }
            },
            x: {
              ticks: {
                autoSkip: true,
                maxRotation: 45,
                minRotation: 0,
                font: {
                  size: 14,
                  weight: "600"
                },
                callback: (value, idx) => {
                  const lbl = labels[idx] || "";
                  return lbl.length > 26 ? `${lbl.slice(0, 25)}â€¦` : lbl;
                }
              }
            }
          }
        }
      });
      auditRevisionIssueBindings({ issueIds, labels, source: "chart" });
    }

    async function loadRevisionPractice() {
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session || !selectedFile) {
        return;
      }

      lastRevisionSectionData = null;

      try {
        // Get latest mark event for this user and file
        const { data: markEvents, error: markError } = await supa
          .from("mark_events")
          .select("id, label_counts, issues, created_at, file_name")
          .eq("user_id", sessionData.session.user.id)
          .eq("file_name", selectedFile.name)
          .order("created_at", { ascending: false })
          .limit(1);

        if (markError) {
          console.error("Error loading mark events:", markError);
          sectionSelect.innerHTML = '<option value="">All sections</option>';
          issueSelect.innerHTML = '<option value="">Examples will appear here after marking.</option>';
          renderIssueButtonsFromSectionData(null);
          return;
        }

        if (!markEvents || markEvents.length === 0) {
          sectionSelect.innerHTML = '<option value="">All sections</option>';
          issueSelect.innerHTML = '<option value="">Examples will appear here after marking.</option>';
          renderIssueButtonsFromSectionData(null);
          return;
        }

        currentMarkEvent = markEvents[0];
        const rawLabelCounts = { ...(currentMarkEvent.label_counts || {}) };
        const filteredLabelCounts = applyDismissalsToLabelCounts(rawLabelCounts);
        liveLabelCounts = { ...filteredLabelCounts };
        const labelCounts = liveLabelCounts;
        syncIssueIdMaps(currentMarkEvent?.issues || [], labelCounts);
        
        if (resultsCard) resultsCard.style.display = "block";
        if (form) form.classList.add("has-results");
        try {
          renderMostCommonIssues(liveLabelCounts);
        } catch (chartError) {
          console.warn("Most common issues chart failed to render:", chartError);
        }
        if (statsPanel) {
          statsPanel.style.display = "block";
          updateStatsPanel(liveLabelCounts);
        }
        
        // Build section index by querying issue_examples
        let examplesQuery = supa
          .from("issue_examples")
          .select("label, paragraph_index")
          .eq("user_id", sessionData.session.user.id)
          .eq("file_name", selectedFile.name);
        
        // Filter by mark_event_id if available
        if (currentMarkEvent.id) {
          examplesQuery = examplesQuery.eq("mark_event_id", currentMarkEvent.id);
        }
        
        const { data: examplesData, error: examplesError } = await examplesQuery;
        
        if (examplesError) {
          console.warn("Error loading examples for section index:", examplesError);
        }
        
        // Determine intro_idx_est and conclusion_idx_est from paragraph_index values
        const paraIndices = (examplesData || [])
          .map(ex => ex.paragraph_index)
          .filter(idx => idx != null && typeof idx === 'number');
        
        const intro_idx_est = paraIndices.length > 0 ? Math.min(...paraIndices) : 0;
        const conclusion_idx_est = paraIndices.length > 0 ? Math.max(...paraIndices) : 0;
        
        // Build label-to-section mapping
        // For each label, find its dominant paragraph_index (most frequent)
        const labelParaCounts = {};
        (examplesData || []).forEach(ex => {
          const label = String(ex.label || "").trim();
          const paraIdx = ex.paragraph_index;
          if (!label || paraIdx == null) return;
          
          if (!labelParaCounts[label]) {
            labelParaCounts[label] = {};
          }
          labelParaCounts[label][paraIdx] = (labelParaCounts[label][paraIdx] || 0) + 1;
        });
        
        // Determine section for each label
        const labelToSection = {};
        const sectionLabels = {
          "Title and Introduction": [],
          "Conclusion": [],
        };
        const bodySections = {}; // "Nth Body Paragraph" -> [labels]
        
        Object.keys(labelCounts).forEach(label => {
          const labelLower = label.toLowerCase();
          const paraCounts = labelParaCounts[label] || {};
          
          // Find dominant paragraph_index
          let dominantParaIdx = null;
          let maxCount = 0;
          Object.entries(paraCounts).forEach(([paraIdx, count]) => {
            if (count > maxCount) {
              maxCount = count;
              dominantParaIdx = parseInt(paraIdx, 10);
            }
          });
          
          // Bucket into section
          let section = null;
          if (dominantParaIdx === intro_idx_est || 
              labelLower.includes("title") || 
              labelLower.includes("thesis") || 
              labelLower.includes("first sentence") || 
              labelLower.includes("introduction")) {
            section = "Title and Introduction";
            sectionLabels["Title and Introduction"].push(label);
          } else if (dominantParaIdx === conclusion_idx_est || 
                     labelLower.includes("conclusion")) {
            section = "Conclusion";
            sectionLabels["Conclusion"].push(label);
          } else if (dominantParaIdx != null) {
            const bodyNum = dominantParaIdx - intro_idx_est;
            const sectionName = formatBodySectionName(bodyNum);
            section = sectionName;
            if (!bodySections[sectionName]) {
              bodySections[sectionName] = [];
            }
            bodySections[sectionName].push(label);
          } else {
            // Fallback: put in Title and Introduction if we can't determine
            section = "Title and Introduction";
            sectionLabels["Title and Introduction"].push(label);
          }
          
          labelToSection[label] = section;
        });
        
        // Merge body sections into sectionLabels
        Object.keys(bodySections).forEach(sectionName => {
          sectionLabels[sectionName] = bodySections[sectionName];
        });
        
        // Store section data for filtering
        window.revisionSectionData = {
          labelToSection,
          sectionLabels,
          labelCounts
        };
        lastRevisionSectionData = window.revisionSectionData;
        
        // Populate sectionSelect (only include sections with at least one label)
        sectionSelect.innerHTML = '<option value="">All sections</option>';
        // Sort body sections numerically (Body paragraph 1, 2, 10, not 1, 10, 2)
        const bodySectionNames = Object.keys(bodySections).sort((a, b) => {
          const numA = parseInt(a.match(/\d+/)?.[0] || "0", 10);
          const numB = parseInt(b.match(/\d+/)?.[0] || "0", 10);
          return numA - numB;
        });
        const sectionOrder = ["Title and Introduction", ...bodySectionNames, "Conclusion"];
        window.revisionSectionData.sectionOrder = sectionOrder;
        renderIssueButtonsFromSectionData(window.revisionSectionData, sectionOrder);
        sectionOrder.forEach(sectionName => {
          if (sectionLabels[sectionName] && sectionLabels[sectionName].length > 0) {
            const option = document.createElement("option");
            option.value = sectionName;
            option.textContent = sectionName;
            sectionSelect.appendChild(option);
          }
        });
        
        // Populate issueSelect with all labels (sorted by count desc)
        const sortedLabels = Object.entries(labelCounts)
          .sort((a, b) => (b[1] || 0) - (a[1] || 0))
          .map(([label]) => String(label || "").trim())
          .filter(Boolean);
        
        issueSelect.innerHTML = '<option value="">Select an issue...</option>';
        sortedLabels.forEach(label => {
          const option = document.createElement("option");
          const issueId = getIssueIdForLabel(label);
          option.value = issueId;
          option.dataset.issueLabel = label;
          const count = labelCounts[label] || 0;
          option.textContent = `${label} (${count})`;
          issueSelect.appendChild(option);
        });

      } catch (error) {
        console.error("Error loading revision practice:", error);
        sectionSelect.innerHTML = '<option value="">All sections</option>';
        issueSelect.innerHTML = '<option value="">Examples will appear here after marking.</option>';
        renderIssueButtonsFromSectionData(null);
      }
    }

    async function loadIssueExamples(label) {
      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session || !selectedFile) {
        return;
      }

      try {
        if (examplesList) examplesList.innerHTML = "";
        if (examplesList) examplesList.style.display = "";
        if (approvedRewritesList) approvedRewritesList.innerHTML = "";
        if (approvedRewritesWrap) approvedRewritesWrap.style.display = "none";
        approvedRewrites.length = 0;
        if (applyAllToPreviewBtn) {
          applyAllToPreviewBtn.style.display = "none";
          applyAllToPreviewBtn.disabled = true;
          applyAllToPreviewBtn.classList.remove("apply-attention");
        }
        approvedRewriteByKey.clear();
        approvedExampleKeys.clear();

        // Get explanation from issues array
        const issueData = updateIssueMetadataForLabel(label);

        // Get examples from issue_examples
        // Fetch 50 rows to allow deduplication while still getting 10 unique examples
        // Filter by mark_event_id if available (prevents stale examples after recheck)
        const userId = sessionData.session.user.id;
        const fileName = selectedFile.name;
        const wanted = canonicalLabel(label);
        let examples = [];
        let lastError = null;

        const res = await supa
          .from("issue_examples")
          .select("label, sentence, paragraph_index, created_at")
          .eq("user_id", userId)
          .eq("file_name", fileName)
          .eq("label", label)
          .eq("mark_event_id", currentMarkEvent?.id)
          .order("created_at", { ascending: true })
          .limit(50);

        examples = res.data || [];
        lastError = res.error;

        // Treat empty results or errors as failure and fall back.
        if ((lastError || examples.length === 0) && currentMarkEvent?.id) {
          // FALLBACK 1: same mark_event_id, no label filter
          const broad = await supa
            .from("issue_examples")
            .select("label, sentence, paragraph_index, created_at")
            .eq("user_id", userId)
            .eq("file_name", fileName)
            .eq("mark_event_id", currentMarkEvent.id)
            .order("created_at", { ascending: true })
            .limit(200);

          if (!broad.error && broad.data?.length) {
            examples = broad.data.filter(
              (row) => canonicalLabel(row.label) === wanted
            );
          } else if (broad.error) {
            lastError = lastError || broad.error;
          }
        }

        // FALLBACK 2: legacy rows without mark_event_id
        if (examples.length === 0) {
          const legacy = await supa
            .from("issue_examples")
            .select("label, sentence, paragraph_index, created_at")
            .eq("user_id", userId)
            .eq("file_name", fileName)
            .order("created_at", { ascending: true })
            .limit(200);

          if (!legacy.error && legacy.data?.length) {
            examples = legacy.data.filter(
              (row) => canonicalLabel(row.label) === wanted
            );
          } else if (legacy.error) {
            lastError = lastError || legacy.error;
          }
        }

        if (lastError && examples.length === 0) {
          console.error("Error loading examples:", lastError);
          hideExamplesEmptyState();
          updateAllApprovedBanner([]);
          examplesList.innerHTML = "<li>Error loading examples.</li>";
          if (exampleNavRow) exampleNavRow.style.display = "none";
          currentExamplesAll = [];
          currentIndex = 0;
          return;
        }

        if (examples.length === 0) {
          console.warn("No revision examples found for label:", label);
        }

        // Sort: first by created_at desc (latest run first), then by paragraph_index asc (doc order)
        const sortedExamples = (examples || []).sort((a, b) => {
          // First, sort by created_at descending (latest first)
          const timeA = new Date(a.created_at || 0).getTime();
          const timeB = new Date(b.created_at || 0).getTime();
          if (timeA !== timeB) {
            return timeB - timeA; // Descending
          }
          // If created_at is the same (same mark event), sort by paragraph_index ascending
          const paraA = a.paragraph_index ?? 999999;
          const paraB = b.paragraph_index ?? 999999;
          return paraA - paraB;
        });

        // Deduplicate examples by paragraph + sentence, and skip applied examples
        const uniq = [];
        const seenSent = new Set();
        for (const ex of sortedExamples) {
          const s = String(ex?.sentence || "").trim();
          if (!s) continue;
          const paraIndex = ex?.paragraph_index ?? "";
          const key = getExampleKeyFromParts(paraIndex ?? 0, s);
          if (loadAppliedFlag(label, key)) {
            appliedExampleKeys.add(key);
          }
          if (appliedExampleKeys.has(key)) continue;
          if (seenSent.has(key)) continue;
          seenSent.add(key);
          if (typeof ex.applied_to_preview !== "boolean") {
            ex.applied_to_preview = false;
          }
          uniq.push(ex);
          if (uniq.length >= 10) break; // Cap at 10 examples
        }
        const filteredUniq = filterDismissedExamples(label, uniq);
        const labelChanged = currentLabel !== label;
        currentLabel = label;
        currentExamplesAll = filteredUniq;
        const issueId = getIssueIdForLabel(label);
        examplesByIssueId.set(issueId, filteredUniq || []);
        if (labelChanged) currentIndex = 0;

        currentExamplesAll.forEach((ex) => {
          const key = getExampleKey(ex);
          if (key && !exampleDataByKey.has(key)) {
            exampleDataByKey.set(key, ex);
          }
        });

        if (!filteredUniq || filteredUniq.length === 0) {
          if (issueId) {
            console.warn("No examples loaded for issueId:", issueId);
          }
          const hadAnyExamples = Array.isArray(examples) && examples.length > 0;
          const hadDismissals = uniq && uniq.length > 0;
          const emptyMessage = !hadAnyExamples
            ? "No examples found for this issue yet."
            : hadDismissals
              ? "All examples for this issue have been dismissed. Click another bar to revise a different issue."
              : getPreviewOnlyMessage(
                  label,
                  "No more examples for this issue. Click another bar to practice a different issue."
                );
          showExamplesEmptyState(emptyMessage);
          updateAllApprovedBanner([]);
          if (exampleNavRow) exampleNavRow.style.display = "none";
          downloadRevisionNotesBtn.style.display = "none";
          updateApplyAllUI();
          return;
        }

        hideExamplesEmptyState();
        updateAllApprovedBanner(currentExamplesAll);
        renderCurrentExample();

        downloadRevisionNotesBtn.style.display = "block";
        downloadRevisionNotesBtn.onclick = () => {
          downloadRevisionNotes(label, currentExamplesAll);
        };

      } catch (error) {
        console.error("Error loading issue examples:", error);
        hideExamplesEmptyState();
        examplesList.innerHTML = "<li>Error loading examples.</li>";
        if (exampleNavRow) exampleNavRow.style.display = "none";
        currentExamplesAll = [];
        currentIndex = 0;
      }
    }

    async function loadRandomIssueForTraining() {
      let candidates = [];
      const chartIssueIds = mostCommonIssuesChart?.data?.datasets?.[0]?.issueIds;
      if (Array.isArray(chartIssueIds) && chartIssueIds.length) {
        candidates = chartIssueIds.slice();
      } else if (lastRevisionSectionData?.labelCounts) {
        candidates = Object.entries(lastRevisionSectionData.labelCounts)
          .filter(([lbl, ct]) => lbl && (ct || 0) > 0)
          .sort((a, b) => (b[1] || 0) - (a[1] || 0))
          .slice(0, 8)
          .map(([lbl]) => getIssueIdForLabel(lbl));
      }
      if (!candidates.length) return null;

      const issueId = candidates[Math.floor(Math.random() * candidates.length)];
      const label = getLabelForIssueId(issueId) || "";

      if (sectionSelect) {
        sectionSelect.value = "";
        sectionSelect.dispatchEvent(new Event("change"));
      }
      if (issueSelect) {
        issueSelect.value = issueId;
      }

      await openRevisionExampleFromIssueId(issueId, label);

      const btn = issueButtonsWrap?.querySelector(
        `.issue-btn[data-issue-id="${CSS.escape(issueId)}"]`
      );
      if (btn) {
        if (activeIssueBtn) activeIssueBtn.classList.remove("active");
        activeIssueBtn = btn;
        activeIssueBtn.classList.add("active");
      }

      return issueId;
    }

    // ===== Preview highlighting helpers =====
    function getPreviewBlocks() {
      if (!markedPreview) return [];
      
      // Prefer: markedPreview.querySelectorAll(".docx p, .docx li, p, li")
      let blocks = Array.from(markedPreview.querySelectorAll(".docx p, .docx li, p, li"));
      
      // Filter out empty innerText
      blocks = blocks.filter(block => (block.innerText || "").trim().length > 0);
      
      // If none found, fallback to markedPreview.querySelectorAll("p, li, div") filtered
      if (blocks.length === 0) {
        blocks = Array.from(markedPreview.querySelectorAll("p, li, div"));
        blocks = blocks.filter(block => (block.innerText || "").trim().length > 0);
      }
      
      return blocks;
    }

    function normalizeForMatch(text) {
      return (text || "")
        .replace(/[\u201C\u201D\u201E\u201F]/g, '"')  // curly quotes to straight
        .replace(/[\u2018\u2019\u201A\u201B]/g, "'")  // curly quotes to straight
        .replace(/[\u2013\u2014]/g, "-")  // en dash and em dash to hyphen
        .replace(/\u00AD/g, "")  // remove soft hyphens
        .replace(/\u00A0/g, " ")  // non-breaking spaces to normal spaces
        .replace(/[\u200B-\u200D\uFEFF]/g, "")  // remove zero-width chars
        .replace(/\s+/g, " ")  // collapse whitespace
        .trim();
    }

    function unwrapNode(el) {
      const parent = el.parentNode;
      if (!parent) return;
      while (el.firstChild) {
        parent.insertBefore(el.firstChild, el);
      }
      parent.removeChild(el);
      parent.normalize();
    }

    function clearPreviewHighlights() {
      // Unwrap any highlight spans
      const highlightedSpans = markedPreview.querySelectorAll("span.vysti-preview-hit[data-vysti-hit='1']");
      highlightedSpans.forEach(unwrapNode);
      
      // Remove classes from any elements
      const highlighted = markedPreview.querySelectorAll(".vysti-preview-hit, .vysti-preview-hit-block");
      highlighted.forEach(el => {
        el.classList.remove("vysti-preview-hit", "vysti-preview-hit-block");
      });
    }

    function normalizeCharForMatch(ch) {
      // Convert curly quotes to straight
      if (ch === '\u201C' || ch === '\u201D' || ch === '\u201E' || ch === '\u201F') return '"';
      if (ch === '\u2018' || ch === '\u2019' || ch === '\u201A' || ch === '\u201B') return "'";
      // Convert en dash and em dash to hyphen
      if (ch === '\u2013' || ch === '\u2014') return '-';
      // Convert NBSP to space
      if (ch === '\u00A0') return ' ';
      // Strip soft hyphen and zero-width chars
      if (ch === '\u00AD' || (ch >= '\u200B' && ch <= '\u200D') || ch === '\uFEFF') return '';
      // Treat any whitespace as space
      if (/\s/.test(ch)) return ' ';
      return ch;
    }

    // Helper: Check if a text node is a Vysti label run (starts with "â†’")
    function isVystiLabelTextNode(node) {
      if (node.nodeType !== Node.TEXT_NODE) return false;
      
      // Check if the node's textContent (trimmed) starts with "â†’"
      const text = (node.textContent || "").trim();
      if (text.startsWith("â†’")) return true;
      
      // Also check the closest SPAN's textContent (handles cases where docx-preview splits arrow + label across nodes)
      let current = node.parentElement;
      while (current && current.tagName !== "SPAN") {
        current = current.parentElement;
      }
      if (current && current.tagName === "SPAN") {
        const spanText = (current.textContent || "").trim();
        if (spanText.startsWith("â†’")) return true;
      }
      
      return false;
    }

    // Helper: Check if a text node is any Vysti artifact (arrow labels or rewrite-practice tags)
    function isVystiArtifactTextNode(node) {
      if (node.nodeType !== Node.TEXT_NODE) return false;
      
      // Check for arrow labels using existing helper
      if (isVystiLabelTextNode(node)) return true;
      
      // Check for rewrite-practice tag
      const text = (node.textContent || "").trim();
      // Match the exact phrase from marker.py: " * Rewrite this paragraph for practice  *"
      // Also handle case-insensitive and variations in whitespace
      const rewritePattern = /^\s*\*\s*Rewrite this paragraph for practice\s*\*\s*$/i;
      if (rewritePattern.test(text)) return true;
      
      // Also check the closest SPAN's textContent (handles cases where docx-preview splits text across nodes)
      let current = node.parentElement;
      while (current && current.tagName !== "SPAN") {
        current = current.parentElement;
      }
      if (current && current.tagName === "SPAN") {
        const spanText = (current.textContent || "").trim();
        if (rewritePattern.test(spanText)) return true;
      }
      
      return false;
    }

    function removeRewritePracticeTagsFromPreview(rootEl) {
      if (!rootEl) return;
      const rewritePattern = /\s*\*\s*Rewrite this paragraph for practice\s*\*\s*/i;
      const replacePattern = new RegExp(rewritePattern.source, "gi");
      const walker = document.createTreeWalker(
        rootEl,
        NodeFilter.SHOW_TEXT,
        null
      );
      const matchedNodes = [];
      let node;
      while ((node = walker.nextNode())) {
        if (rewritePattern.test(node.textContent || "")) {
          matchedNodes.push(node);
        }
      }
      matchedNodes.forEach((textNode) => {
        const original = textNode.textContent || "";
        const cleaned = original.replace(replacePattern, "").trim();
        if (cleaned) {
          textNode.textContent = cleaned;
        } else {
          const parent = textNode.parentNode;
          textNode.remove();
          if (parent && parent.childNodes.length === 0) {
            parent.remove();
          }
        }
      });
      rootEl.normalize();
    }

    // Helper: Extract clean text from an element, excluding Vysti artifacts
    function extractCleanTextFromElement(el) {
      if (!el) return "";
      
      const walker = document.createTreeWalker(
        el,
        NodeFilter.SHOW_TEXT,
        null
      );
      
      const textParts = [];
      let node;
      
      while ((node = walker.nextNode())) {
        // Skip Vysti artifacts (arrow labels and rewrite-practice tags)
        if (isVystiArtifactTextNode(node)) continue;
        
        const text = node.textContent || "";
        // IMPORTANT: do NOT drop whitespace-only nodes; docx-preview often stores spaces as their own text nodes.
        textParts.push(text);
      }
      
      // Concatenate all text parts
      let combined = textParts.join("");
      
      // Normalize whitespace:
      // - Convert NBSP to space
      combined = combined.replace(/\u00A0/g, " ");
      // - Collapse multiple whitespace to single spaces
      combined = combined.replace(/\s+/g, " ");
      // - Trim
      combined = combined.trim();
      
      return combined;
    }

    function selectionSafeText(block) {
      // Exclude quoted text so we donâ€™t target evidence
      const raw = extractCleanTextFromElement(block) || "";
      return stripQuotedText(raw);
    }

    function highlightAndScrollInBlock(block, textToFind) {
      if (!block || !textToFind) return false;

      clearPreviewHighlights();

      // Try highlighting a slightly longer anchor first (more precise)
      let spans = highlightExactTextInElement(block, textToFind);
      if (!Array.isArray(spans) || spans.length === 0) {
        // fallback: highlight just the first word
        const firstWord = String(textToFind).split(/\s+/)[0];
        spans = highlightExactTextInElement(block, firstWord);
      }

      if (Array.isArray(spans) && spans.length) {
        spans.forEach(s => s.classList.add("vysti-cursor-highlight"));
        spans[0].scrollIntoView({ behavior: "smooth", block: "center" });
        return true;
      }

      block.scrollIntoView({ behavior: "smooth", block: "center" });
      return true;
    }

    function findWeakVerbInText(text) {
      // Build regex once if you want; for now use WEAK_VERBS set
      // Scan tokens with indices so we can build an anchor phrase
      const re = /\b[A-Za-z]+(?:'[A-Za-z]+)?\b/g;
      let m;
      const lowerText = text.toLowerCase();

      while ((m = re.exec(text)) !== null) {
        const tok = m[0];
        const t = tok.toLowerCase();

        if (!WEAK_VERBS.has(t)) continue;

        // Skip "the use of" (Precision-only)
        // Simple window check in raw text
        if (t === "use") {
          const before = lowerText.slice(Math.max(0, m.index - 6), m.index);
          const after = lowerText.slice(m.index + tok.length, m.index + tok.length + 6);
          if (/\bthe\s+$/.test(before) && /^\s+of\b/.test(after)) continue;
        }

        // Build anchor: token + next word (more precise)
        const afterSlice = text.slice(m.index + tok.length);
        const next = afterSlice.match(/^\s+([A-Za-z]+(?:'[A-Za-z]+)?)/);
        const anchor = next ? `${tok} ${next[1]}` : tok;

        return anchor;
      }
      return null;
    }

    const COMMON_UPGRADE_VERBS = new Set([
      // â€œmehâ€ reporting verbs that students overuse
      "demonstrates","emphasizes","states","represents","suggests","indicates",
      "explains","describes","discusses","presents","notes","mentions",
      "portrays","conveys","reveals","highlights","illustrates","shows","uses",
      "makes","does","gets","has","had"
    ]);

    const BE_VERBS = new Set([
      "am","is","are","was","were","be","been","being"
    ]);

    let lastPowerVerbJumpIndex = 0;

    function isLikelyVerbToken(lowerTok) {
      if (!lowerTok) return false;
      // exclude super common non-verbs
      if (lowerTok.length < 3) return false;
      // prefer known â€œmeh verbsâ€
      if (COMMON_UPGRADE_VERBS.has(lowerTok)) return true;
      // fallback: morphology heuristic (imperfect but works decently)
      return (
        lowerTok.endsWith("ed") ||
        lowerTok.endsWith("ing") ||
        lowerTok.endsWith("s")
      );
    }

    function findNextTokenMatch(normText, startIndex, predicate) {
      if (!normText) return null;
      const re = /\b[A-Za-z]+\b/g;
      re.lastIndex = Math.max(0, startIndex || 0);
      let m;

      while ((m = re.exec(normText)) !== null) {
        const tok = m[0];
        const lowerTok = tok.toLowerCase();
        if (predicate(lowerTok, m.index, tok)) {
          return {
            token: tok,
            startIdx: m.index,
            endIdx: m.index + tok.length - 1
          };
        }
      }
      return null;
    }

    function getNormalizedIndexFromRangeStart(preview, posMap) {
      const selection = window.getSelection();
      if (!selection || !selection.rangeCount) return null;
      const range = selection.getRangeAt(0);
      if (!preview.contains(range.startContainer)) return null;

      let node = range.startContainer;
      let offset = range.startOffset;

      if (node.nodeType !== Node.TEXT_NODE) {
        const walker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null);
        const firstText = walker.nextNode();
        if (!firstText) return null;
        node = firstText;
        offset = 0;
      }

      let fallbackIndex = null;
      for (let i = 0; i < posMap.length; i += 1) {
        const pos = posMap[i];
        if (pos.node !== node) continue;
        if (pos.offset >= offset) return i;
        fallbackIndex = i + 1;
      }
      return fallbackIndex;
    }

    function selectWordRangeFromMap(preview, posMap, startIdx, endIdx) {
      if (!posMap.length) return false;
      const start = posMap[startIdx];
      const end = posMap[endIdx];
      if (!start || !end) return false;

      const selection = window.getSelection();
      if (!selection) return false;

      const range = document.createRange();
      range.setStart(start.node, start.offset);
      range.setEnd(end.node, end.offset + 1);
      selection.removeAllRanges();
      selection.addRange(range);

      preview.focus();
      const scrollEl = start.node && start.node.parentElement ? start.node.parentElement : preview;
      if (scrollEl && scrollEl.scrollIntoView) {
        scrollEl.scrollIntoView({ behavior: "smooth", block: "center" });
      }
      return true;
    }

    function findNonPowerVerbCandidate(text) {
      const re = /\b[A-Za-z]+(?:'[A-Za-z]+)?\b/g;
      let m;

      while ((m = re.exec(text)) !== null) {
        const tok = m[0];
        const t = tok.toLowerCase();

        // Skip weak verbs here; we already prefer weak verbs first
        if (WEAK_VERBS.has(t)) continue;

        // Skip if itâ€™s already a power verb (forms set)
        if (powerVerbFormsSet && powerVerbFormsSet.has(t)) continue;

        // Skip obvious function words (reuse your cohesion stop words if available)
        if (COHESION_STOP_WORDS && COHESION_STOP_WORDS.has(t)) continue;

        if (!isLikelyVerbToken(t)) continue;

        // Anchor with next word for more precise highlight
        const afterSlice = text.slice(m.index + tok.length);
        const next = afterSlice.match(/^\s+([A-Za-z]+(?:'[A-Za-z]+)?)/);
        const anchor = next ? `${tok} ${next[1]}` : tok;

        return anchor;
      }
      return null;
    }

    async function jumpToNextVerbToUpgradeInPreview() {
      const preview = document.getElementById("markedPreview");
      if (!preview || !preview.isContentEditable) return false;
      if (!preview.innerText.trim()) return false;

      if (!powerVerbFormsSet || powerVerbFormsSet.size === 0) {
        await loadPowerVerbsList();
      }

      const { normText, posMap } = buildNormalizedTextMap(preview);
      if (!normText || !posMap.length) return false;

      const selectionIndex = getNormalizedIndexFromRangeStart(preview, posMap);
      const startIndex = Number.isInteger(selectionIndex) ? selectionIndex : lastPowerVerbJumpIndex;
      const lowerNorm = normText.toLowerCase();

      const weakMatch = findNextTokenMatch(normText, startIndex, (lowerTok, idx) => {
        if (!WEAK_VERBS.has(lowerTok)) return false;
        if (lowerTok === "use") {
          const before = lowerNorm.slice(Math.max(0, idx - 6), idx);
          const after = lowerNorm.slice(idx + lowerTok.length, idx + lowerTok.length + 6);
          if (/\bthe\s+$/.test(before) && /^\s+of\b/.test(after)) return false;
        }
        return true;
      });

      const target = weakMatch || findNextTokenMatch(normText, startIndex, (lowerTok) => {
        if (!lowerTok) return false;
        if (BE_VERBS.has(lowerTok)) return false;
        if (COHESION_STOP_WORDS && COHESION_STOP_WORDS.has(lowerTok)) return false;
        if (powerVerbFormsSet && powerVerbFormsSet.has(lowerTok)) return false;
        if (!isLikelyVerbToken(lowerTok)) return false;
        return true;
      });

      if (!target) return false;

      clearPreviewHighlights();
      const didSelect = selectWordRangeFromMap(preview, posMap, target.startIdx, target.endIdx);
      if (didSelect) {
        lastPowerVerbJumpIndex = Math.min(target.endIdx + 1, normText.length);
      }
      return didSelect;
    }

    function buildNormalizedTextMap(rootEl) {
      const walker = document.createTreeWalker(rootEl, NodeFilter.SHOW_TEXT, null);
      const posMap = [];
      let normText = "";
      let lastWasSpace = false;

      let node;
      while ((node = walker.nextNode())) {
        // Skip Vysti label runs (text starting with "â†’")
        if (isVystiLabelTextNode(node)) continue;
        
        const t = node.textContent || "";
        for (let i = 0; i < t.length; i++) {
          let ch = normalizeCharForMatch(t[i]);
          if (ch === "") continue;

          if (ch === " ") {
            if (normText.length === 0 || lastWasSpace) continue;
            lastWasSpace = true;
          } else {
            lastWasSpace = false;
          }

          normText += ch;
          posMap.push({ node, offset: i });
        }
      }

      return { normText, posMap };
    }

    // Helper: Wrap a substring of a single Text node by splitting it
    function wrapTextNodeSubstring(node, startOffset, endOffsetInclusive) {
      if (node.nodeType !== Node.TEXT_NODE) return null;
      
      const text = node.textContent || "";
      const endOffsetExclusive = endOffsetInclusive + 1;
      
      // Split at endOffsetExclusive if needed
      if (endOffsetExclusive < text.length) {
        const afterNode = node.splitText(endOffsetExclusive);
        // afterNode is now the node after the split
      }
      
      // Split at startOffset if needed (now node might have been shortened)
      let targetNode = node;
      if (startOffset > 0) {
        targetNode = node.splitText(startOffset);
      }
      
      // Now targetNode contains the substring we want to wrap
      const span = document.createElement("span");
      span.className = "vysti-preview-hit";
      span.setAttribute("data-vysti-hit", "1");
      
      // Wrap the targetNode
      const parent = targetNode.parentNode;
      if (parent) {
        parent.insertBefore(span, targetNode);
        span.appendChild(targetNode);
      }
      
      return span;
    }

    // Multi-span wrapper that handles ranges across multiple text nodes
    function wrapMappedRangeMulti(posMap, startIdx, endIdx) {
      if (startIdx < 0 || endIdx < startIdx || endIdx >= posMap.length) {
        return null;
      }
      
      // Build segments by grouping consecutive entries with the same node
      const segments = [];
      let currentSegment = null;
      
      for (let i = startIdx; i <= endIdx; i++) {
        const pos = posMap[i];
        if (!pos || !pos.node) continue;
        
        if (!currentSegment || currentSegment.node !== pos.node) {
          // Start new segment
          if (currentSegment) {
            segments.push(currentSegment);
          }
          currentSegment = {
            node: pos.node,
            startOffset: pos.offset,
            endOffset: pos.offset
          };
        } else {
          // Extend current segment
          currentSegment.endOffset = pos.offset;
        }
      }
      
      if (currentSegment) {
        segments.push(currentSegment);
      }
      
      if (segments.length === 0) return null;
      
      // Group segments by node, then process each node's segments in reverse offset order
      // This ensures that when we split a node, earlier offsets in the same node are still valid
      const nodeToSegments = new Map();
      for (const seg of segments) {
        if (!nodeToSegments.has(seg.node)) {
          nodeToSegments.set(seg.node, []);
        }
        nodeToSegments.get(seg.node).push(seg);
      }
      
      const createdSpans = [];
      
      // Process each node's segments separately, in reverse offset order
      for (const [originalNode, nodeSegments] of nodeToSegments) {
        // Sort by endOffset descending (process highest offsets first)
        nodeSegments.sort((a, b) => b.endOffset - a.endOffset);
        
        for (const seg of nodeSegments) {
          // Use the original node reference - wrapTextNodeSubstring handles splitting
          const span = wrapTextNodeSubstring(seg.node, seg.startOffset, seg.endOffset);
          if (span) {
            createdSpans.push(span);
          }
        }
      }
      
      // Sort spans by DOM order
      createdSpans.sort((a, b) => {
        const pos = a.compareDocumentPosition(b);
        if (pos & Node.DOCUMENT_POSITION_FOLLOWING) return -1;
        if (pos & Node.DOCUMENT_POSITION_PRECEDING) return 1;
        return 0;
      });
      
      return createdSpans.length > 0 ? createdSpans : null;
    }

    function highlightExactTextInElement(rootEl, targetSentence) {
      const target = normalizeForMatch(targetSentence);
      if (!target) return null;

      const { normText, posMap } = buildNormalizedTextMap(rootEl);

      const start = normText.indexOf(target);
      if (start === -1) return null;

      const end = start + target.length - 1;
      return wrapMappedRangeMulti(posMap, start, end);
    }

    function buildAnchorCandidates(target) {
      const lens = [80, 60, 45, 35, 25, 18];
      const prefixes = [];
      const suffixes = [];

      for (const L of lens) {
        let p = target.substring(0, Math.min(L, target.length));
        const cut = p.lastIndexOf(" ");
        if (cut > 12) p = p.substring(0, cut);
        if (p.length >= 12 && !prefixes.includes(p)) prefixes.push(p);
      }

      for (const L of lens) {
        let s = target.substring(Math.max(0, target.length - L));
        const cut = s.indexOf(" ");
        if (cut !== -1 && (s.length - (cut + 1)) >= 12) s = s.substring(cut + 1);
        if (s.length >= 12 && !suffixes.includes(s)) suffixes.push(s);
      }

      return { prefixes, suffixes };
    }

    function highlightAnchoredSentenceInElement(rootEl, sentence) {
      const target = normalizeForMatch(sentence);
      if (!target) return null;

      const { normText, posMap } = buildNormalizedTextMap(rootEl);
      const { prefixes, suffixes } = buildAnchorCandidates(target);

      // Prevent "highlight half the paragraph" accidents
      const maxAllowed = Math.max(220, target.length * 3 + 120);

      for (const prefix of prefixes) {
        const start = normText.indexOf(prefix);
        if (start === -1) continue;

        for (const suffix of suffixes) {
          const endStart = normText.indexOf(suffix, start + prefix.length);
          if (endStart === -1) continue;

          const end = endStart + suffix.length - 1;
          const spanLen = end - start + 1;

          if (spanLen <= 0 || spanLen > maxAllowed) continue;

          const spans = wrapMappedRangeMulti(posMap, start, end);
          if (spans && spans.length > 0) return spans;
        }
      }

      return null;
    }

    function scoreBlockMatch(sentence, blockText) {
      const normSentence = normalizeForMatch(sentence);
      const normBlock = normalizeForMatch(blockText);

      if (!normSentence || !normBlock) return 0.0;

      // Perfect match if the normalized block contains the full normalized sentence.
      if (normBlock.includes(normSentence)) return 1.0;

      // Token scoring fallback:
      // - Prefer longer tokens to avoid false positives.
      // - But if the sentence is short (or gets split by injected "â†’ ..."), relax token length.
      const tokenize = (minLen) =>
        normSentence
          .replace(/[^\w\s]/g, " ")
          .split(/\s+/)
          .filter((t) => t.length >= minLen);

      let tokens = tokenize(4);
      if (tokens.length === 0) tokens = tokenize(3);
      if (tokens.length === 0) tokens = tokenize(2);

      if (tokens.length === 0) return 0.0;

      const blockLower = normBlock.toLowerCase();
      let hits = 0;
      for (const token of tokens) {
        if (blockLower.includes(token.toLowerCase())) hits++;
      }

      return hits / tokens.length;
    }

    function findBestPreviewBlockForExample(example) {
      const blocks = getPreviewBlocks();
      if (blocks.length === 0) return null;

      const sentence = (example?.sentence || "").trim();
      const paraIndex = example?.paragraph_index;

      // If there's no usable sentence text, fall back deterministically.
      if (!sentence) {
        if (typeof paraIndex === "number") {
          const idx = Math.max(0, Math.min(blocks.length - 1, paraIndex));
          return blocks[idx] || blocks[0] || null;
        }
        return blocks[0] || null;
      }

      // 1) Global best (search all blocks). This protects us when paragraph_index is offset
      // by title/name/spacing blocks at the top of docx-preview.
      let globalBest = blocks[0];
      let globalBestScore = -1;

      for (let i = 0; i < blocks.length; i++) {
        const score = scoreBlockMatch(sentence, blocks[i].innerText || "");
        if (score > globalBestScore) {
          globalBestScore = score;
          globalBest = blocks[i];
          if (score === 1.0) break; // can't beat perfect
        }
      }

      // If paragraph_index is missing, just use the global best.
      if (typeof paraIndex !== "number") {
        return globalBest;
      }

      // 2) Local window best (prefer local when it's confident, but widen near top of document)
      const candidates = [];
      const bases = [paraIndex, paraIndex - 1, paraIndex + 1];

      for (const base of bases) {
        if (typeof base !== "number") continue;

        const backward = 4;

        // Near the top, docx-preview often adds extra blocks (title/name/blank lines),
        // so we search farther forward to avoid missing the true first body paragraph.
        const forward = base <= 2 ? 12 : 4;

        const start = Math.max(0, base - backward);
        const end = Math.min(blocks.length - 1, base + forward);

        for (let i = start; i <= end; i++) {
          const score = scoreBlockMatch(sentence, blocks[i].innerText || "");
          candidates.push({ block: blocks[i], score, index: i });
          if (score === 1.0) return blocks[i];
        }
      }

      candidates.sort((a, b) => b.score - a.score);
      const bestLocal = candidates[0];

      // If local is good, use it.
      if (bestLocal && bestLocal.score >= 0.3) {
        return bestLocal.block;
      }

      // Otherwise, if global is decent, use it (THIS fixes first-sentence problems).
      if (globalBestScore >= 0.3) {
        return globalBest;
      }

      // Last resort: old deterministic fallback.
      const fallbackIdx = Math.max(0, Math.min(blocks.length - 1, paraIndex));
      const fallbackIdx2 = Math.max(0, Math.min(blocks.length - 1, paraIndex - 1));
      return blocks[fallbackIdx] || blocks[fallbackIdx2] || globalBest || null;
    }

    function highlightAndScrollToExample(example, statusDivOptional, options = {}) {
      clearPreviewHighlights();
      
      const sentence = example?.sentence || "";
      const blockEl = findBestPreviewBlockForExample(example);
      
      if (!blockEl) {
        if (statusDivOptional) {
          statusDivOptional.textContent = "Couldn't locate it in the preview automatically. Use Copy + paste manually.";
        }
        return { ok: false, hits: [], blockEl: null, used: "none" };
      }
      
      let hits = highlightExactTextInElement(blockEl, sentence);
      let used = "exact";

      // NEW: if exact fails, try anchored match (handles injected "â†’ ..." text inside the sentence)
      if (!hits || hits.length === 0) {
        hits = highlightAnchoredSentenceInElement(blockEl, sentence);
        used = "anchor";
      }

      if (hits && hits.length > 0) {
        const first = hits[0];
        const last = hits[hits.length - 1];

        if (options.scroll !== false) {
          // Scroll to first span
          first.scrollIntoView({ behavior: "smooth", block: "center" });

          // Create selection range that selects the full sentence
          try {
            // Find first text node in first span
            let firstTextNode = first.firstChild;
            while (firstTextNode && firstTextNode.nodeType !== Node.TEXT_NODE) {
              firstTextNode = firstTextNode.firstChild;
            }
            
            // Find first text node in last span
            let lastTextNode = last.firstChild;
            while (lastTextNode && lastTextNode.nodeType !== Node.TEXT_NODE) {
              lastTextNode = lastTextNode.firstChild;
            }
            
            if (firstTextNode && lastTextNode) {
              const range = document.createRange();
              range.setStart(firstTextNode, 0);
              range.setEnd(lastTextNode, lastTextNode.textContent.length);
              
              const sel = window.getSelection();
              sel.removeAllRanges();
              sel.addRange(range);
            }
          } catch (e) {
            // Fallback: select all spans
            try {
              const range = document.createRange();
              range.setStartBefore(first);
              range.setEndAfter(last);
              const sel = window.getSelection();
              sel.removeAllRanges();
              sel.addRange(range);
            } catch (e2) {}
          }

          if (markedPreview) markedPreview.focus();
        }

        if (statusDivOptional) {
          statusDivOptional.textContent = "Highlighted the sentence in the preview. Paste your rewrite to replace it.";
        }
        return { ok: true, hits: hits, blockEl: blockEl, used: used };
      }

      // Only now do paragraph fallback
      console.debug("[FindPreview fallback]", {
        label: example?.label,
        paragraph_index: example?.paragraph_index,
        sentence: example?.sentence,
        normSentence: normalizeForMatch(example?.sentence || "").slice(0, 200),
        normBlock: normalizeForMatch(blockEl?.innerText || "").slice(0, 200),
      });
      blockEl.classList.add("vysti-preview-hit-block");
      blockEl.scrollIntoView({ behavior: "smooth", block: "center" });
      if (markedPreview) markedPreview.focus();
      if (statusDivOptional) {
        statusDivOptional.textContent = "Found the paragraph, but couldn't isolate the exact sentence. You can still paste manually.";
      }
      return { ok: true, hits: [], blockEl: blockEl, used: "paragraph" };
    }

    function cursorHighlightExampleInPreview(example) {
      if (!markedPreview) return;
      clearPreviewHighlights();

      const sentence = example?.sentence || "";
      const paragraphEl = findBestPreviewBlockForExample(example);
      if (!paragraphEl) return;

      let hits = highlightExactTextInElement(paragraphEl, sentence);
      if (!hits || hits.length === 0) {
        hits = highlightAnchoredSentenceInElement(
          paragraphEl,
          sentence,
          buildAnchorCandidates(sentence)
        );
      }

      if (hits && hits.length > 0) {
        hits.forEach((span) => span.classList.add("vysti-cursor-highlight"));
      }
    }

    function brandedConfirm({ title, body, okText = "Remove", cancelText = "Cancel" } = {}) {
      const overlay = document.getElementById("brandConfirmOverlay");
      const titleEl = document.getElementById("brandConfirmTitle");
      const bodyEl = document.getElementById("brandConfirmBody");
      const okBtn = document.getElementById("brandConfirmOk");
      const cancelBtn = document.getElementById("brandConfirmCancel");
      const closeBtn = overlay?.querySelector(".brand-confirm-close");

      if (!overlay || !titleEl || !bodyEl || !okBtn || !cancelBtn || !closeBtn) {
        return Promise.resolve(window.confirm(body || "Are you sure?"));
      }

      return new Promise((resolve) => {
        let resolved = false;

        const cleanup = () => {
          overlay.hidden = true;
          document.removeEventListener("keydown", onKeyDown);
          overlay.removeEventListener("click", onOverlayClick);
          okBtn.removeEventListener("click", onOk);
          cancelBtn.removeEventListener("click", onCancel);
          closeBtn.removeEventListener("click", onCancel);
        };

        const finish = (result) => {
          if (resolved) return;
          resolved = true;
          cleanup();
          resolve(result);
        };

        const onOk = () => finish(true);
        const onCancel = () => finish(false);
        const onOverlayClick = (event) => {
          if (event.target === overlay) {
            finish(false);
          }
        };
        const onKeyDown = (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            finish(false);
          }
        };

        titleEl.textContent = title || "Confirm";
        bodyEl.textContent = body || "";
        okBtn.textContent = okText || "Remove";
        cancelBtn.textContent = cancelText || "Cancel";

        overlay.hidden = false;
        okBtn.focus();

        document.addEventListener("keydown", onKeyDown);
        overlay.addEventListener("click", onOverlayClick);
        okBtn.addEventListener("click", onOk);
        cancelBtn.addEventListener("click", onCancel);
        closeBtn.addEventListener("click", onCancel);
      });
    }

    function removeIssueLabelAndHighlight(label, example, options = {}) {
      const {
        statusDiv = null,
        actionBtn = null,
        scroll = true,
        allowParagraphFallback = false,
        silent = false
      } = options;

      if (markedPreviewCard.style.display === "none" || !markedPreview || !markedPreview.innerText.trim()) {
        if (!silent && statusDiv) {
          statusDiv.textContent = "Click \"Mark my essay\" to load the preview first.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return { ok: false };
      }

      const result = highlightAndScrollToExample(example, null, { scroll });
      if (!result.ok || !result.blockEl) {
        if (!silent && statusDiv) {
          statusDiv.textContent = "Couldn't locate the sentence in the preview.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return { ok: false };
      }

      if (!allowParagraphFallback && (!result.hits || result.hits.length === 0)) {
        if (!silent && statusDiv) {
          statusDiv.textContent = "Couldn't isolate the exact sentence in preview. Try Find in preview first.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return { ok: false };
      }

      const blockEl = result.blockEl;
      const labelText = `â†’ ${label}`;
      const normalizeWhitespace = (text) => (text || "").replace(/\s+/g, " ").trim();
      const arrowCandidates = Array.from(blockEl.querySelectorAll("span, a"))
        .filter(el => {
          const text = normalizeWhitespace(el.textContent);
          return text.startsWith("â†’") && text.includes(label);
        });

      if (arrowCandidates.length === 0) {
        if (!silent && statusDiv) {
          statusDiv.textContent = "Couldn't find the issue label in the preview.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return { ok: false };
      }

      let selectedLabelEl = arrowCandidates[0];
      if (result.hits && result.hits.length > 0) {
        try {
          const range = document.createRange();
          range.setStartBefore(result.hits[0]);
          range.setEndAfter(result.hits[result.hits.length - 1]);
          const intersecting = arrowCandidates.find(el => range.intersectsNode(el));
          if (intersecting) {
            selectedLabelEl = intersecting;
          } else {
            const firstHitRect = result.hits[0].getBoundingClientRect();
            let closest = arrowCandidates[0];
            let closestDist = Number.POSITIVE_INFINITY;
            arrowCandidates.forEach(el => {
              const rect = el.getBoundingClientRect();
              const dist = Math.abs(rect.top - firstHitRect.top);
              if (dist < closestDist) {
                closest = el;
                closestDist = dist;
              }
            });
            selectedLabelEl = closest;
          }
        } catch (e) {
          selectedLabelEl = arrowCandidates[0];
        }
      }

      let removalTarget = selectedLabelEl;
      if (selectedLabelEl.parentElement && selectedLabelEl.parentElement.tagName === "SPAN") {
        const parentText = normalizeWhitespace(selectedLabelEl.parentElement.textContent);
        const childText = normalizeWhitespace(selectedLabelEl.textContent);
        if (parentText === childText) {
          removalTarget = selectedLabelEl.parentElement;
        }
      }

      if (normalizeWhitespace(removalTarget.textContent) !== normalizeWhitespace(labelText)) {
        // Still remove the best label match to avoid leaving the arrow label behind.
      }

      const hasInlineHighlight = (el) => {
        if (!el || el.nodeType !== Node.ELEMENT_NODE) return false;
        if (el.style && (el.style.backgroundColor || el.style.background)) return true;
        return !!el.querySelector("*[style*='background']");
      };

      const clearInlineHighlight = (el) => {
        if (!el || el.nodeType !== Node.ELEMENT_NODE) return;
        if (el.style) {
          el.style.backgroundColor = "";
          el.style.background = "";
        }
        el.querySelectorAll("*").forEach(child => {
          if (child.style) {
            child.style.backgroundColor = "";
            child.style.background = "";
          }
        });
      };

      let sibling = removalTarget.previousSibling;
      while (sibling) {
        if (sibling.nodeType !== Node.ELEMENT_NODE) break;
        const el = sibling;
        if (!hasInlineHighlight(el)) break;
        clearInlineHighlight(el);
        sibling = sibling.previousSibling;
      }

      removalTarget.remove();

      clearPreviewHighlights();
      if (markedPreview) markedPreview.normalize();

      if (!silent && statusDiv) {
        statusDiv.textContent = "Dismissed from preview. (This will stay dismissed after Recheck.)";
        statusDiv.className = "rewrite-status visible ok";
      }
      if (actionBtn) actionBtn.disabled = true;

      const exampleRow = actionBtn?.closest(".example-item");
      if (exampleRow) {
        exampleRow.classList.add("example-dismissed");
      }

      return { ok: true, blockEl: result.blockEl };
    }

    async function removeIssueFromPreview(label, example, statusDiv, removeBtn) {
      if (markedPreviewCard.style.display === "none" || !markedPreview || !markedPreview.innerText.trim()) {
        statusDiv.textContent = "Click \"Mark my essay\" to load the preview first.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      const ok = await brandedConfirm({
        title: "Remove from preview?",
        body: "Remove this issue label + highlight from the preview?"
      });
      if (!ok) {
        return;
      }
      removeIssueLabelAndHighlight(label, example, {
        statusDiv,
        actionBtn: removeBtn,
        scroll: true,
        allowParagraphFallback: false,
        silent: false
      });
    }

    function applyDismissalsToPreviewDOM() {
      if (!selectedFile || !markedPreview || !markedPreview.innerText.trim()) return;
      const records = dismissedIssues.filter((record) => record?.file_name === selectedFile.name);
      if (!records.length) return;
      records.forEach((record) => {
        removeIssueLabelAndHighlight(record?.label || "", {
          label: record?.label || "",
          sentence: record?.sentence || "",
          paragraph_index: record?.paragraph_index ?? null
        }, {
          scroll: false,
          allowParagraphFallback: true,
          silent: true
        });
      });
    }

    async function openDismissIssueModal() {
      if (!dismissIssueOverlay || !dismissConfirmBtn || !dismissCancelBtn) {
        return { confirmed: false, reason: null, other_text: null };
      }

      const reasonInputs = Array.from(
        dismissIssueOverlay.querySelectorAll('input[name="dismissReason"]')
      );

      return new Promise((resolve) => {
        let resolved = false;

        const cleanup = () => {
          dismissIssueOverlay.classList.add("hidden");
          document.removeEventListener("keydown", onKeyDown);
          dismissIssueOverlay.removeEventListener("click", onOverlayClick);
          dismissCancelBtn.removeEventListener("click", onCancel);
          dismissConfirmBtn.removeEventListener("click", onConfirm);
          reasonInputs.forEach((input) => input.removeEventListener("change", onReasonChange));
          if (dismissOtherText) {
            dismissOtherText.removeEventListener("input", onOtherInput);
          }
        };

        const finish = (confirmed, reason = null, otherText = null) => {
          if (resolved) return;
          resolved = true;
          cleanup();
          resolve({ confirmed, reason, other_text: otherText });
        };

        const getSelectedReason = () => {
          const checked = reasonInputs.find((input) => input.checked);
          return checked ? checked.value : "";
        };

        const setError = (message) => {
          if (!dismissError) return;
          if (!message) {
            dismissError.textContent = "";
            dismissError.classList.add("hidden");
            return;
          }
          dismissError.textContent = message;
          dismissError.classList.remove("hidden");
        };

        const updateOtherUI = (reason) => {
          const isOther = reason === "other";
          if (dismissOtherText) {
            dismissOtherText.classList.toggle("hidden", !isOther);
            if (isOther) dismissOtherText.focus();
          }
          if (dismissCharCount) {
            dismissCharCount.classList.toggle("hidden", !isOther);
          }
        };

        const updateCharCount = () => {
          if (!dismissOtherText || !dismissCharCount) return;
          const len = (dismissOtherText.value || "").length;
          dismissCharCount.textContent = `${len}/280`;
        };

        const updateConfirmState = () => {
          const reason = getSelectedReason();
          const isOther = reason === "other";
          const otherText = dismissOtherText ? dismissOtherText.value.trim() : "";
          const valid = reason && (!isOther || otherText.length > 0);
          dismissConfirmBtn.disabled = !valid;
        };

        const onReasonChange = () => {
          const reason = getSelectedReason();
          updateOtherUI(reason);
          updateCharCount();
          setError("");
          updateConfirmState();
        };

        const onOtherInput = () => {
          updateCharCount();
          updateConfirmState();
        };

        const onCancel = () => finish(false, null, null);

        const onConfirm = () => {
          const reason = getSelectedReason();
          if (!reason) {
            setError("Please select a reason to continue.");
            return;
          }
          const isOther = reason === "other";
          const otherText = dismissOtherText ? dismissOtherText.value.trim() : "";
          if (isOther && !otherText) {
            setError("Please add a brief explanation for â€œOther.â€");
            return;
          }
          setError("");
          finish(true, reason, isOther ? otherText : null);
        };

        const onOverlayClick = (event) => {
          if (event.target === dismissIssueOverlay) {
            finish(false, null, null);
          }
        };

        const onKeyDown = (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            finish(false, null, null);
          }
        };

        // Reset state
        reasonInputs.forEach((input) => (input.checked = false));
        if (dismissOtherText) dismissOtherText.value = "";
        updateOtherUI("");
        updateCharCount();
        setError("");
        dismissConfirmBtn.disabled = true;

        dismissIssueOverlay.classList.remove("hidden");
        dismissCancelBtn.focus();

        document.addEventListener("keydown", onKeyDown);
        dismissIssueOverlay.addEventListener("click", onOverlayClick);
        dismissCancelBtn.addEventListener("click", onCancel);
        dismissConfirmBtn.addEventListener("click", onConfirm);
        reasonInputs.forEach((input) => input.addEventListener("change", onReasonChange));
        if (dismissOtherText) {
          dismissOtherText.addEventListener("input", onOtherInput);
        }
      });
    }

    async function dismissIssue(label, example, statusDiv, btn) {
      const modalResult = await openDismissIssueModal();
      if (!modalResult.confirmed) return;

      const fileName = selectedFile?.name || "nofile";
      const record = {
        label: label || "",
        sentence: example?.sentence || "",
        paragraph_index: example?.paragraph_index ?? null,
        file_name: fileName,
        created_at: new Date().toISOString(),
        reason: modalResult.reason,
        other_text: modalResult.other_text || null
      };

      dismissedIssues.push(record);
      saveDismissedIssuesToStorage();

      try {
        const { data: sessionData } = await supa.auth.getSession();
        const userId = sessionData?.session?.user?.id;
        if (userId) {
          const currentMode = modeSelect ? modeSelect.value : "textual_analysis";
          const { error } = await supa
            .from("dismissed_issue_feedback")
            .insert({
              user_id: userId,
              file_name: fileName,
              mark_event_id: currentMarkEvent?.id || null,
              mode: currentMode,
              issue_label: label || "",
              paragraph_index: record.paragraph_index,
              sentence: record.sentence,
              reason: modalResult.reason,
              other_text: modalResult.other_text || null
            });
          if (error) {
            console.warn("Dismissed issue feedback insert failed:", error);
          }
        }
      } catch (error) {
        console.warn("Dismissed issue feedback insert failed:", error);
      }

      removeIssueLabelAndHighlight(label, example, {
        statusDiv,
        actionBtn: btn,
        scroll: true,
        allowParagraphFallback: true,
        silent: false
      });

      const rawCounts = currentMarkEvent?.label_counts || liveLabelCounts || {};
      liveLabelCounts = { ...applyDismissalsToLabelCounts(rawCounts) };
      refreshIssueCountUI();
      renderMostCommonIssues(liveLabelCounts);

      currentExamplesAll = filterDismissedExamples(currentLabel || label, currentExamplesAll);
      if (!currentExamplesAll.length) {
        showExamplesEmptyState(
          "All examples for this issue have been dismissed. Click another bar to revise a different issue."
        );
        updateAllApprovedBanner([]);
        if (exampleNavRow) exampleNavRow.style.display = "none";
        downloadRevisionNotesBtn.style.display = "none";
        updateApplyAllUI();
        return;
      }

      renderCurrentExample();
    }

    function normalizeWhitespaceAndQuotes(value) {
      if (!value) return "";
      const straightened = value
        .replace(/[\u2018\u2019]/g, "'")
        .replace(/[\u201C\u201D]/g, "\"");
      return straightened.replace(/\s+/g, " ").trim();
    }

    function normalizeLabelForPayload(value) {
      if (!value) return "";
      return value.replace(/\s+/g, " ").trim();
    }

    async function checkRewrite(label, example, textarea, statusDiv, checkBtn) {
      const rewrite = textarea.value.trim();
      if (!rewrite) {
        statusDiv.textContent = "Please enter a rewrite first.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      const contextText = extractPreviewText();
      if (!contextText || !contextText.trim()) {
        statusDiv.textContent = "Load the Preview first (click 'Mark my essay') before checking rewrites.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      const originalSentence = example?.sentence || "";
      if (originalSentence) {
        const normalizedRewrite = normalizeWhitespaceAndQuotes(rewrite);
        const normalizedOriginal = normalizeWhitespaceAndQuotes(originalSentence);
        if (normalizedRewrite && normalizedRewrite === normalizedOriginal) {
          statusDiv.textContent = "No changes detected â€” edit the example before checking.";
          statusDiv.className = "rewrite-status visible bad";
          return;
        }
      }

      const { data: sessionData } = await supa.auth.getSession();
      if (!sessionData || !sessionData.session) {
        statusDiv.textContent = "You must be logged in.";
        statusDiv.className = "rewrite-status visible bad";
        return;
      }

      statusDiv.textContent = "Checking";
      statusDiv.className = "rewrite-status visible checking";
      statusDiv.classList.remove("ok", "bad");
      if (checkBtn) {
        checkBtn.disabled = true;
      }

      try {
        const API_BASE = "https://vysti-rules.onrender.com";
        const currentMode = modeSelect ? modeSelect.value : "textual_analysis";
        const response = await fetch(`${API_BASE}/revision/check`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${sessionData.session.access_token}`,
          },
          body: JSON.stringify({
            label: label,
          label_trimmed: normalizeLabelForPayload(label),
            rewrite: rewrite,
            mode: currentMode,
            context_text: contextText,
            original_sentence: originalSentence || null,
            paragraph_index: example?.paragraph_index ?? null,
          }),
        });

        if (!response.ok) {
          const text = await response.text();
          throw new Error(`HTTP ${response.status}: ${text.substring(0, 100)}`);
        }

        const result = await response.json();
        const ok = !!result.approved;
        const exampleRow = statusDiv.closest(".example-item");
        const exampleKey = getExampleKey(example);

        if (ok) {
          if (exampleRow && exampleRow.dataset.movingApproved === "1") return;
          if (exampleRow) exampleRow.dataset.movingApproved = "1";
          statusDiv.className = "rewrite-status visible ok";
          statusDiv.textContent = "Approved!";

          setTimeout(() => {
            if (exampleKey) {
              approvedRewriteByKey.set(exampleKey, rewrite);
              approvedExampleKeys.add(exampleKey);
              setExampleApprovalState(exampleKey, true);
              draftRewriteByKey.set(exampleKey, rewrite);
              if (!exampleDataByKey.has(exampleKey)) {
                exampleDataByKey.set(exampleKey, example);
              }
              upsertApprovedRewrite({
                label: label || example?.label || "",
                exampleKey,
                originalSentence: example?.sentence || "",
                rewriteText: rewrite,
                examplePayload: example
              });
            }
            if (exampleRow) {
              exampleRow.classList.add("example-approved");
              exampleRow.dataset.approvedRewrite = rewrite;
              if (exampleKey) exampleRow.dataset.exampleKey = exampleKey;
              const applyBtn = exampleRow.querySelector(".apply-to-preview-btn");
              if (applyBtn) {
                applyBtn.disabled = false;
                setApplyAttention(applyBtn);
              }
            }
            renderApprovedRewritesList();
            renderCurrentExample();
            if (exampleRow) delete exampleRow.dataset.movingApproved;
          }, 600);
          return;
        }

        statusDiv.textContent = result.message || "Looks like we still have an issue.";
        statusDiv.className = "rewrite-status visible bad";

        if (exampleKey && exampleRow && approvedExampleKeys.has(exampleKey)) {
          const applyBtn = exampleRow.querySelector(".apply-to-preview-btn");
          revokeApprovedRewrite({
            exampleKey,
            exampleRow,
            applyBtn,
            statusDiv
          });
        }
      } catch (error) {
        console.error("Error checking rewrite:", error);
        statusDiv.textContent = `Error: ${error.message}`;
        statusDiv.className = "rewrite-status visible bad";
      } finally {
        statusDiv.classList.remove("checking");
        if (checkBtn) {
          checkBtn.disabled = false;
        }
      }
    }

    function applyRewriteToPreviewByKey({
      exampleKey,
      rewriteText,
      exampleData,
      statusDiv,
      applyBtn,
      exampleRow,
      scroll = true
    }) {
      if (applyBtn) clearApplyAttention(applyBtn);
      // Ensure preview exists
      if (markedPreviewCard.style.display === "none" || !markedPreview || !markedPreview.innerText.trim()) {
        if (statusDiv) {
          statusDiv.textContent = "Click \"Mark my essay\" to load the preview first.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return false;
      }
      hasStartedRevising = true;

      const resolvedExampleData = exampleData || exampleRow?._exampleData || exampleDataByKey.get(exampleKey);
      const resolvedKey = exampleKey || getExampleKey(resolvedExampleData);
      const resolvedRewrite = rewriteText || approvedRewriteByKey.get(resolvedKey);

      if (!resolvedRewrite) {
        if (statusDiv) {
          statusDiv.textContent = "Please check and approve your rewrite first.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return false;
      }

      if (!resolvedExampleData) {
        if (statusDiv) {
          statusDiv.textContent = "Unable to locate the original example for preview replacement.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return false;
      }

      const label = exampleRow?.dataset?.label || resolvedExampleData?.label || currentLabel || "";

      // Find the sentence in preview
      clearPreviewHighlights();
      const result = highlightAndScrollToExample(resolvedExampleData, null, { scroll });
      
      if (!result.ok || result.hits.length === 0) {
        if (statusDiv) {
          statusDiv.textContent = "Couldn't isolate the exact sentence in preview â€” please paste manually.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return false;
      }

      // Replace the matched range with the approved rewrite
      try {
        const first = result.hits[0];
        const last = result.hits[result.hits.length - 1];
        const range = document.createRange();
        range.setStartBefore(first);
        range.setEndAfter(last);
        range.deleteContents();

        // Insert rewrite as a styled span so it doesn't inherit UI fonts
        const rewriteSpan = document.createElement("span");
        rewriteSpan.className = "vysti-applied-rewrite";
        rewriteSpan.textContent = resolvedRewrite;

        range.insertNode(rewriteSpan);
        rewriteSpan.classList.add("vysti-flash-highlight");
        setTimeout(() => rewriteSpan.classList.remove("vysti-flash-highlight"), 1200);

        // Move caret after inserted rewrite (nice UX, avoids weird selection states)
        range.setStartAfter(rewriteSpan);
        range.collapse(true);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);

        // Normalize to merge any split text nodes after DOM surgery
        if (markedPreview) markedPreview.normalize();
        
        // Clear any leftover highlight styling
        clearPreviewHighlights();
        
        // Update UI
        if (statusDiv) {
          statusDiv.textContent = "Applied";
          statusDiv.className = "rewrite-status visible ok";
        }
        if (applyBtn) applyBtn.disabled = true;
        
        // Mark example as applied
        if (exampleRow) {
          exampleRow.classList.add("example-applied");
          exampleRow.dataset.applied = "true";
        }

        if (resolvedKey) {
          appliedExampleKeys.add(resolvedKey);
          setExampleAppliedState(resolvedKey, true, label);
        }
        if (resolvedKey) {
          removeApprovedRewriteByKey(resolvedKey);
          renderApprovedRewritesList();
        }
        if (label) {
          liveLabelCounts[label] = Math.max(0, (liveLabelCounts[label] || 0) - 1);
          if (!liveLabelCounts[label]) {
            delete liveLabelCounts[label];
          }
        }
        renderMostCommonIssues(liveLabelCounts);
        refreshIssueCountUI();
        updateApplyAllUI();
        updateAllApprovedBanner(currentExamplesAll);
        
        // Show recheck button if hidden
        hideMarkButtonShowRecheck();

        // Update meters immediately after applying rewrite
        void refreshStudentMetrics();
        updateWordCountFromPreviewDebounced?.(0);
        return true;
      } catch (error) {
        console.error("Error applying rewrite:", error);
        if (statusDiv) {
          statusDiv.textContent = "Error applying rewrite. Please paste manually.";
          statusDiv.className = "rewrite-status visible bad";
        }
        return false;
      }
    }

    function downloadRevisionNotes(label, examples) {
      let content = `Revision Notes: ${label}\n\n`;
      
      examples.forEach((ex, idx) => {
        content += `Example ${idx + 1}:\n`;
        content += `Original: ${ex.sentence || ""}\n`;
        const key = getExampleKey(ex);
        const rewrite = approvedRewriteByKey.get(key) || draftRewriteByKey.get(key) || "";
        if (rewrite) {
          content += `Your rewrite: ${rewrite}\n`;
        }
        content += `\n`;
      });
      
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `revision_notes_${label.replace(/\s+/g, "_")}.txt`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Recheck document button handler
    if (recheckDocumentBtn) {
      recheckDocumentBtn.addEventListener("click", async () => {
        resetRevisionPracticeUI();
        if (!selectedFile || !markedPreview) {
          return;
        }
        hasStartedRevising = true;

        // Extract current preview text in a paragraph-preserving way
        const previewText = extractPreviewText();
        if (!previewText) {
          statusArea.textContent = "Could not extract text from preview.";
          statusArea.className = "status-area error";
          if (resultsCard) resultsCard.style.display = "block";
          return;
        }

        // Update Word count immediately based on what we are rechecking
        currentWordCount = wordCountFromText(previewText);
        updateStatsPanel(liveLabelCounts);

        // Get session
        const { data: sessionData } = await supa.auth.getSession();
        if (!sessionData || !sessionData.session) {
          statusArea.textContent = "You must be logged in.";
          statusArea.className = "status-area error";
          if (resultsCard) resultsCard.style.display = "block";
          return;
        }

        // Update UI
        statusArea.textContent = "Rechecking document...";
        statusArea.className = "status-area";
        startButtonLoading(recheckDocumentBtn, "Recheck my essay");

        try {
          const API_BASE = "https://vysti-rules.onrender.com";
          const currentMode = modeSelect ? modeSelect.value : "textual_analysis";
          const markTextPayload = {
            file_name: selectedFile.name,
            text: previewText,
            mode: currentMode,
            highlight_thesis_devices: false,
            student_mode: true,
          };
          if (detectedWork && detectedWork.confidence === "high") {
            markTextPayload.titles = [{
              author: detectedWork.author,
              title: detectedWork.title,
              is_minor: detectedWork.isMinor
            }];
          }
          const response = await fetch(`${API_BASE}/mark_text`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${sessionData.session.access_token}`,
            },
            body: JSON.stringify(markTextPayload),
          });

          if (!response.ok) {
            const text = await response.text();
            throw new Error(`HTTP ${response.status}: ${text.substring(0, 100)}`);
          }

          const techHeader = response.headers.get("X-Vysti-Techniques");
          if (techHeader) {
            try {
              const parsed = JSON.parse(techHeader);
              currentTechniques = Array.isArray(parsed) ? parsed : [];
            } catch (err) {
              console.warn("Failed to parse techniques header:", err);
              currentTechniques = [];
            }
          } else {
            currentTechniques = [];
          }

          const blob = await response.blob();
          markedBlob = blob;
          downloadUrl = URL.createObjectURL(blob);

          // Replace the preview with the returned docx blob
          markedPreview.innerHTML = "";
          const buf = await blob.arrayBuffer();
          if (typeof docx !== "undefined" && docx.renderAsync) {
            await docx.renderAsync(buf, markedPreview, null, { inWrapper: true });
            removeRewritePracticeTagsFromPreview(markedPreview);
            markedPreview.contentEditable = "true";
            markedPreview.spellcheck = true;
            markedPreview.classList.add("preview-editable");
            applyPreviewZoom();
            updateStatsPanel(liveLabelCounts);
            await refreshStudentMetrics();
            applyDismissalsToPreviewDOM();
            makePreviewLabelsClickable();
          } else {
            markedPreview.innerHTML = "<p>Preview not available. Please download the file to view.</p>";
            updateStatsPanel(liveLabelCounts);
            await refreshStudentMetrics();
          }

          // Reload revision practice to refresh issues + examples
          await loadRevisionPractice();

          const totalIssues = totalIssuesFromLabelCounts(liveLabelCounts);
          if (totalIssues === 0) {
            statusArea.textContent = "Document appears to pass all of Vysti's rules. Ready to download.";
            if (mostCommonIssuesWrap) {
              mostCommonIssuesWrap.style.display = "none";
              mostCommonIssuesWrap.dataset.hasData = "false";
            }
            if (revisionPracticeCard) revisionPracticeCard.style.display = "none";
          } else {
            statusArea.textContent = "Document rechecked. Preview updated.";
          }
          statusArea.className = "status-area success";
          ensurePostPreviewTourVisibility();
          startPostPreviewTour();
        } catch (error) {
          console.error("Error rechecking document:", error);
          statusArea.textContent = `Error: ${error.message}`;
          statusArea.className = "status-area error";
        } finally {
          stopButtonLoading(
            recheckDocumentBtn,
            () => !!selectedFile
          );
        }
      });
    }

    function extractPreviewText() {
      if (!markedPreview) return null;
      
      // Collect all <p> and <li> in preview container and join with \n\n
      const paragraphs = [];
      const elements = markedPreview.querySelectorAll("p, li");
      
      for (const el of elements) {
        if (el.closest("table") || el.closest(".docx-table")) continue;
        // Use clean extraction that excludes Vysti artifacts
        const text = extractCleanTextFromElement(el);
        if (!text) continue;
        const trimmed = text.trim();
        if (
          trimmed === "Issue" ||
          trimmed === "Explanation" ||
          trimmed === "Issue Explanation"
        ) {
          continue;
        }
        paragraphs.push(text);
      }
      
      // If no paragraphs found, try getting all text (also clean)
      if (paragraphs.length === 0) {
        const allText = extractCleanTextFromElement(markedPreview);
        if (allText) {
          return allText;
        }
        return null;
      }
      
      return paragraphs.join("\n\n");
    }
    function wordCountFromText(text) {
      const t = String(text || "");
      // Count tokens like: word, don't, Fisher's
      const words = t.match(/\b[A-Za-z]+(?:'[A-Za-z]+)?\b/g) || [];
      return words.length;
    }


    // =========================
    // Student tour controller
    // =========================

    const preUploadTourSteps = [
      {
        anchor: "#mode",
        title: "Assignment type",
        body: "Choose the assignment type so Vysti applies the right rules.",
      },
      {
        anchor: "#assignmentName",
        title: "Assignment Tracker",
        body: "Name and number your draft to track progress.",
      },
      {
        anchor: "#dropZone",
        title: "Upload",
        body: "Upload your .docx file here.",
      },
    ];

    const postUploadTourSteps = [
      {
        anchor: "#checkBtn",
        title: "Mark my essay",
        body: "Click here to generate a preview and revise your work.",
      },
    ];

    const postPreviewTourSteps = [
      {
        anchor: "#downloadBtn",
        title: "Download",
        body: "You can download your marked essay now or revise it first.",
      },
      {
        anchor: "#mostCommonIssuesWrap",
        title: "Most Common Issues",
        body: "Hover to see an explanation. Click a bar to jump to an example.",
      },
      {
        anchor: "#markedPreviewCard",
        title: "Preview",
        body: "Edit your document directly in this Preview. Use Zoom if you need it. Changes here arenâ€™t finalized until you recheck.",
      },
      {
        anchor: "#recheckDocumentBtn",
        title: "Recheck",
        body: "After editing the Preview, click here to regenerate your feedback. Edits can fix issues â€” but can also create new ones.",
      },
      {
        anchor: "#examplesList",
        title: "Practice a revision",
        body: "Follow Vysti's guidance to repair your work, then click 'Check rewrite'. If it's approved , click â€˜Apply to Previewâ€™ to update your document.",
      },
    ];

    let activeTourSteps = preUploadTourSteps;

    const tourState = {
      currentStepIndex: 0,
      active: false,
    };

    let tourOverlay = null;
    let tourPopover = null;
    let tourTitle = null;
    let tourBody = null;
    let tourStep = null;
    let tourNextBtn = null;
    let tourCloseBtn = null;
    let tourHideCheckbox = null;
    let tourArrow = null;
    let tourPositionHandler = null;

    function createTourElements() {
      if (tourPopover) return;

      tourOverlay = document.createElement("div");
      tourOverlay.className = "tour-overlay";

      tourPopover = document.createElement("div");
      tourPopover.className = "tour-popover";
      tourPopover.setAttribute("role", "dialog");
      tourPopover.setAttribute("aria-live", "polite");

      tourCloseBtn = document.createElement("button");
      tourCloseBtn.className = "tour-close";
      tourCloseBtn.type = "button";
      tourCloseBtn.setAttribute("aria-label", "Close tour");
      tourCloseBtn.textContent = "Ã—";

      tourArrow = document.createElement("div");
      tourArrow.className = "tour-arrow";

      tourTitle = document.createElement("div");
      tourTitle.className = "tour-title";

      tourBody = document.createElement("div");
      tourBody.className = "tour-body";

      const footer = document.createElement("div");
      footer.className = "tour-footer";

      tourStep = document.createElement("div");
      tourStep.className = "tour-step";

      const checkboxLabel = document.createElement("label");
      checkboxLabel.className = "tour-checkbox-row";
      tourHideCheckbox = document.createElement("input");
      tourHideCheckbox.type = "checkbox";
      tourHideCheckbox.id = "tourHideCheckbox";
      checkboxLabel.appendChild(tourHideCheckbox);
      checkboxLabel.appendChild(document.createTextNode(" Do not show again"));

      tourNextBtn = document.createElement("button");
      tourNextBtn.className = "tour-primary-btn";
      tourNextBtn.type = "button";
      tourNextBtn.textContent = "Got it";

      footer.appendChild(tourStep);
      footer.appendChild(checkboxLabel);
      footer.appendChild(tourNextBtn);

      tourPopover.appendChild(tourCloseBtn);
      tourPopover.appendChild(tourArrow);
      tourPopover.appendChild(tourTitle);
      tourPopover.appendChild(tourBody);
      tourPopover.appendChild(footer);

      document.body.appendChild(tourOverlay);
      document.body.appendChild(tourPopover);

      tourNextBtn.addEventListener("click", nextStep);
      tourCloseBtn.addEventListener("click", () => closeTour("dismissed"));
      tourHideCheckbox.addEventListener("change", () => {
        if (tourHideCheckbox.checked) {
          closeTour("hide");
        }
      });
    }

    function getCurrentAnchor() {
      const step = activeTourSteps[tourState.currentStepIndex];
      if (!step) return null;
      return document.querySelector(step.anchor);
    }

    function clearTourHighlight() {
      const highlighted = document.querySelector(".tour-highlight");
      if (highlighted) highlighted.classList.remove("tour-highlight");
    }

    function positionTourPopover(anchorEl) {
      if (!tourPopover || !anchorEl) return;

      const gap = 12;
      const padding = 12;
      const rect = anchorEl.getBoundingClientRect();

      tourPopover.style.display = "block";
      tourPopover.style.visibility = "hidden";

      const popRect = tourPopover.getBoundingClientRect();
      const fitsBelow = rect.bottom + gap + popRect.height <= window.innerHeight;

      let top = fitsBelow ? rect.bottom + gap : rect.top - popRect.height - gap;
      top = Math.max(padding, Math.min(top, window.innerHeight - popRect.height - padding));

      let left = rect.left + rect.width / 2 - popRect.width / 2;
      left = Math.max(padding, Math.min(left, window.innerWidth - popRect.width - padding));

      tourPopover.style.top = `${Math.round(top)}px`;
      tourPopover.style.left = `${Math.round(left)}px`;

      tourArrow.classList.toggle("tour-arrow-down", fitsBelow);
      tourArrow.classList.toggle("tour-arrow-up", !fitsBelow);

      const anchorCenter = rect.left + rect.width / 2;
      const arrowLeft = Math.max(16, Math.min(anchorCenter - left, popRect.width - 16));
      tourArrow.style.left = `${Math.round(arrowLeft)}px`;
      tourArrow.style.top = fitsBelow ? "-6px" : "";
      tourArrow.style.bottom = fitsBelow ? "" : "-6px";

      tourPopover.style.visibility = "visible";
    }

    function attachTourPositioning() {
      if (tourPositionHandler) return;
      tourPositionHandler = () => {
        if (!tourState.active) return;
        const anchorEl = getCurrentAnchor();
        if (anchorEl) positionTourPopover(anchorEl);
      };
      window.addEventListener("resize", tourPositionHandler);
      window.addEventListener("scroll", tourPositionHandler, true);
    }

    function detachTourPositioning() {
      if (!tourPositionHandler) return;
      window.removeEventListener("resize", tourPositionHandler);
      window.removeEventListener("scroll", tourPositionHandler, true);
      tourPositionHandler = null;
    }

    function showStep(index) {
      if (index < 0 || index >= activeTourSteps.length) {
        closeTour("completed");
        return;
      }

      let anchorEl = null;
      let step = null;
      let resolvedIndex = index;

      for (let i = index; i < activeTourSteps.length; i += 1) {
        const candidate = activeTourSteps[i];
        const candidateAnchor = document.querySelector(candidate.anchor);
        if (candidateAnchor) {
          resolvedIndex = i;
          step = candidate;
          anchorEl = candidateAnchor;
          break;
        }
      }

      if (!anchorEl || !step) {
        closeTour("dismissed");
        return;
      }

      tourState.currentStepIndex = resolvedIndex;

      clearTourHighlight();
      anchorEl.classList.add("tour-highlight");
      anchorEl.scrollIntoView({ block: "center", behavior: "smooth" });

      tourTitle.textContent = step.title;
      tourBody.textContent = step.body;
      tourStep.textContent = `${resolvedIndex + 1} of ${activeTourSteps.length}`;

      tourOverlay.style.display = "block";
      tourPopover.style.display = "block";

      attachTourPositioning();

      requestAnimationFrame(() => {
        positionTourPopover(anchorEl);
        setTimeout(() => positionTourPopover(anchorEl), 350);
      });
    }

    function startTourAt(index, { force = false, steps = preUploadTourSteps } = {}) {
      if (!force && !shouldShowStudentHelpers()) return;
      activeTourSteps = steps;
      createTourElements();
      tourState.active = true;
      tourState.currentStepIndex = index;
      if (force && tourHideCheckbox) {
        tourHideCheckbox.checked = false;
      }
      showStep(index);
    }

    function startTour({ force = false } = {}) {
      startTourAt(0, { force, steps: preUploadTourSteps });
    }

    function clearStudentHelperSuppression() {
      localStorage.removeItem(STUDENT_HELPERS_DISABLED_KEY);
      localStorage.removeItem(TOUR_DONE_KEY);
      localStorage.removeItem(TOUR_HIDE_KEY);
    }

    function getTourStepsForCurrentState() {
      const hasPreviewCard = markedPreviewCard && markedPreviewCard.style.display !== "none";
      const hasPreviewText = markedPreview && markedPreview.innerText.trim().length > 0;
      const hasIssuesData = mostCommonIssuesWrap && mostCommonIssuesWrap.dataset.hasData === "true";
      const hasExamples = examplesList && examplesList.children.length > 0;
      if (hasPreviewCard || hasPreviewText || hasIssuesData || hasExamples) {
        return postPreviewTourSteps;
      }
      if (selectedFile) {
        return postUploadTourSteps;
      }
      return preUploadTourSteps;
    }

    function startTourForCurrentState({ force = false } = {}) {
      const steps = getTourStepsForCurrentState();
      if (steps === postPreviewTourSteps) {
        ensurePostPreviewTourVisibility();
      }
      startTourAt(0, { force, steps });
    }

    async function nextStep() {
      if (tourHideCheckbox && tourHideCheckbox.checked) {
        closeTour("hide");
        return;
      }
      const currentStep = activeTourSteps[tourState.currentStepIndex];
      const isPostPreviewRecheck =
        activeTourSteps === postPreviewTourSteps &&
        currentStep?.anchor === "#recheckDocumentBtn";
      if (isPostPreviewRecheck) {
        if (tourNextBtn) tourNextBtn.disabled = true;
        try {
          const label = await loadRandomIssueForTraining();
          if (!label) {
            closeTour("completed");
            return;
          }
          showStep(tourState.currentStepIndex + 1);
        } finally {
          if (tourNextBtn) tourNextBtn.disabled = false;
        }
        return;
      }
      const nextIndex = tourState.currentStepIndex + 1;
      if (nextIndex >= activeTourSteps.length) {
        closeTour("completed");
        return;
      }
      showStep(nextIndex);
    }

    function closeTour(reason) {
      tourState.active = false;
      detachTourPositioning();
      clearTourHighlight();

      if (tourOverlay) tourOverlay.style.display = "none";
      if (tourPopover) tourPopover.style.display = "none";
      if (reason === "hide") {
        localStorage.setItem(STUDENT_HELPERS_DISABLED_KEY, "1");
        localStorage.setItem(TOUR_DONE_KEY, "1");
      } else if (reason === "completed") {
        localStorage.setItem(TOUR_DONE_KEY, "1");
      }
    }

    function startPostUploadTour() {
      startTourAt(0, { force: FORCE_STUDENT_HELPERS, steps: postUploadTourSteps });
    }

    function ensurePostPreviewTourVisibility() {
      if (resultsCard) resultsCard.style.display = "block";
      if (downloadBtn) downloadBtn.style.display = "block";
      if (markedPreviewCard) markedPreviewCard.style.display = "block";
      hideMarkButtonShowRecheck();
      if (mostCommonIssuesWrap && mostCommonIssuesWrap.dataset.hasData === "true") {
        mostCommonIssuesWrap.style.display = "block";
      }
    }

    function formatOrdinal(n) {
      const num = parseInt(n, 10);
      if (Number.isNaN(num)) return `${n}`;
      const mod100 = num % 100;
      if (mod100 >= 11 && mod100 <= 13) return `${num}th`;
      const mod10 = num % 10;
      if (mod10 === 1) return `${num}st`;
      if (mod10 === 2) return `${num}nd`;
      if (mod10 === 3) return `${num}rd`;
      return `${num}th`;
    }

    function formatBodySectionName(bodyNum) {
      return `${formatOrdinal(bodyNum)} Body Paragraph`;
    }

    function startPostPreviewTour() {
      startTourAt(0, { force: FORCE_STUDENT_HELPERS, steps: postPreviewTourSteps });
    }

    // Initial state
    showMarkButtonHideRecheck();
    updateFileUI();
  </script>
</body>
</html>
